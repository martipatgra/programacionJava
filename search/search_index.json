{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Programaci\u00f3n","text":"<p>Aqu\u00ed puedes encontrar los apuntes del m\u00f3dulo de Programaci\u00f3n, que se imparte en el primer curso del ciclo formativo de grado superior de Desarrollo de Aplicaciones Multiplataforma.</p> <p>La duraci\u00f3n del m\u00f3dulo es de 256 horas lectivas, a raz\u00f3n de  8 horas semanales. Se ha planificado bas\u00e1ndose en 4 sesiones de 2 horas lectivas por semana.</p>"},{"location":"#resultados-de-aprendizaje-y-criterios-de-evaluacion","title":"Resultados de aprendizaje y criterios de evaluaci\u00f3n","text":"<ul> <li>Reconoce la estructura de un programa inform\u00e1tico, identificando y relacionando los elementos propios del lenguaje de programaci\u00f3n utilizado.</li> </ul> Criterios de evaluaci\u00f3n Se han identificado los bloques que componen la estructura de un programa inform\u00e1tico. Se han creado proyectos de desarrollo de aplicaciones Se han utilizado entornos integrados de desarrollo. Se han identificado los distintos tipos de variables y la utilidad espec\u00edfica de cada uno. Se ha modificado el c\u00f3digo de un programa para crear y utilizar variables. Se han creado y utilizado constantes y literales. Se han clasificado, reconocido y utilizado en expresiones los operadores del lenguaje. Se ha comprobado el funcionamiento de las conversiones de tipo expl\u00edcitas e impl\u00edcitas. Se han introducido comentarios en el c\u00f3digo. <ul> <li>Escribe y prueba programas sencillos, reconociendo y aplicando los fundamentos de la programaci\u00f3n orientada a objetos.</li> <li>Escribe y depura c\u00f3digo, analizando y utilizando las estructuras de control del lenguaje.</li> <li>Desarrolla programas organizados en clases analizando y aplicando los principios de la programaci\u00f3n orientada a objetos.</li> <li>Realiza operaciones de entrada y salida de informaci\u00f3n, utilizando procedimientos espec\u00edficos del lenguaje y librer\u00edas de clases.</li> <li>Escribe programas que manipulen informaci\u00f3n seleccionando y utilizando tipos avanzados de datos.</li> <li>Desarrolla programas aplicando caracter\u00edsticas avanzadas de los lenguajes orientados a objetos y del entorno de programaci\u00f3n.</li> <li>Utiliza bases de datos orientadas a objetos, analizando sus caracter\u00edsticas y aplicando t\u00e9cnicas para mantener la persistencia de la informaci\u00f3n.</li> <li>Gestiona informaci\u00f3n almacenada en bases de datos relacionales manteniendo la integridad y consistencia de los datos.</li> </ul>"},{"location":"#unidades-didacticas-temporalizacion","title":"Unidades did\u00e1cticas / Temporalizaci\u00f3n","text":"<p>A continuaci\u00f3n se muestran las unidades did\u00e1cticas y una estimaci\u00f3n temporal de cada una de ellas. El curso est\u00e1 dividido en 10 unidades did\u00e1cticas distribuidas en tres trimestres.</p>"},{"location":"#primera-evaluacion","title":"Primera evaluaci\u00f3n","text":"<p>Compuesta por las 5 primeras unidades, donde se estudiar\u00e1n los aspectos b\u00e1sicos de la programaci\u00f3n orientada a objetos usando el lenguaje de programaci\u00f3n Java.</p> Unidad T\u00edtulo Sesiones Horas 1 Elementos de un programa inform\u00e1tico 10 20 2 Estructuras b\u00e1sicas de control 13 26 3 Programaci\u00f3n orientada a objetos. Clases y Objetos 12 24 4 Arrays 9 18 5 Herencia y polimorfismo 14 28"},{"location":"#segunda-evaluacion","title":"Segunda evaluaci\u00f3n","text":"<p>Incluye 3 unidades y se profundizar\u00e1 en aspectos de codificaci\u00f3n como colecciones de Java, interfaces de usuario, reflections, expresiones regulares, etc.</p> Unidad T\u00edtulo Sesiones Horas 6 Colecciones 15 30 7 Programaci\u00f3n avanzada 10 20 8 Interfaces de usuario 16 32"},{"location":"#tercera-evaluacion","title":"Tercera evaluaci\u00f3n","text":"<p>Por \u00faltimo se aprender\u00e1n t\u00e9cnicas de lectura y escritura y persistencia de la informaci\u00f3n en ficheros y bases de datos.</p> Unidad T\u00edtulo Sesiones Horas 9 Persistencia de la informaci\u00f3n 13 26 10 Bases de datos 16 32"},{"location":"#instrumentos-de-calificacion","title":"Instrumentos de calificaci\u00f3n","text":"<p>La nota de cada evaluaci\u00f3n se calcula mediante:</p> <ul> <li>30% Trabajo en Clase / Actividades<ul> <li>Se eval\u00faan todas las actividades realizadas en clase y en casa.</li> <li>Las actividades se eval\u00faan mediante tareas de Aules con calificaciones comprendidas entre 0 y 3 puntos:<ul> <li>0: No entregada.</li> <li>1: Entregada pero soluci\u00f3n err\u00f3nea o incompleta.</li> <li>2: Entregada y soluci\u00f3n aceptable, aunque tiene alg\u00fan apartado incompleto.</li> <li>3: Entregada y soluci\u00f3n correcta.</li> </ul> </li> <li>Las actividades/pr\u00e1cticas son fundamentales para aprobar la asignatura.</li> <li>Cualquier actividad que se detecte copia ser\u00e1 puntuada con 0.</li> </ul> </li> <li>70% Actividad de evaluaci\u00f3n.<ul> <li>Se deben aprobar ambas partes por separado.</li> </ul> </li> </ul> <p>La nota final se calcula mediante la media de cada una de las evaluaciones.</p>"},{"location":"about/","title":"About","text":"<p>Patricia Mart\u00ed</p> <p>p.marti2@edu.gva.es</p>"},{"location":"about/#bibliografia-y-webgrafia","title":"Bibliograf\u00eda y webgraf\u00eda","text":"<p>https://docs.oracle.com/en/java/</p> <p>Java, Java, Java- Object-Oriented Problem Solving - Third Edition R. Morelli and R. Walde</p>"},{"location":"shortcuts/","title":"Atajos de teclado para IntelliJ","text":""},{"location":"shortcuts/#codigo","title":"C\u00f3digo","text":""},{"location":"shortcuts/#eliminar-imports-que-no-se-usan-ctrl-alt-o","title":"Eliminar imports que no se usan --&gt; CTRL + ALT + o","text":""},{"location":"shortcuts/#formatear-el-codigo-ctrl-alt-l","title":"Formatear el c\u00f3digo --&gt; CTRL + ALT + l","text":""},{"location":"ud1/121conceptosbasicos/","title":"\ud83d\udcbe JAVA","text":"<p>Java es un lenguaje de programaci\u00f3n orientado a objetos. Fue creado por James Gosling en 1995. Oracle lo compr\u00f3. Es un lenguaje indepediente de la plataforma donde va a ser ejecutado, esto significa, que una vez que se compila (.class tambi\u00e9n llamado bytecode) puede ser transportado a diferentes plataformas (Windows, MacOS, Linux) para ser ejecutado. \u00bfC\u00f3mo se hace esto? Utilizando la JVM (Java Virtual Machine). La JVM coge los bytecode compilados y los interpreta dependiendo del OS para poder ser ejecutado. Por tanto, el bytecode siempre es el mismo, pero lo que genera la JVM cambiar\u00e1 para cada SO. Tambi\u00e9n existen otros t\u00e9rminos muy famosos relacionados con Java como JRE y JDK. </p>"},{"location":"ud1/121conceptosbasicos/#jre","title":"JRE","text":"<p>Java Runtime Environment. La m\u00e1quina virtual de Java est\u00e1 incluida en el JRE. Se utiliza para ejecutar aplicaciones Java en el SO, por tanto si queremos desplegar una aplicaci\u00f3n en Java, necesitamos tener instalado previamente el JRE para esa m\u00e1quina y plataforma.</p>"},{"location":"ud1/121conceptosbasicos/#jdk","title":"JDK","text":"<p>Java Development Kit. Es m\u00e1s pesado que el JRE, contiene todas las herramientas para programar y compilar las clases Java en bytecode, por tanto cuando desarrollamos clases Java necesitamos el JDK. Adem\u00e1s incluy el JRE.</p>"},{"location":"ud1/121conceptosbasicos/#versiones-java","title":"Versiones Java","text":"<p>La \u00faltima versi\u00f3n de Java se conoce como LTS Release (Long Term Support), y es JAVA 11 LTS ( la LTS 17 estar\u00e1 disponible 14 de Septiembre 2021). Nosotros para el prop\u00f3sito de este curso usaremos Java 11.</p>"},{"location":"ud1/121conceptosbasicos/#porque-java","title":"\u00bfPorqu\u00e9 Java?","text":"<ul> <li>Naci\u00f3 en 1995 y todav\u00eda sigue siendo uno de los lenguajes m\u00e1s usados a nivel mundial.</li> <li>Su capacidad de escribirlo y ejecutarlo en cualquier plataforma: \"Write once, run anywhere\".</li> <li>Desde que naci\u00f3 han salido muchas releases de gran importancia, el lenguaje sigue evolucionando con nuevas funcionalidades.</li> <li>Tiene un comunidad muy grande de c\u00f3digo abierto, documentaci\u00f3n y tutoriales. Es usado por muchas compa\u00f1\u00edas de software, por tanto se ofertan muchos empleos de desarrolladores Java.</li> </ul>"},{"location":"ud1/122setup/","title":"\ud83d\udcbe \u00bfQu\u00e9 se necesita para programar en Java?","text":"<ul> <li>Instalar el JDK versi\u00f3n 11. Lo podemos descarga desde la p\u00e1gina oficial de Oracle.</li> <li>Instalar un IDE (Integrated Development Environment), es un programa que te ayudar a desarrollar aplicaciones. Hay muchas opciones disponibles de IDEs.</li> </ul>"},{"location":"ud1/122setup/#setup-java-11-y-intellij-en-windows","title":"Setup Java 11 y IntelliJ en Windows","text":"<ol> <li> <p>Vamos a la p\u00e1gina de Oracle y descargamos JDK 11.</p> </li> <li> <p>Instalamos el JDK.</p> </li> </ol> <p>En linux usamos el siguiente comando para instalar el jdk: sudo apt-get install openjdk-11-jdk</p> <ol> <li> <p>Windows: A\u00f1adimos en las variables de entorno del sistema dentro de la variable Path, la ruta donde se ha instalado java en nuestra m\u00e1quina (C:\\Program Files\\Java\\jdk-11\\bin)</p> </li> <li> <p>Windows: Agregamos tambi\u00e9n una nueva variable llamada JAVA_HOME --&gt; C:\\Program Files\\Java\\jdk-11 (Ruta de nuestra m\u00e1quina).</p> </li> <li> <p>Verificamos que se ha instalado java, ejecutando desde l\u00ednea de comandos:</p> </li> </ol> <pre><code>java --version\n</code></pre> <ol> <li> <p>Descargamos e instalamos IntelliJ Community</p> </li> <li> <p>En File -&gt; Settings, modificamos las siguientes opciones:  </p> </li> </ol>"},{"location":"ud1/123holamundo/","title":"\ud83d\udcbe Proyecto \"Hola Mundo\". Estructura de un programa","text":"<p>Cada vez que est\u00e1s aprendiendo un nuevo lenguaje de programaci\u00f3n es una tradici\u00f3n crear un nuevo programa muy simple que genera el texto Hola mundo. Veamos como podemos hacer esto en IntelliJ.</p> <ol> <li>Hacemos click en crear nuevo proyecto y elegimos el JDK 11 que hemos instalado. </li> <li>Luego en Next, Next, a\u00f1adimos nombre al proyecto y Finish.  </li> <li>Creamos una nueva clase Java llamada Hello.java  </li> <li>Vamos a crear un m\u00e9todo para imprimir el mensaje Hola mundo. Usaremos un m\u00e9todo especial llamado main. El main es el primer m\u00e9todo que Java busca y ejecuta en el proyecto. Es el punto de entrada. </li> <li>Ejecutamos el programa mediante </li> <li>A\u00f1adimos y ejecutamos la siguiente sentencia dentro del m\u00e9todo main: System.out.println(\"Hello World\"); </li> </ol>"},{"location":"ud1/123holamundo/#challenge","title":"Challenge","text":"<p>Question</p> <p>Modifica el programa para que imprima por pantalla Hello Teacher.</p> <p>Question</p> <p>Realizar las actividades 1 y 2.</p>"},{"location":"ud1/131variables/","title":"\ud83d\udcbe Variables","text":"<p>Las variables en Java es una forma de almacenar informaci\u00f3n en nuestro ordenador. Definimos variables asign\u00e1ndoles un nombre. De igual manera se puede acceder a la informaci\u00f3n que guardar las variable, simplemente accediendo por el nombre que le hemos dado. Es el ordenador el que se encarga de averiguar d\u00f3nde se almacena internamente en la memoria RAM del ordenador. Como su nombre indica \"variable\", se puede modificar el contenido que \u00e9sta almacena, es decir, es variable. Lo \u00fanico que tenemos que hacer es decirle al PC qu\u00e9 tipo de informaci\u00f3n queremos guardar en nuestra variable y darle un nombre. Existe diferentes tipos de informaci\u00f3n que podemos utilizar para definir nuestras variables. Se les conoce como tipos de datos o data types. Los tipos de datos son palabras reservas keywords en Java, es decir, no podemos utilizarlas fuera del contexto de tipo de datos.  Para definir una variable, necesitamos especificar el tipo de datos, luego darle un nombre a nuestra variable, y opcionalmente, podemos agregar una expresi\u00f3n para inicializar la variable con un valor. </p>"},{"location":"ud1/131variables/#reglas-para-el-nombrado-de-variables","title":"Reglas para el nombrado de variables","text":"<ul> <li> <p>Tiene que comenzar con una letra o '_', nunca con n\u00fameros.</p> </li> <li> <p>Puede contener n\u00fameros. No debe contener espacios en blanco.</p> </li> <li> <p>No debe ser muy largo y debe expresar algo en el contexto.</p> </li> <li> <p>No se pueden usar palabras reservadas.</p> </li> <li> <p>May\u00fasculas y min\u00fasculas se tratan diferente.</p> </li> </ul> <p></p> <p>Definimos nuestra primera variable en el programa de la siguiente forma: </p> <p>La l\u00ednea que acabamos de escribir se conoce como sentencia de declaraci\u00f3n.</p>"},{"location":"ud1/131variables/#keywords","title":"Keywords","text":"<p>Son palabras reservadas del lenguaje. Es decir, son palabras que tienen un significado especial en Java y no puedes usarlas fuera de ese contexto. Ejemplos: public, class, void, static, etc. Existen 61 keywords en Java.</p>"},{"location":"ud1/131variables/#vida-de-las-variables","title":"Vida de las variables","text":"<p>Las variables son memorias reservadas para almacenar valores en RAM. Estas posiciones de memoria se liberan tan pronto como termina la vida de la variable. Seg\u00fan la vida de las variables, hay tres tipos de Variables.</p> <p>1. Variables locales: La vida permanece dentro de un bloque donde se ha declarado.</p> <p>2. Variables de instancia: Declaradas dentro de la clase pero fuera de los m\u00e9todos. No deber\u00eda ser est\u00e1tico.</p> <p>3. Variables est\u00e1ticas: es como una variable global. Declarado como est\u00e1tico en la clase pero fuera de los m\u00e9todos.</p> <pre><code>    static int pi = 3.14;\n</code></pre>"},{"location":"ud1/131variables/#visibilidad","title":"Visibilidad","text":"<p>En las variables locales, su \u00e1mbito y uso se encuentra dentro del m\u00e9todo o bloque en el que se defini\u00f3 y se destruyen despu\u00e9s de la ejecuci\u00f3n del m\u00e9todo. Es decir, no se puede usar una variable local fuera del m\u00e9todo actual.</p> <p>A las variables de instancia se puede acceder solo a trav\u00e9s de objetos de la clase para la que se defini\u00f3.</p> <p>Un campo / variable est\u00e1tico pertenece a la clase y se cargar\u00e1 en la memoria junto con la clase. Se invocan sin crear un objeto. (Usando el nombre de la clase como referencia). Solo hay una copia de la variable est\u00e1tica disponible en toda la clase, es decir, el valor de la variable est\u00e1tica ser\u00e1 el mismo en todos los objetos. Puede definir una variable est\u00e1tica utilizando la palabra clave static.</p>"},{"location":"ud1/131variables/#mutacion-de-las-variables","title":"Mutaci\u00f3n de las variables","text":"<p>Supongamos que hemos ejecutado la siguiente l\u00ednea de c\u00f3digo:</p> <pre><code>int x = 5;\n</code></pre> <p>\u00bfC\u00f3mo podr\u00edamos sumar 6 al valor actualmente almacenado en <code>x</code>? Un enfoque ingenuo podr\u00eda ser probar esta l\u00ednea de c\u00f3digo:</p> <pre><code>    x + 6;\n</code></pre> <p>Sin embargo, esta l\u00ednea de c\u00f3digo es una expresi\u00f3n que da como resultado un valor: no hemos alterado el valor de x.</p> <pre><code>// Recuerda, x es una variable que contiene el valor 5\nx + 6; // se eval\u00faa como:\n5 + 6; // y luego da como resultado:\n11;\n\n// Pero 11; no es una declaraci\u00f3n que Java entienda,\n// entonces el compilador lanza un error cuando ve: x + 6;\n</code></pre> <p>Para aumentar el valor de <code>x</code> en 6, necesitamos reasignar el valor de <code>x</code> para que sea el resultado de <code>x + 6</code>:</p> <pre><code>x = x + 6; // se eval\u00faa como:\nx = 5 + 6; // y luego se suman los valores\nx = 11;// como resultado se asigna el valor 11 a x\n</code></pre> <p>Aqu\u00ed, hemos usado el valor de <code>x</code> para calcular y almacenar un nuevo valor en la variable <code>x</code>; en este caso, 11.</p>"},{"location":"ud1/131variables/#scope-ambito","title":"Scope - \u00c1mbito","text":"<p>El alcance o \u00e1mbito (scope) de una variable es la parte de un programa en la que existe. En Java, el alcance de una variable comienza donde se declara y termina cuando se alcanza la llave de cierre del bloque que la contiene.</p> <pre><code>public static void main(String[] args) {\nint x = 5;\nfor (int i = 1; i &lt;= 5; i++) {\nint y = 10;\nSystem.out.println(x) // \u00a1x todav\u00eda est\u00e1 dentro del alcance aqu\u00ed!\n}\nSystem.out.println(x) // \u00a1x todav\u00eda est\u00e1 dentro del alcance aqu\u00ed tambi\u00e9n!\n}\n</code></pre> <ul> <li><code>x</code> est\u00e1 dentro del alcance entre su declaraci\u00f3n en la l\u00ednea 2 y la llave que la encierra en la l\u00ednea 8.</li> <li><code>y</code> est\u00e1 dentro del alcance entre su declaraci\u00f3n en la l\u00ednea 4 y la llave que la encierra en la l\u00ednea 6.</li> <li>Las variables de bucle est\u00e1n dentro del alcance entre sus bucles <code>for</code> { }. Entonces, <code>i</code> est\u00e1 dentro del alcance entre las l\u00edneas 3 - 6. Nota: Dos variables con el mismo nombre no pueden existir dentro del mismo \u00e1mbito (scope).</li> </ul>"},{"location":"ud1/132sentencias/","title":"\ud83d\udcbe Sentencias","text":"<p>Hemos comentado que un programa es un conjunto de instrucciones. Estas instrucciones se llaman sentencias o statements en ingl\u00e9s. Una sentencia es un segmento de c\u00f3digo que realiza una acci\u00f3n en el programa. A medida que se ejecuta un programa, decimos que ejecuta sentencias, lo que significa que lleva a cabo las acciones especificadas por esas sentencias. En nuestro programa Hello World, tenemos un statement en la l\u00ednea 4 y 6. La regla en Java es que las sentencias deben terminar con un punto y coma. Si se olvida, se producir\u00eda un error de sintaxis. </p>"},{"location":"ud1/132sentencias/#sentencias-de-declaracion","title":"Sentencias de declaraci\u00f3n","text":"<p>Se usan para definir una variable de un tipo de dato en particular. En Java, una variable debe declararse antes de que pueda usarse en un programa. De no hacerlo, se producir\u00eda un error de sintaxis. En su forma m\u00e1s simple una declaraci\u00f3n incluye el tipo de datos y el nombre de la variable. Opcionalmente se puede establecer la variable a cierto valor. Es decir, se dice que se ha inicializado.</p> <pre><code>Ejemplos:\nint numero;\nint a = 3; //se crea la variable a y se le asigna el valor 3\nint dia;\n</code></pre>"},{"location":"ud1/132sentencias/#sentencias-de-asignacion","title":"Sentencias de asignaci\u00f3n","text":"<p>Una sentencia de asignaci\u00f3n es una sentencia que almacena (asigna) un valor en una variable. Una sentencia de asignaci\u00f3n utiliza el signo igual (=) como operador de asignaci\u00f3n. En su forma m\u00e1s simple, tiene una variable en el lado izquierdo del signo igual y alg\u00fan tipo de valor en el lado derecho.</p> <pre><code>Ejemplos:\nnumero = 6; //asigno el valor 6 a la variable numero\na = 0;\ndia = 22;\n</code></pre> <p>En el siguiente ejemplo, hay variables tanto a la izquierda como a la derecha del operador de asignaci\u00f3n (=). Pero tienen un significado muy diferente. La variable de la derecha (num2) se trata como un valor. Si esa variable almacena 20, entonces ese es su valor. De hecho, cualquier cosa que ocurra en el lado derecho de un operador de asignaci\u00f3n se trata como un valor. La variable de la izquierda (num1) se trata como una ubicaci\u00f3n de memoria. Es donde se almacenar\u00e1 el valor 20 como resultado de la ejecuci\u00f3n de esta declaraci\u00f3n. El efecto de esta declaraci\u00f3n es copia el valor almacenado en num2 en num1, como se ilustra en la siguiente imagen.</p> <pre><code>Ejemplo\n//se crean las variables\nint num1 = 10;\nint num2 = 20;\n\nnum1 = num2; //se copia el valor de num2 a la variable num1\n</code></pre> <p></p>"},{"location":"ud1/132sentencias/#challenge","title":"Challenge","text":"<p>Question</p> <p>En el programa Hello World, imprime por pantalla la variable miPrimerEntero que hemos creado.</p>"},{"location":"ud1/132sentencias/#challenge2","title":"Challenge2","text":"<p>Question</p> <p>En el programa Hello World, crea las siguientes variables adicionales justo debajo de la declaraci\u00f3n \"int miPrimerEntero = 7;\" en el programa:</p> <ul> <li>num1 de tipo int y con un valor de 10.</li> <li>num2 de tipo int y con un valor de 8.</li> <li>y una tercera total que sea la suma de las anteriores.</li> <li>imprime por pantalla la variable total.</li> </ul>"},{"location":"ud1/132sentencias/#paquetes-en-java-java-packages","title":"Paquetes en Java - Java Packages","text":"<p>Un paquete es una forma de organizar nuestros proyectos Java. Se pueden ver como carpetas dentro de la estructuraci\u00f3n interna del proyecto.</p> <p>Los paquetes son el mecanismo que usa Java para facilitar la modularidad del c\u00f3digo. Un paquete puede contener una o m\u00e1s definiciones de interfaces y clases, distribuy\u00e9ndose habitualmente como un archivo. Para utilizar los elementos de un paquete es necesario importar este en el m\u00f3dulo de c\u00f3digo en curso, usando para ello la sentencia import.</p> <p>IntelliJ nos ofrece la opci\u00f3n de automatizar esto cuando creamos un proyecto, simplemente seleccionando la opci\u00f3n: </p>"},{"location":"ud1/142noprimitive/","title":"\ud83d\udcbe No primitivos u objetos","text":"<p>En Java, los tipos de datos no primitivos son los tipos de datos de referencia o los tipos de datos creados por el usuario. Todos los tipos de datos no primitivos se implementan utilizando conceptos de objeto. Cada variable del tipo de datos no primitivo es un objeto. Los tipos de datos no primitivos pueden utilizar m\u00e9todos adicionales para realizar determinadas operaciones. El valor predeterminado de la variable de tipo de datos no primitivos es nulo.</p>"},{"location":"ud1/142noprimitive/#string-cadena-de-caracteres","title":"String - Cadena de caracteres","text":"<p>String es una clase integrada en el lenguaje Java ampliamente utilizada y definido en el paquete java.lang. Representa cadenas de caracteres y se utilizan para almacenar varios atributos como nombre de usuario, contrase\u00f1a, etc. Los String son inmutables; es decir, no se pueden modificar una vez creados. Siempre que se modifica un objeto String, en realidad se crea uno nuevo String.</p> <p>Existen varias formas para crear un String:</p> <pre><code>    String texto = \"Severo Ochoa\";\nString texto2 = new String(\"Severo Ochoa\");\n</code></pre>"},{"location":"ud1/142noprimitive/#asignacion-de-memoria-de-objetos-string","title":"Asignaci\u00f3n de memoria de objetos String","text":"<p>La memoria se divide en dos partes, el String Pool y la memoria Heap.</p> <p></p> <p>Veamos como funcionar\u00eda para la imagen anterior.</p> <ol> <li> <p>Siempre que creamos un String con comillas dobles, se almacenan en String Pool. String Pool almacena el \u00fanico valor en \u00e9l. Es por eso que, String s1 = \"blogs\" se almacenan como el primer valor en el String Pool.</p> </li> <li> <p>Siempre que creamos un objeto usando la palabra clave new, se almacena en la memoria Heap pero fuera del String Pool. Aqu\u00ed se puede almacenar valores duplicados ya que pertenece a diferentes objetos. Entonces, para la declaraci\u00f3n String s2 = new String(\u201cblogs\u201d), aunque el valor de s1 y s2 es el mismo, s2 se almacenar\u00e1 fuera del String Pool.</p> </li> <li> <p>Cuando creamos otro String usando comillas dobles, primero verifica todos los valores en el String Pool y si coincide con alguno se asigna la misma ubicaci\u00f3n asignada a otro objeto de referencia. Por lo tanto, String s3 = \u201dblogs\u201d no agregar\u00e1 una nueva entrada en el String Pool.</p> </li> <li> <p>Pero si creamos otro objeto con un valor existente usando la palabra clave new. Asignar\u00e1 nueva memoria al nuevo objeto en el Heap. Por lo tanto, a String s4 = new String (\"blogs\") se le asignar\u00e1 nueva memoria.</p> </li> <li> <p>Ahora, si manipulamos el valor en s1 usando s1 = \u201dNew\u201c + s1, no actualizar\u00e1 la entrada o referencia existente de s1. Este proceso crear\u00e1 una nueva entrada en el String Pool con el valor \"New blogs\" y la referencia de memoria cambiar\u00eda para el objeto s1.</p> </li> </ol>"},{"location":"ud1/142noprimitive/#java-string-class-methods","title":"Java String Class Methods","text":"<p>La clase java.lang.String proporciona muchos m\u00e9todos \u00fatiles para realizar operaciones en la secuencia de valores char.</p>"},{"location":"ud1/142noprimitive/#date","title":"Date","text":"<p>En sus inicios se crearon las clases java.util.Date y java.sql.Date para almacenar y manejar fechas. Pero ambas clases son defectuosas en dise\u00f1o e implementaci\u00f3n. Por ejemplo, las clases existentes (como java.util.Date y SimpleDateFormatter) no son thread-safe, lo que genera posibles problemas de concurrencia para los usuarios.</p> <p>Por tanto, desde Java 8 y posteriores se ha desarrollado una nueva API java.time que resuelve los problemas que presentaban las librer\u00edas anteriores.</p> <p></p> <p>More information</p> <p>Why do we need a new date and time library?</p> <p>Ejemplo de c\u00f3digo para mostara la fecha y la hora:</p> <pre><code>  //mostrar fecha\nLocalDate ld = LocalDate.now();\nSystem.out.println(ld);\n\n//mostrar hora\nLocalTime lt = LocalTime.now();\nSystem.out.println(lt);\n\n//mostrar fecha y hora\nLocalDateTime ldt = LocalDateTime.now();\nSystem.out.println(ldt);\n\n//formatear la fecha con un formato dado\nDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"dd-MM-yyyy HH:mm:ss\");\nString formatted = formatter.format(ldt);\nSystem.out.println(formatted);\n</code></pre>"},{"location":"ud1/142noprimitive/#enum-en-java","title":"Enum en Java","text":"<p>El tipo enumerado es un tipo de datos especial que permite que una variable sea un conjunto de constantes predefinidas. La variable debe ser igual a uno de los valores que se han predefinido para ella.</p> <p>Debido a que son constantes, los nombres de los campos del tipo enum deben estar en letras may\u00fasculas.</p> <p>En Java, se define un enumerado utilizando la palabra clave enum seguido del nombre siguiendo la convenci\u00f3n del nombrado de clases. Primera letra en may\u00fascula y CamelCase.</p> <p>Para crear un enum en Java, bot\u00f3n derecho en el paquete --&gt; new Java class y seleccionamos enum.</p> <p>Ejemplo de enumerado:</p> <pre><code>  public enum PuntosCardinales {\nNORTE, SUR, ESTE, OESTE\n}\n\npublic class Main {\n\npublic static void main(String[] args) {\nPuntosCardinales myVar = PuntosCardinales.ESTE;\nSystem.out.println(myVar);\n}\n\n}\n</code></pre>"},{"location":"ud1/143string/","title":"\ud83d\udcbe String en Java","text":"<p>Un String es un tipo de dato no primitvo que, en Java representa una cadena de caracteres no modificable. Todos los literales de la forma \"cualquier texto\", es decir, literales entre comillas dobles, que aparecen en un programa java se implementan como objetos de la clase String.</p> <p>A diferencia de muchos objetos vimos que un String se puede crear sin la palabra new.</p> <p>String text = \"hola\";</p>"},{"location":"ud1/143string/#creacion-de-string","title":"Creaci\u00f3n de String","text":"<p>Se puede crear un String de varias formas.</p> <pre><code>    String texto = \"Severo Ochoa\";\n\n//Utilizando new\nString texto2 = new String(\"Severo Ochoa\");\n\n//Utilizando el operador concatenaci\u00f3n +\nString s2 = text + \" 2021\";      //s2 contiene \"Severo Ochoa 2021\"\n</code></pre>"},{"location":"ud1/143string/#el-operador-concatenacion","title":"El operador concatenaci\u00f3n","text":"<p>La clase proporciona el operador + (concatenaci\u00f3n) para unir dos o m\u00e1s String. El resultado de aplicar este operador es un nuevo String concatenaci\u00f3n de los otros. Por ejemplo, si tenemos dos String b y c:</p> <pre><code>String b = \"Ordenador\";\nString c = \" Port\u00e1til\";\n</code></pre> <p></p> <p>La operaci\u00f3n</p> <pre><code>b = b + c;\n</code></pre> <p>Crea un nuevo String que se incluye en el String Pool:</p> <p></p>"},{"location":"ud1/143string/#indices","title":"\u00cdndices","text":"<p>Cada uno de los caracteres que forman un String son del tipo primitivo char. Los caracteres de un string est\u00e1n numerados internamente con \u00edndices empezando desde el cero:</p> <p></p> <p>El primer car\u00e1cter tiene \u00edndice 0 y el \u00faltimo tiene la longitud del string menos 1.</p>"},{"location":"ud1/143string/#metodos-de-la-clase-string","title":"M\u00e9todos de la clase String","text":"<p>La clase String proporciona m\u00e9todos para el tratamiento de las cadenas de caracteres: acceso a caracteres individuales, buscar y extraer una subcadena, copiar cadenas, convertir cadenas a may\u00fasculas o min\u00fasculas, etc.</p> <p></p> <p>Para acceder a alguno de los m\u00e9todos siguientes utilizamos la notaci\u00f3n \".\"</p> <pre><code>  String texto = \"Clase\";\nint longitud = texto.length(); //devuelve 5\n</code></pre> <p></p> <p>Tip</p> <p>Para m\u00e1s informaci\u00f3n consulta la documentaci\u00f3n oficial de la clase String</p>"},{"location":"ud1/143string/#comparar-strings","title":"Comparar Strings","text":"<p>Los operadores relacionales como == o &lt; &gt; NO se utilizan para comparar Strings, aunque el c\u00f3digo compile no es correcto, ya que == compara objetos, y devolver\u00eda falso aunque dos strings tuvieran el mismo texto puesto que son objetos diferentes.</p> <p>Para comparar strings utilizamos el m\u00e9todo equals.</p> <pre><code>  String name = \"Patri\";\n\nif (name.equals(\"Patri\")) {\nSystem.out.println(\"Coincide.\");\n}\n</code></pre> <p>La siguiente tabla muestra los m\u00e9todos que se utilizan para comparar Strings.</p> <p></p>"},{"location":"ud1/143string/#char-dentro-de-string","title":"char dentro de String","text":"<p>Como se ha comentado, un String est\u00e1 compuesto de caracteres tipo char.</p> <p>Para acceder a los caracteres dentro de un String usamos el m\u00e9todo charAt.</p> <p>Se puede usar la concatenaci\u00f3n + para concatenar char con String.</p> <pre><code>String food = \"cookie\";\nchar firstLetter = food.charAt(0); // 'c'\nSystem.out.println(firstLetter + \" is for \" + food); </code></pre> <p>Tambi\u00e9n podemos recorrer el String con un bucle for e imprimir cada uno de los caracteres que lo forman.</p> <pre><code>String major = \"CSE\";\nfor (int i = 0; i &lt; major.length(); i++) {\nchar c = major.charAt(i);\nSystem.out.println(c);\n}\n</code></pre> <pre><code>OUTPUT\nC\nS\nE\n</code></pre>"},{"location":"ud1/143string/#char","title":"char","text":"<p>A todos los valores char se les asigna un n\u00famero internamente por el ordenador, son los llamados valores ASCII. Por ejemplo:</p> <p>el car\u00e1cter 'A' es 65 en c\u00f3digo ASCII</p> <p>el car\u00e1cter 'a' es 97 en c\u00f3digo ASCII</p> <p>Mezclar tipos de datos char e int autom\u00e1ticamente cause una conversi\u00f3n en entero. Por ejemplo:</p> <p>'a' + 10 --&gt; devuelve 107.</p> <p>Para convertir un entero en su equivalente a car\u00e1cter (char) har\u00edamos:</p> <p>(char) ('a' + 2) --&gt; devuelve 'c'.</p>"},{"location":"ud1/143string/#diferencias-entre-char-y-string","title":"Diferencias entre char y String","text":"<ul> <li>String es un objeto, por tanto, contiene m\u00e9todos.</li> <li>char es un tipo de dato primitivo, no puedes llamar a m\u00e9todos con \u00e9l.</li> <li>String utiliza comillas dobles.</li> <li>char utiliza comillas simples.</li> <li>No se puede comparar un String usando operadores relacionales.</li> <li>Si se puede comparar un char usando operadores relacionales: 'a' &lt; 'b', 'X' == 'X', ...</li> </ul>"},{"location":"ud1/14datatypejava/","title":"\ud83d\udcbe Tipos de datos","text":"<p>Un tipo de datos es un conjunto de valores y un conjunto de operaciones definidas en ellos. Se pueden clasificar en primitivos y objetos. </p>"},{"location":"ud1/14datatypejava/#primitivos","title":"Primitivos","text":"<p>Los primitivos son los m\u00e1s b\u00e1sicos y fundamentales, vienen integrados en Java. Especifican el tipo de valor almacenado en una variable y el tama\u00f1o de la memoria. Hay 8 tipos primitivos de datos integrados en el lenguaje Java. Estos incluyen: int, byte, short, long, float, double, boolean y char.</p> Primitive data type Wrapper class byte Byte short Short int Integer long Long float Float double Double boolean Boolean char Character"},{"location":"ud1/14datatypejava/#byte","title":"byte","text":"<p>Como su propio nombre denota, emplea un solo byte (8 bits) de almacenamiento. Esto permite almacenar valores en el rango [-128, 127]. Raramente se usa. Ocupa menos memoria y puede ser m\u00e1s r\u00e1pido accedido.</p> <pre><code>  byte b = 2;\n</code></pre>"},{"location":"ud1/14datatypejava/#short","title":"short","text":"<p>Usa el doble de almacenamiento que el anterior, es decir, ocupa 16 bits [-32.768, 32.767].</p> <pre><code>  short s = 3467;\n</code></pre>"},{"location":"ud1/14datatypejava/#int","title":"int","text":"<p>Emplea 4 bytes (32 bits) de almacenamiento y es el tipo de dato entero m\u00e1s empleado. Necesita cuatro veces el espacio que ocupa un byte. Es el entero predeterminado usado en Java.</p> <pre><code>        int maxValor = 2147483647;\n// after java 7 and higher\nint maxValue = 2_147_483_647;\n</code></pre>"},{"location":"ud1/14datatypejava/#long","title":"long","text":"<p>Es el tipo entero de mayor tama\u00f1o, 8 bytes (64 bits). Para definir un long, tenemos que hacerlo de la siguiente forma:</p> <pre><code>  long myLongNumber = 500L;\n</code></pre>"},{"location":"ud1/14datatypejava/#float","title":"float","text":"<p>Tiene una parte flotante que sirve para expresar n\u00fameros decimales. Es de simple precisi\u00f3n (formato y cantidad de espacio que ocupa) porque ocupa 32 bits. No se recomienda mucho su uso.</p> <pre><code>  float f = 4;\nfloat f = 4f; //tambi\u00e9n v\u00e1lida\n</code></pre>"},{"location":"ud1/14datatypejava/#double","title":"double","text":"<p>Es un n\u00famero de precisi\u00f3n doble y ocupa 64 bits. Es el flotante predeterminado en Java. Se recomienda su uso. Muchas librer\u00edas internas de Java, relacionadas con operaciones matem\u00e1ticas, usan double.</p> <pre><code>  double d = 5;\ndouble d = 5d; //tambi\u00e9n v\u00e1lida\n</code></pre>"},{"location":"ud1/14datatypejava/#char","title":"char","text":"<p>Se utiliza para almacenar caracteres (letras, n\u00fameros, signos, etc.) individuales. Ocupa 2 bytes en memoria (16 bits). Permite almacenar caracteres Unicode. Unicode es un est\u00e1ndar de codificaci\u00f3n internacional que nos permite representar diferentes idiomas; y la forma en que funciona es usando una combinaci\u00f3n de los dos bytes que un char ocupa en la memoria, que puede representar hasta 65535 diferentes tipos de caracteres. Unicode table.</p> <pre><code>  char c = 'P';\nchar u = '\\u00A2';//print unicode character\n</code></pre> <p>Un car\u00e1cter precedido por una barra invertida () es una secuencia de escape y tiene un significado especial para el compilador. La siguiente tabla muestra las secuencias de escape de Java:</p> <p></p>"},{"location":"ud1/14datatypejava/#boolean","title":"boolean","text":"<p>solo permite almacenar dos posibles valores que son true o false. Tiene la finalidad de facilitar el trabajo con valores \"verdadero/falso\" (booleanos), resultantes por regla general de evaluar expresiones.</p> <p>Este tipo de datos representa un bit de informaci\u00f3n, pero su \"tama\u00f1o\" no es algo que est\u00e9 definido con precisi\u00f3n.</p> <pre><code>  boolean isMyNamePatri = true;\n</code></pre>"},{"location":"ud1/14datatypejava/#wrapper-classes-clases-contenedores","title":"Wrapper classes (clases contenedores)","text":"<p>Las clases contenedoras proporcionan una forma de utilizar tipos de datos primitivos como objetos. En Java, tenemos una Wrapper class para cada uno de los 8 tipos de datos primitivos. Gracias a esto, podemos realizar operaciones en un dato primitivo como por ejemplo en un int:</p> <pre><code>   int minimoValorInt = Integer.MIN_VALUE;\n</code></pre>"},{"location":"ud1/15operators/","title":"\ud83d\udcbe Operadores","text":"<p>Los operadores son s\u00edmbolos especiales en Java que realizan operaciones entre uno o varios operandos y devuelve un resultado. Uno de los m\u00e1s usados es el operador suma (+) como hemos visto en clases anteriores.</p>"},{"location":"ud1/15operators/#operando","title":"Operando","text":"<p>Es cualquier t\u00e9rmino, que puede ser una variable o valor y que es manipulado por un operador.</p> <pre><code>   int valor = 8;\nint numero = valor + 12;\n</code></pre> <p>En el ejemplo anterior, + es el operador y valor y 12 son los operandos. valor + 12 es una expresi\u00f3n que devuelve el resultado de 20.</p>"},{"location":"ud1/15operators/#expresiones","title":"Expresiones","text":"<p>Una expresi\u00f3n es una combinaci\u00f3n de literales, operadores, nombres de variables y par\u00e9ntesis que se utilizan para calcular un valor.</p> <pre><code>  int miPrimerEntero = 7 + 5;\nint resultado = 0;\n\nresultado = (miPrimerEntero * 10) / (32 + 12);\n</code></pre> <p>Java examina la expresi\u00f3n de la derecha del signo igual y realiza el c\u00e1lculo de una expresi\u00f3n matem\u00e1tica. Despu\u00e9s asigna ese valor a la variable resultado. Podr\u00edamos complicar m\u00e1s la expresi\u00f3n utilizando operadores como par\u00e9ntesis, multiplicaciones, divisiones, etc.</p> <p>Las partes de una expresi\u00f3n deben estar ordenadas correctamente. Las reglas para las expresiones Java correctas son casi las mismas que las del \u00e1lgebra:</p> <ol> <li> <p>Cada operador debe tener el n\u00famero correcto de operandos.</p> <ul> <li>Multiplicaci\u00f3n *, Divisi\u00f3n /, Suma +, Resta: debe tener dos operandos, uno en cada lado.</li> <li>La negaci\u00f3n - y unario m\u00e1s + deben ir seguidos de un operando.</li> </ul> </li> <li> <p>Los par\u00e9ntesis () pueden rodear una expresi\u00f3n legal para convertirla en operando.</p> </li> </ol> <p></p>"},{"location":"ud1/15operators/#expresiones-mixtas-con-int-y-double","title":"Expresiones mixtas con int y double","text":"<p>Si ambos operandos de un operador aritm\u00e9tico son de tipo int, entonces la operaci\u00f3n es una operaci\u00f3n entera. Si alg\u00fan operando es de punto flotante, entonces la operaci\u00f3n es de punto flotante.</p>"},{"location":"ud1/15operators/#tipos-de-operadores-en-java","title":"Tipos de operadores en Java","text":"<p>Java proporciona muchos tipos de operadores que se pueden usar seg\u00fan la necesidad. Se clasifican seg\u00fan la funcionalidad que brindan. Algunos de los tipos son los siguientes:</p> <p>Operadores aritm\u00e9ticos, unarios, de asignaci\u00f3n, relacionales, l\u00f3gicos, etc.</p>"},{"location":"ud1/15operators/#operador-de-asignacion","title":"Operador de asignaci\u00f3n (=)","text":"<p>Es uno de los operadores m\u00e1s usados. Se usa para asignar un valor a cualquier variable. Tiene una asociaci\u00f3n de derecha a izquierda, es decir, el valor dado en el lado derecho del operador se asigna a la variable de la izquierda y, por lo tanto, el valor del lado derecho debe declararse antes de usarlo o debe ser una constante.</p>"},{"location":"ud1/15operators/#operadores-aritmeticos","title":"Operadores aritm\u00e9ticos","text":"<p>Se utilizan para realizar operaciones aritm\u00e9ticas simples.</p> S\u00edmbolo Operaci\u00f3n Descripci\u00f3n + Suma Realiza la suma de los operandos. - Resta Realiza la resta de los operandos. * Producto Multiplica los operandos. / Divisi\u00f3n Realiza la divisi\u00f3n. % M\u00f3dulo Calcula el resto."},{"location":"ud1/15operators/#operadores-unarios","title":"Operadores unarios","text":"<p>Los operadores unarios solo necesitan un operando. Se usan para incrementar, disminuir o negar un valor.</p> S\u00edmbolo Operaci\u00f3n Descripci\u00f3n ++ Incremento Incrementa el valor en 1 unidad. -- Decremento El valor disminuye en 1 unidad. ! NOT l\u00f3gico Invierte un valor booleano. <p>Existen dos versiones de estos operadores:</p> <ul> <li>Pre-incremento y pre-decremento. El valor se aumenta/disminuye primero y luego se calcula el resultado.</li> </ul> <p></p> <pre><code> int a = 8, b = 1;\nb = ++a; //b=9, a=9\n</code></pre> <ul> <li>Post-Incremento y post-decremento: el valor se usa por primera vez para calcular el resultado y luego se incrementa/decrementa.</li> </ul> <pre><code> int a = 8, b = 1;\nb = a++;//b = 8, a = 9\n</code></pre> <p></p>"},{"location":"ud1/15operators/#operadores-relacionales","title":"Operadores relacionales","text":"<p>Estos operadores se utilizan para verificar relaciones como igualdad, mayor que, menor que. Devuelven el resultado booleano despu\u00e9s de la comparaci\u00f3n.</p> S\u00edmbolo Operaci\u00f3n Descripci\u00f3n == Igual a Devuelve verdadero si el valor de la izquierda del s\u00edmbolo es igual al de la derecha. != Distinto a Devuelve verdadero si el valor de la izquierda es distinto al de la derecha. &lt; Menor que Devuelve verdadero si el valor de la izquierda es menor que el de la derecha. &lt;= Menor o igual que Devuelve verdadero si el valor de la izquierda es menor o igual que el de la derecha. &gt; Mayor que Devuelve verdadero si el valor de la izquierda es mayor que el de la derecha. &gt;= Mayor o igual que Devuelve verdadero si el valor de la izquierda es mayor o igual al de la derecha. <pre><code>  int a = 20, b = 10;\nSystem.out.println(\"a == b :\" + (a == b));//Devuelve falso, porque a no es igual a b\n</code></pre>"},{"location":"ud1/15operators/#operadores-logicos","title":"Operadores l\u00f3gicos","text":"<p>Estos operadores se utilizan para realizar operaciones l\u00f3gicas AND y OR. Se usa ampliamente en sentencias if-then o bucles para verificar condiciones, establecer un punto de salida de un bucle o la toma de  decisiones. Los operadores condicionales son:</p> S\u00edmbolo Operaci\u00f3n Descripci\u00f3n &amp;&amp; AND l\u00f3gico Devuelve verdadero cuando ambas condiciones son ciertas. || OR l\u00f3gico Devuelve verdadero si al menos una condici\u00f3n es cierta. <p></p> <pre><code>    int a = 20, b = 10, c= 10;\nSystem.out.println((b == c &amp;&amp; a == c)); //False\nSystem.out.println((a == c &amp;&amp; b == c)); //False\nSystem.out.println((a == b || b == c)); //True\n</code></pre>"},{"location":"ud1/15operators/#operadores-de-bits","title":"Operadores de bits","text":"S\u00edmbolo Operaci\u00f3n Descripci\u00f3n &amp; AND Si ambos bits de entrada son 1, establece como resultado 1. De lo contrario 0. | OR Si por lo menos uno de los bits de entrada es 1, establece como resultado 1. De lo contrario 0. ^ XOR Si uno de los bits de entrada es 1 y el otro 0, establece como resultado 1. Si los bits son iguales establece 0. ~ NOT Invierte todos los bits y devuelve el resultado en complemento a 2."},{"location":"ud1/15operators/#operador-ternario","title":"Operador ternario (?:)","text":"<p>Ternario es una versi\u00f3n abreviada de la sentencia if-else. Tiene tres operandos y de ah\u00ed el nombre ternario. El formato general es:</p> <p></p> <p>La declaraci\u00f3n anterior significa que si la condici\u00f3n se eval\u00faa como verdadera, entonces ejecuta las instrucciones despu\u00e9s del \u2018?\u2018 de lo contrario, ejecuta las instrucciones despu\u00e9s de \u2018:\u2018.</p> <pre><code>  int nota = 7;\nString notaFinal = (nota &gt;= 5) ? \"Aprobado\" : \"Suspendido\";\nSystem.out.println(notaFinal); //muestra Aprobado\n</code></pre>"},{"location":"ud1/15operators/#abreviaciones","title":"Abreviaciones","text":"<p>En muchos casos, el operador de asignaci\u00f3n se puede combinar con otros operadores para construir una versi\u00f3n m\u00e1s corta de la declaraci\u00f3n llamada Declaraci\u00f3n Compuesta (Compound Statement).</p> <ul> <li>+= , para sumar el operando izquierdo con el operando derecho y luego asignarlo a la variable de la izquierda.</li> </ul> <pre><code>  int a = 5;\na += 5; // a = a + 5;\n</code></pre> <ul> <li>\u2013 = , para restar el operando izquierdo con el operando derecho y luego asignarlo a la variable de la izquierda.</li> </ul> <pre><code>  int a = 5;\na -= 5; // a = a - 5;\n</code></pre> <ul> <li>*= , para multiplicar el operando izquierdo con el operando derecho y luego asign\u00e1ndolo a la variable de la izquierda.</li> </ul> <pre><code>  int a = 5;\na *= 5; // a = a * 5;\n</code></pre> <ul> <li>/ = , para dividir el operando izquierdo con el operando derecho y luego asignarlo a la variable de la izquierda.</li> </ul> <pre><code>  int a = 5;\na /= 5; // a = a / 5;\n</code></pre> <ul> <li>% = , para asignar el m\u00f3dulo del operando izquierdo con el operando derecho y luego asignarlo a la variable de la izquierda.</li> </ul> <pre><code>  int a = 5;\na %= 5; // a = a % 5;\n</code></pre>"},{"location":"ud1/15operators/#precedencia-de-operadores","title":"Precedencia de operadores","text":"<p>El orden de precedencia, es decir, como Java decide la prioridad al evaluar los operadores en una expresi\u00f3n, se puede ver en Java Operator Precedence Table</p>"},{"location":"ud1/15operators/#conversiones-de-tipo","title":"Conversiones de tipo","text":""},{"location":"ud1/15operators/#conversiones-por-defecto","title":"Conversiones por defecto","text":"<p>Las reglas de Java para saber el tipo de datos resultante de una expresi\u00f3n se siguen las siguientes reglas:</p> Si alg\u00fan operando es El otro operando se transforma a double double float float long long byte or short int <p>Si se aplican dos regla, se elige la que aparece primero en la tabla.</p>"},{"location":"ud1/15operators/#conversiones-forzosas-casting-entre-tipos-nativos","title":"Conversiones forzosas (casting entre tipos nativos)","text":"<p>Es una forma de convertir un n\u00famero de un tipo a otro tipo de dato. Para hacerlo ponemos en par\u00e9ntesis el tipo de dato al que queremos convertirlo.</p> <pre><code>    byte miByte = (byte) (14 / 2); //conviero la operaci\u00f3n divisi\u00f3n que devuelve un int a byte\n\n//Otra forma\nfloat a = 8.0f;\nint b = 10;\nb = (int) a;//convierto el tipo float a int\n</code></pre> <p>Otros operadores</p> <p>Existen m\u00e1s operadores que no se han mencionado en el curso. Si se desea consultar todos los operadores de Java se pueden ver en su documentaci\u00f3n oficial. More information</p>"},{"location":"ud1/15operators/#sintaxis-de-las-expresiones-matematicas","title":"Sintaxis de las expresiones matem\u00e1ticas","text":"M\u00e9todo Returns Ejemplo Math.abs valor absoluto Math.abs(-308) returns 308 Math.ceil redondeo hacia arriba Math.ceil(2.13) returns 3.0 Math.floor redondeo hacia abajo Math.floor(2.93) returns 2.0 Math.max valor m\u00e1x. de dos valores Math.max(45, 207) returns 207 Math.min valor min. de dos valores Math.min(3.8, 2.75) returns 2.75 Math.pow potencia Math.pow(3, 4) returns 81.0 Math.round redondear al entero m\u00e1s cercano Math.round(2.718) returns 3 Math.sqrt ra\u00edz cuadrada Math.sqrt(81) returns 9.0"},{"location":"ud1/16comments/","title":"\ud83d\udcbe Comentarios en Java","text":"<p>Los comentarios son ignorados por el ordenador y se usan en el programa para ayudar a describir alguna funcionalidad o explicaci\u00f3n del c\u00f3digo fuente. Existen dos tipos de comentarios.</p>"},{"location":"ud1/16comments/#comentarios-de-una-linea","title":"Comentarios de una l\u00ednea","text":"<p>Usamos la doble barra // para realizar un comentario de una sola l\u00ednea. Lo podemos usar en una l\u00ednea en blanco o detr\u00e1s del c\u00f3digo.</p> <pre><code>   int gravity; //variable para calcular la gravedad\n</code></pre>"},{"location":"ud1/16comments/#comentarios-multilinea","title":"Comentarios multil\u00ednea","text":"<p>Usamos la barra con asterisco doble para realizar comentarios que afecten a m\u00e1s de una l\u00ednea. De forma que cuando abramos un comentario usaremos /*, para cerrarlo */.</p> <pre><code>   /*\n      Clase que almacena en la base de datos\n      los datos de una persona.\n   */\npublic class Persona {\n...\n}\n</code></pre>"},{"location":"ud1/17constantesliterales/","title":"\ud83d\udcbe Constantes y literales","text":""},{"location":"ud1/17constantesliterales/#las-constantes","title":"Las constantes","text":"<p>Un programa puede contener ciertos valores que no deben cambiar durante su ejecuci\u00f3n. Estos valores se llaman constantes. Definici\u00f3n: Una constante es una zona de memoria que se referencia con un identificador, conocido como nombre de la constante, donde se almacena un valor que no puede cambiar durante la ejecuci\u00f3n del programa.</p> <p>La nomenclatura para definiar las constantes es la siguiente:</p> <ul> <li>Todas las letras de cada palabra deben estar en may\u00fasculas</li> <li>Se separa cada palabra con un _</li> <li>Se declaran similar a las variables, con la diferencia de que el tipo de dato va despu\u00e9s de la palabra reservada final</li> </ul> <pre><code>    final double PI = 3.141591;\nfinal int MIN_WIDTH = 4;\nfinal double TASAS = 0.045;\n</code></pre> <p>Las constantes hacen que el programa sea m\u00e1s f\u00e1cil de leer y verificar que sea correcto. Si es necesario cambiar una constante (por ejemplo, si cambian las tasas), todo lo que tendremos que hacer es cambiar la declaraci\u00f3n de la constante. No ser\u00e1 necesario buscar en todo el programa cada aparici\u00f3n de ese n\u00famero espec\u00edfico.</p>"},{"location":"ud1/17constantesliterales/#los-literales","title":"Los literales","text":"<p>Un literal Java es un valor de tipo entero, real, l\u00f3gico, car\u00e1cter, cadena de caracteres o un valor nulo (null) que puede aparecer dentro de un programa. Por ejemplo: 150, 12.4, \u201cANA\u201d, null, \u2018t\u2019. Los literales suelen aparecer en la asignaci\u00f3n de valores a las variables o formando parte de expresiones aritm\u00e9ticas o l\u00f3gicas.</p> <p></p>"},{"location":"ud1/18inputoutputconsole/","title":"\ud83d\udcbe Programaci\u00f3n de la consola: entrada y salida de informaci\u00f3n (I/O input/output)","text":"<p>Java viene con una biblioteca de clases que se puede usar para realizar tareas comunes. La biblioteca de clases de Java est\u00e1 organizada en un conjunto de paquetes, donde cada paquete contiene una colecci\u00f3n de clases relacionadas.</p> <p>En esta secci\u00f3n presentamos las clases System y Scanner que se utilizan para imprimir la salida y leer la entrada de un programa.</p> <p>El tipo m\u00e1s simple de interfaz de usuario es la interfaz de l\u00ednea de comandos, en la que la entrada se toma de la l\u00ednea de comandos a trav\u00e9s del teclado y la salida se muestra en la consola. Algunas aplicaciones Java utilizan este tipo de interfaz otros usan interfaz gr\u00e1fica como veremos m\u00e1s adelante.</p> <p></p> <p></p>"},{"location":"ud1/18inputoutputconsole/#salida-de-la-informacion","title":"Salida de la informaci\u00f3n","text":"<p>En Java, cualquier origen o destino de I/O se considera un flujo de bytes o caracteres. Para realizar la salida, insertamos bytes o caracteres en la secuencia. Para realizar la entrada, extraemos bytes o caracteres del flujo (stream). Incluso los caracteres introducidos en un teclado, si se consideran como una secuencia de pulsaciones de teclas, se pueden representar como un stream.</p> <p>En Java, la I/O se maneja a trav\u00e9s de m\u00e9todos que pertenecen a clases contenidas en el paquete java.io. Ya hemos visto c\u00f3mo se usa el m\u00e9todo de salida println() para enviar una cadena a la consola. Por ejemplo:</p> <pre><code>   System.out.println(\"Hola mundo\");\n</code></pre> <p>imprime el texto Hola mundo por la consola.</p> <p>Los objetos System.out y System.err se pueden usar para escribir la salida en la consola. Como sugiere su nombre, el flujo de errores se usa principalmente para mensajes de error, mientras que el flujo de salida se usa para otras salidas impresas.</p> <pre><code>   System.err.println(\"Fallo al abrir el fichero\");\n</code></pre> <p>De manera similar, como sugiere su nombre, el objeto System.in se puede usar para manejar la entrada, que se trata en el siguiente punto.</p> <p>La \u00fanica diferencia entre los m\u00e9todos print() y println() es que println() tambi\u00e9n imprimir\u00e1 un retorno de carro y un avance de l\u00ednea despu\u00e9s de imprimir sus datos, lo que permitir\u00e1 que la salida posterior se imprima en una nueva l\u00ednea. Por ejemplo:</p> <pre><code>   System.out.print(\"Hola\");\nSystem.out.print(\"mundo\"):\nSystem.out.println(\"Texto con salto de l\u00ednea\");\nSystem.out.println(\"adi\u00f3s\");\n</code></pre> <pre><code>   HolamundoTexto con salto de l\u00ednea\n   adi\u00f3s\n</code></pre>"},{"location":"ud1/18inputoutputconsole/#entrada-de-la-informacion-javautilscanner","title":"Entrada de la informaci\u00f3n java.util.Scanner","text":"<p>Se ha agregado la clase Scanner al paquete java.util que permite la entrada de teclado sin forzar el programador para manejar las excepciones. La clase Scanner est\u00e1 dise\u00f1ada para ser una forma muy flexible de reconocer fragmentos de datos que se ajustan a patrones espec\u00edficos de cualquier flujo de entrada.</p> <p>Para usar la clase Scanner para la entrada de teclado, debemos crear una instancia de Scanner y asociarla con System.in. La clase tiene un constructor para este prop\u00f3sito, por lo que la declaraci\u00f3n</p> <pre><code>   Scanner sc = new Scanner(System.in);\n</code></pre> <p>declara y crea una instancia de un objeto que se puede utilizar para la entrada del teclado. Despu\u00e9s de crear un objeto Scanner, podemos hacer una llamada a nextInt(), nextDouble(), o next() para leer, respectivamente, un entero, un n\u00famero real, o String del teclado.</p> <pre><code>   public static void main(String[] args) {\nScanner sc = new Scanner (System.in);\nSystem.out.print(\"Introduce un n\u00famero: \");\nint num = sc.nextInt();//Read the integer\nSystem.out.println(\"El n\u00famero introducido es: \" + num);\n}\n</code></pre> <p>Cuando se ejecuta el m\u00e9todo nextInt(), no se ejecutan m\u00e1s declaraciones hasta que el m\u00e9todo devuelve un valor int. Normalmente, esto no sucede hasta que el usuario ha escrito los d\u00edgitos de un n\u00famero entero y presiona la tecla Intro o Intro.</p> <p>Para leer un String utilizamos el m\u00e9todo next().</p> <pre><code>   public static void main(String[] args) {\nScanner sc = new Scanner (System.in);\nSystem.out.print(\"Introduce una palabra: \");\nString str = sc.next();\nSystem.out.println(str);\n}\n</code></pre> <p>Un objeto Scanner tiene un conjunto de cadenas de caracteres que separan o delimitan los fragmentos de datos que est\u00e1 buscando. De forma predeterminada, este conjunto de delimitadores consta de cualquier secuencia no vac\u00eda de caracteres en blanco, es decir, los caracteres de espacio, tabulaci\u00f3n, retorno y nueva l\u00ednea. Esto permitir\u00e1 al usuario ingresar varios n\u00fameros enteros separados por espacios antes de presionar la tecla Enter. En c\u00f3digo ser\u00eda:</p> <pre><code>   System.out.print(\"Introduce dos n\u00fameros: \");\nint num = sc.nextInt();\nint num2 = sc.nextInt();\n</code></pre> <p>Los espacios en blanco como delimitadores tambi\u00e9n significan que el m\u00e9todo next() no puede devolver una cadena vac\u00eda ni puede devolver una cadena que contenga espacios. Por ejemplo, considere el c\u00f3digo:</p> <pre><code>   System.out.print(\"Introduce un texto separado por espacio en blanco: \");\nString str = sc.next();\n</code></pre> <p>Si se escribe \"Hola mundo\" y se presiona la tecla enter, la cadena str almacenar\u00e1 s\u00f3lo \"Hola\".</p> <p>Para que un objeto Scanner lea cadenas que contienen espacios, debemos usar el m\u00e9todo nextLine():</p> <pre><code>   String str = sc.nextLine();\n</code></pre>"},{"location":"ud1/19poo/","title":"\ud83d\udcbe Introducci\u00f3n a la programaci\u00f3n orientada a objetos","text":"<p>La programaci\u00f3n modular es un paradigma que consiste en dividir un programa en m\u00f3dulos con el fin de hacerlo m\u00e1s legible y manejable. Enfatiza este concepto mediante la construcci\u00f3n de aplicaciones a partir de su divisi\u00f3n en componentes independientes que llevan a cabo tareas concretas.</p> <p>Al aplicar programaci\u00f3n modular, un problema complejo debe ser dividido en otros subproblemas m\u00e1s simples a\u00fan.</p> <p>Un m\u00f3dulo es cada una de las partes de un programa que resuelve uno de los subproblemas.</p> <p>La programaci\u00f3n orientada a objetos (POO) se basa en la programaci\u00f3n modular, aunque supone una ruptura respecto a \u00e9sta al introducir el concepto de objeto, lo que supone un gran avance en t\u00e9rminos de modularizaci\u00f3n y reutilizaci\u00f3n de c\u00f3digo.</p>"},{"location":"ud1/19poo/#fundamentos-de-la-poo","title":"Fundamentos de la POO","text":"<ul> <li>Abstracci\u00f3n: es el pilar de la POO, un principio por el cual se a\u00edsla toda aquella informaci\u00f3n que no resulta relevante a un determinado nivel de conocimiento. Consiste en captar las caracter\u00edsticas esenciales de un objeto, asi como su comportamiento.</li> <li>Encapsulaci\u00f3n: se centra en ocultad la complejidad de la clase. Significa proteger a los miembros de una clase de un acceso ilegal o no autorizado.</li> <li>Herencia: es el pilar m\u00e1s fuerte que asegura la reutilizaci\u00f3n de c\u00f3digo. Permite la definici\u00f3n de nuevas clases a partir de otras ya existentes.</li> <li>Polimorfismo: posibilita que una misma operaci\u00f3n pueda realizar tareas diferentes, dependiendo del tipo de objeto sobre el cual se ha invocado.</li> </ul>"},{"location":"ud1/19poo/#concepto-de-objeto","title":"Concepto de objeto","text":"<p>Entonces, \u00bfqu\u00e9 es un objeto? Al igual que en el mundo real, un objeto es cualquier cosa. Un objeto puede ser una cosa f\u00edsica, como un coche, o una cosa mental, como una idea. Puede ser algo natural, como un animal, o algo artificial hecho por el hombre, como un cajero autom\u00e1tico. Un programa que administra un cajero autom\u00e1tico involucrar\u00eda cuentas bancarias y objetos de cliente. Un programa de ajedrez involucrar\u00eda un objeto tablero y objetos piezas de ajedrez.</p>"},{"location":"ud1/19poo/#atributos-y-acciones","title":"Atributos y acciones","text":""},{"location":"ud1/19poo/#atributos","title":"Atributos","text":"<p>Al igual que con los objetos reales, los objetos de nuestros programas tienen ciertos atributos o propiedades caracter\u00edsticos. Por ejemplo, un objeto de cajero autom\u00e1tico tendr\u00eda una cantidad actual de efectivo que podr\u00eda dispensar. Un objeto pieza ajedrez puede tener un par de atributos de fila y columna que especifiquen su posici\u00f3n en el tablero de ajedrez. Observe que los atributos de un objeto son en s\u00ed mismos objetos. El atributo de efectivo del cajero autom\u00e1tico y los atributos de fila y columna de la pieza de ajedrez son n\u00fameros.</p> <p>A veces nos referimos a la colecci\u00f3n de atributos y valores de un objeto como su estado.</p>"},{"location":"ud1/19poo/#acciones-o-metodos","title":"Acciones o M\u00e9todos","text":"<p>Adem\u00e1s de sus atributos o propiedades, los objetos tambi\u00e9n tienen acciones o comportamientos caracter\u00edsticos. Como ya dijimos, los objetos en los programas son din\u00e1micos. Hacen cosas o les hacen cosas.</p> <p>Por ejemplo, en un programa de ajedrez, ChessPieces tiene la capacidad de moveTo () a una nueva posici\u00f3n en el tablero de ajedrez. De manera similar, cuando un cliente presiona el bot\u00f3n \"Saldo actual\" en un cajero autom\u00e1tico, esto le est\u00e1 diciendo al cajero autom\u00e1tico que informe () el saldo bancario actual del cliente. (Observe c\u00f3mo usamos par\u00e9ntesis para distinguir acciones de objetos y atributos).</p> <p>Las acciones asociadas con un objeto se pueden utilizar para enviar mensajes a los objetos y recuperar informaci\u00f3n de los objetos. Un mensaje es el paso de informaci\u00f3n o datos de un objeto a otro. En este ejemplo, le decimos a pe\u00f3n1: Pieza de ajedrez que se mueva a (3,4).</p> <pre><code>    chessPiece.move(3, 4);\n</code></pre> <p>Los n\u00fameros 3 y 4 en este caso son argumentos que le dicen al pe\u00f3n a qu\u00e9 casilla moverse. (Un tablero de ajedrez tiene 8 filas y 8 columnas y cada cuadrado se identifica por sus coordenadas de fila y columna). En general, un argumento es un valor de datos que especializa el contenido de un mensaje de alguna manera.</p> <p>Responder a un mensaje o realizar una acci\u00f3n a veces provoca un cambio en el estado de un objeto. Por ejemplo, despu\u00e9s de realizar moveTo (3,4), el pe\u00f3n estar\u00e1 en una casilla diferente. Su posici\u00f3n habr\u00e1 cambiado.</p> <p>Por otro lado, algunos mensajes (o acciones) no modifican el estado del objeto. Informar el saldo de la cuenta bancaria del cliente no cambia el saldo.</p>"},{"location":"ud1/19poo/#caracteristicas-basicas","title":"Caracter\u00edsticas b\u00e1sicas","text":"<ul> <li>Estado: est\u00e1 representado por atributos de un objeto.</li> <li>Comportamiento: se representa mediante m\u00e9todos de un objeto. Tambi\u00e9n refleja la respuesta de un objeto con otros objetos.</li> <li>Identidad: le da un nombre \u00fanico a un objeto y permite que un objeto interact\u00fae con otros objetos.</li> </ul>"},{"location":"ud1/19poo/#creacion-y-destruccion-de-objetos","title":"Creaci\u00f3n y destrucci\u00f3n de objetos","text":""},{"location":"ud1/19poo/#creacion","title":"Creaci\u00f3n","text":"<p>Para crear un objeto utilizamos la palabra reservada new, que asigna memoria del Heap. Se usa el nombre de la clase (constructor) seguido por par\u00e9ntesis. Se le llama instanciar un objeto.</p> <pre><code>    ATM atm = new ATM();\n</code></pre>"},{"location":"ud1/19poo/#destruccion","title":"Destrucci\u00f3n","text":"<p>En Java no es posible destruir objetos de forma expl\u00edcita, los objetos se destruyen de forma autom\u00e1tica por el recolector de basura. Java busca objetos inalcanzables y los destruye, normalmente cuando falta memoria. Los convierte de nuevo en memoria binaria no utilizada.</p>"},{"location":"ud1/19poo/#uso-de-objetos-acceso-a-atributos-y-metodos","title":"Uso de objetos: acceso a atributos y m\u00e9todos","text":"<p>Para acceder a los atributos y m\u00e9todos de un objeto utilizamos la notaci\u00f3n \".\" detr\u00e1s del nombre del objeto. El objeto debe ser creado previamente sino dar\u00e1 error de compilaci\u00f3n.</p> <pre><code>    double cantidad = atm.efectivo;\natm.mostrarEfectivo();\n</code></pre> <p>M\u00e1s adelante veremos la visibilidad de los m\u00e9todos y atributos de los objetos.</p>"},{"location":"ud1/1elementos/","title":"\ud83d\udcbe Elementos de un programa inform\u00e1tico","text":"<p> Un programa es una secuencia de instrucciones que un ordenador ejecuta para realizar alguna tarea. Parece una idea bastante simple, pero para que el ordenador pueda hacer uso de las instrucciones, deben estar escritas de forma que las pueda usar. Esto significa que los programas deben estar escritos en lenguajes de programaci\u00f3n. Los lenguajes de programaci\u00f3n se diferencian de los lenguajes humanos ordinarios en que son completamente inequ\u00edvocos y muy estrictos sobre lo que est\u00e1 y no est\u00e1 permitido en un programa. Las reglas que determinan lo que est\u00e1 permitido se denominan sintaxis del lenguaje. Las reglas de sintaxis especifican el vocabulario b\u00e1sico del lenguaje y c\u00f3mo se pueden construir los programas. </p>"},{"location":"ud1/1elementos/#lenguajes-de-programacion","title":"Lenguajes de programaci\u00f3n","text":"<p>Se trata de un conjunto de instrucciones que permite la comunicaci\u00f3n de los humanos con los ordenadores.</p> <p></p> <p></p> <ol> <li>C --&gt; bases de datos, videojuegos, kernel linux, IOT, dispositivos inteligentes, etc.</li> <li>Python --&gt; inteligencia artificial, big data, etc.</li> <li>Java --&gt; puntos de ventas, aplicaciones de escritorio, cajeros autom\u00e1ticos, dispositivos m\u00f3viles, ...</li> </ol> <p></p>"},{"location":"ud1/1elementos/#con-que-lenguaje-de-programacion-debo-empezar","title":"\u00bfCon qu\u00e9 lenguaje de programaci\u00f3n debo empezar?","text":"<p>En realidad, no existe el mejor lenguaje de programaci\u00f3n para empezar, y el lenguaje que elijas pr\u00e1cticamente no tendr\u00e1 un efecto duradero en tu carrera. Los lenguajes de programaci\u00f3n pueden verse muy diferentes en la superficie, pero la mayor\u00eda de los conceptos fundamentales se transferir\u00e1n de un lenguaje a otro. Aprender un nuevo idioma tambi\u00e9n ser\u00e1 m\u00e1s f\u00e1cil con el tiempo; un principiante puede tardar meses antes de que se sienta c\u00f3modo con su primer lenguaje; un programador experimentado puede familiarizarse con un nuevo idioma en cuesti\u00f3n de d\u00edas.</p>"},{"location":"ud1/1elementos/#7-tips-para-aprender-a-programar-con-exito","title":"7 Tips para aprender a programar con \u00e9xito","text":"<pre><code>1. Learn by doing. Always play with the code while learning\n2. Grasp the fundamentals for long-term benefits\n3. Code by hand. It sharpens proficiency and you\u2019ll need it to get a job\n4. Ask for help. You\u2019ll need it\n5. Seek out more online resources. There\u2019s a wealth of content\n6. Don\u2019t just read the sample code. Tinker with it!\n7. Take breaks when debugging\n</code></pre> <p>Fuente: Coding dojo</p> <p>Tip</p> <p>S\u00e9 persistente, no te rindas!</p>"},{"location":"ud2/11booleanexpressions/","title":"Expresiones booleanas","text":"<p>Las sentencias if del cap\u00edtulo anterior inclu\u00edan preguntas simples de verdadero / falso (expresiones booleanas) como num&lt;10 o jugadores==1. A menudo, las expresiones booleanas simples no son suficientes. Este cap\u00edtulo trata sobre expresiones booleanas m\u00e1s complicadas.</p>"},{"location":"ud2/11booleanexpressions/#_1","title":"&amp;&amp;","text":"<p>El operador AND &amp;&amp; es un operador l\u00f3gico. Un operador l\u00f3gico examina dos valores verdadero / falso y genera un \u00fanico valor verdadero / falso.</p> <p>Por ejemplo cuando necesitas verificar m\u00e1s de una expresi\u00f3n.</p> <pre><code>    if (harina == 100 &amp;&amp; azucar &gt;= 65) {\n\n}\n</code></pre> <p>Cada parte es una expresi\u00f3n relacional. Una expresi\u00f3n relacional es un tipo de expresi\u00f3n booleana que usa un operador relacional para calcular un valor verdadero o falso.</p> <p>Las expresiones se eval\u00faan de izquierda a derecha, as\u00ed, tan pronto se detecta el primer false, la expresi\u00f3n entera se convierte en false y no se eval\u00faa el resto de expresiones.</p>"},{"location":"ud2/11booleanexpressions/#_2","title":"||","text":"<p>El operador OR || se usa en una expresi\u00f3n booleana para verificar que haya al menos una verdadera. Si solo un lado es verdadero, toda la expresi\u00f3n es verdadera. Si ambos lados son falsos, toda la expresi\u00f3n es falsa.</p> <pre><code>    if (ahorrosMensuales &gt; 1000 || pr\u00e9stamo == 3000) {\n\n}\n</code></pre>"},{"location":"ud2/11booleanexpressions/#_3","title":"!","text":"<p>El operador NOT ! cambia de verdadero a falso y de falso a verdadero. Esto puede parecer una tonter\u00eda, pero a menudo es \u00fatil. A veces es m\u00e1s natural expresar una condici\u00f3n de una manera particular, pero la l\u00f3gica del programa requiere lo contrario de lo que ha escrito.</p> <pre><code>    if (!(precio &lt; 35)) {\n\n}\n</code></pre>"},{"location":"ud2/1seleccion/","title":"Sentencia IF","text":"<p>Este apartado analiza c\u00f3mo los programas del ordenador toman decisiones utilizando la sentencia if. Esta sentencia es uno de los bloques de construcci\u00f3n fundamentales de la programaci\u00f3n.</p> <p>Veamos c\u00f3mo funciona.</p> <p>Los limpiaparabrisas se controlan con un interruptor de encendido y apagado. El diagrama de flujo de la derecha muestra c\u00f3mo se toma esta decisi\u00f3n.</p> <p>Comience en la parte superior del gr\u00e1fico y luego siga la l\u00ednea hasta la pregunta:</p> <p>\u00bfesta lloviendo? La respuesta es verdadera o falsa.</p> <p></p> <p>Si la respuesta es verdadera,</p> <ul> <li>siga la l\u00ednea etiquetada como Verdadero,</li> <li>siga las instrucciones en el cuadro \"Activo limpiaparabrisas ,</li> <li>siga la l\u00ednea para \"Continuar\".</li> </ul> <p>Si la respuesta es falsa,</p> <ul> <li>siga la l\u00ednea etiquetada como Falso,</li> <li>siga las instrucciones en el cuadro \"limpiaparabrisas desactivados\",</li> <li>siga la l\u00ednea para \"Continuar\".</li> </ul> Ejemplo del programa en c\u00f3digo <pre><code>public static void main(String[] args) {\n    Scanner scan = new Scanner( System.in );\n    String respuesta;\n    System.out.print(\"\u00bfEst\u00e1 lloviendo? (Y or N): \");\n    respuesta = scan.nextLine();\n\n    if (respuesta.equals(\"Y\")) {\n        System.out.println(\"Activa limpiaparabrisas\");\n    } else {\n        System.out.println(\"Desactiva limpiaparabrisas\");\n    }\n}\n</code></pre>"},{"location":"ud2/1seleccion/#sentencia-simple-condicional-if","title":"Sentencia simple condicional if","text":"<p>La declaraci\u00f3n if es la m\u00e1s b\u00e1sica de todas las declaraciones de flujo de control. Le dice a su programa que ejecute una determinada secci\u00f3n de c\u00f3digo solo si una prueba en particular se eval\u00faa como verdadera. La sentencia simple condicional if tiene la siguiente estructura:</p> <pre><code>    if (*condici\u00f3n*) {\n//sentencias\n}\n</code></pre> <p></p> <p>Condicion es una expresi\u00f3n booleana. Recuerde que una expresi\u00f3n es una combinaci\u00f3n de literales, operadores, nombres de variables y par\u00e9ntesis que se utilizan para calcular un valor, o incluso una llamada a un m\u00e9todo.</p> <p>Una expresi\u00f3n booleana es una expresi\u00f3n que se eval\u00faa como verdadera o falsa.</p> <p>Dada esta descripci\u00f3n de la sintaxis de la sentencia if, los siguientes son ejemplos de sentencias if v\u00e1lidas:</p> <pre><code>    if (true) {\nSystem.out.println(\"expresi\u00f3n if\");\n}\n\nint num = 6;\nif (num &gt; 0) {\nSystem.out.println(\"El n\u00famero es positivo.\");\n}\n</code></pre>"},{"location":"ud2/1seleccion/#sentencia-condicional-compuesta-if-else","title":"Sentencia condicional compuesta if-else","text":"<p>Una segunda versi\u00f3n de la sentencia if incorpora una cl\u00e1usula else en la estructura. Esto nos permite ejecutar cualquiera de dos declaraciones separadas (simple o compuesta) como resultado de un booleano expresi\u00f3n.</p> <pre><code>    if (*condici\u00f3n*) {\n//sentencias 1\n} else {\n//sentencias 2\n}\n</code></pre> <p></p> <p>Ejemplo:</p> <pre><code>    int numJugadores = 2;\n\nif (numJugadores == 1) {\nSystem.out.println(\"Single player\");\n} else {\nSystem.out.println(\"Multiplayer\");\n}\n</code></pre>"},{"location":"ud2/1seleccion/#sentencia-condicional-if-else-multiple","title":"Sentencia condicional if-else m\u00faltiple","text":"<p>Lo que se ejecuta dentro de los if or else, es decir las sentencias pueden ser a su vez sentencias if-else. En otras palabras, es posible incrustar una o m\u00e1s sentencias if-else dentro de otra sentencia if-else, creando as\u00ed una estructura de control anidada. Como ocurre con la mayor\u00eda de las cosas, hacer una estructura de control demasiado compleja no es una buena idea, pero existe una estructura de control est\u00e1ndar anidada ifelse que es muy \u00fatil. Se conoce como selecci\u00f3n de m\u00faltiples v\u00edas.</p> <pre><code>    if (*condici\u00f3n*) {\n//sentencias 1\n} else if (*condici\u00f3n*) {\n//sentencias 2\n} else if (*condici\u00f3n*) {\n...\n} else {\n//sentencias\n}\n</code></pre> <p></p> <p>Ejemplo:</p> <pre><code>    if (numJugadores == 1) {\nSystem.out.println(\"Single player\");\n} else if (numJugadores == 2) {\nSystem.out.println(\"Two player\");\n} else if (numJugadores == 3) {\nSystem.out.println(\"Multiplayer\");\n} else {\nSystem.out.println(\"Not possible, too many players\");\n}\n</code></pre>"},{"location":"ud2/22dowhile/","title":"Sentencia DO-WHILE","text":"<p>El bucle do-while es una variante del bucle while que proporciona el lenguaje de programaci\u00f3n Java. Se puede expresar de la siguiente forma:</p> <pre><code>    //inicializadores\ndo {\n//bloque de c\u00f3digo: sentencia(s)\n//actualizador\n} while (condici\u00f3n);\n</code></pre> <p></p> <p>La diferencia entre do-while y while es que do-while eval\u00faa la condici\u00f3n despu\u00e9s de ejecutar el cuerpo del bucle. Por lo tanto, las sentencias dentro del bloque do-while se ejecutan al menos una vez.</p> <p>Una estructura while correctamente dise\u00f1ada debe incluir 3 partes:</p> <ul> <li>un inicializador,</li> <li>una condici\u00f3n de bucle y</li> <li>un actualizador. El actualizador debe garantizar que la condici\u00f3n de entrada del bucle finalmente falle, permitiendo as\u00ed que el bucle termine.</li> </ul>"},{"location":"ud2/22dowhile/#ejemplo-muestra-los-numeros-del-0-al-4","title":"Ejemplo: Muestra los n\u00fameros del 0 al 4","text":"<pre><code>    int i = 0;\n\ndo {\nSystem.out.println(i);\ni++;\n} while (i &lt; 5);\n</code></pre> <p>Salida</p> <pre><code>    0\n    1\n    2\n    3\n    4\n</code></pre> <p>Traza</p> Iteraci\u00f3n Variable i &lt; 5 Acci\u00f3n i = 0 no se verifica imprime 0, incrementa i=1 1a i = 1 true imprime 1, i = 2 2a i = 2 true imprime 2, i = 3 3a i = 3 true imprime 3, i = 4 4a i = 4 true imprime 4, i = 5 5a i = 5 false termina"},{"location":"ud2/22dowhile/#ejemplo-sumar-los-numeros-del-0-al-10","title":"Ejemplo: Sumar los n\u00fameros del 0 al 10","text":"<pre><code>    int i = 0; //inicializador\nint suma = 0;\n\ndo {\nsuma = suma + i;\ni++;//actualizador\n} while (i &lt;= 10);\n\nSystem.out.println(suma);\n</code></pre> <p>Salida</p> <pre><code>    55\n</code></pre>"},{"location":"ud2/22for/","title":"Sentencia FOR","text":"<p>Un bucle de conteo, o bucle controlado por un contador, es un bucle en el que sabes de antemano cu\u00e1ntas veces se repetir\u00e1. Como por ejemplo el siguiente c\u00f3digo que cuenta hasta 100:</p> <pre><code>    int i = 0;\n\nwhile (i &lt; 100) {\nSystem.out.println(i):\ni++;\n}\n</code></pre> <p>Aunque podemos usar una estructura while como la anterior para codificar un bucle de conteo, Java posee una estructura para \u00e9ste prop\u00f3sito, el bucle for. El bucle for se utiliza cuando el n\u00famero de iteraciones es conocido. Mientras que while y do-while se utiliza generalmente cuando el n\u00famero de iteraciones no se conoce.</p> <pre><code>    for(inicializador; condici\u00f3n; modificador) {\n//cuerpo del bucle\n}\n\n//VARIANTES: Si solo tiene una sentencia en el cuerpo tambi\u00e9n \n//se puede escribir sin llaves\nfor(inicializador; condici\u00f3n; modificador)\n//sentencia;\n\nfor(inicializador; condici\u00f3n; modificador) //sentencia;\n</code></pre> <pre><code>    for(int i = 0; i &lt; 100; i++) {\nSystem.out.println(i);\n}\n</code></pre> <p>Proceso:</p> <ol> <li>Inicializador: inicializa y/o declara variables y se ejecuta solo una vez.</li> <li>Condici\u00f3n: se eval\u00faa la condici\u00f3n. Si la condici\u00f3n es verdadera, se ejecuta el cuerpo del bucle for.</li> <li>Modificador: actualiza el valor de inicializador.</li> <li>La condici\u00f3n se eval\u00faa nuevamente. El proceso contin\u00faa hasta que la condici\u00f3n es falsa.</li> </ol> <p></p>"},{"location":"ud2/22for/#ejemplo-imprime-cualquier-texto-por-pantalla-4-veces","title":"Ejemplo: Imprime cualquier texto por pantalla 4 veces","text":"<pre><code>    for (int i = 1; i &lt;= 4; ++i) {\nSystem.out.println(\"This is a for loop.\");\n}\n</code></pre> <p>Salida</p> <pre><code>    This is a for loop.\n    This is a for loop.\n    This is a for loop.\n    This is a for loop.\n</code></pre> <p>Traza</p> Iteraci\u00f3n Variable i &lt;= 4 Acci\u00f3n 1a i=1 true imprime texto, i=2 2a i=2 true imprime texto, i=3 3a i=3 true imprime texto, i=4 4a i=4 true imprime texto, i=5 5a i=5 false termina <p>La variable de inicializaci\u00f3n en el bucle for, puede ser declarada en otro lugar del c\u00f3digo. Ejemplo:</p> <pre><code>    int i;\n\n//c\u00f3digo\n\nfor (i = 1; i &lt;= 4; ++i) {\nSystem.out.println(\"This is a for loop.\");\n}\n</code></pre> <p>Pero esto, viola la idea de que todas las partes del bucle se combinan en una sola declaraci\u00f3n. Por tanto, estar\u00eda bien si la declaraci\u00f3n de la variable i forma parte de la declaraci\u00f3n for.</p> <p>Una variable declarada en una instrucci\u00f3n for solo se puede usar en esa instrucci\u00f3n y en el cuerpo del bucle.</p>"},{"location":"ud2/22for/#bucle-infinito","title":"Bucle infinito","text":"<p>Un l\u00edmite de bucle es un valor que controla cu\u00e1ntas veces se repite un bucle. Un bucle se repetir\u00e1 hasta que se alcance su l\u00edmite de bucle. La condici\u00f3n del bucle debe ser una expresi\u00f3n booleana que pruebe si se ha alcanzado el l\u00edmite del bucle. De manera similar, el actualizador debe modificar el contador del bucle para que avance hacia su l\u00edmite.</p> <p>Si nunca se alcanza el l\u00edmite del bucle, la condici\u00f3n del bucle nunca se volver\u00e1 falsa y el bucle se repetir\u00e1 para siempre. Esto se conoce como bucle infinito.</p> <p>Para salir de un programa con bucle infinito presiona CONTROL+C.</p>"},{"location":"ud2/22for/#bucle-for-each","title":"Bucle for-each","text":"<p>Lo veremos m\u00e1s adelante, cuando veamos los arrays y colecciones.</p>"},{"location":"ud2/22nestedloop/","title":"Bucles anidados","text":"<p>Un bucle anidado es una estructura en la que un bucle est\u00e1 contenido dentro del cuerpo de otro bucle.</p> <p>Por ejemplo, imagina que quieres imprimir algo como la siguiente tabla de n\u00fameros, donde en la fila y columnas superiores aparecen las posiciones y dentro de las filas tenemos fila x columna.</p> <p></p> <p>Para producir esta tabla de multiplicar, podr\u00edamos usar los siguientes bucles for anidados:</p> <pre><code>1    for (int fila = 1; fila &lt;= 4; fila++) { //para cada una de las 4 filas\n2        for (int col = 1; col &lt;= 9; col ++) //para cada una de las 9 columnas\n3            System.out.print(col * fila + \"\\t\"); //muestra la multiplicaci\u00f3n\n4        System.out.println(); //Empieza una nueva fila\n5    }\n</code></pre> <p>Indentamos el c\u00f3digo para hacer que sea m\u00e1s legible. En este ejemplo, el bucle externo controla el n\u00famero de filas en la tabla, es decir, nuestra elecci\u00f3n de fila como su contador de bucle.</p> <p>La instrucci\u00f3n println() (l\u00ednea 4) se ejecuta despu\u00e9s de que el bucle interno haya terminado de iterar, lo que nos permite imprimir una nueva fila en cada iteraci\u00f3n del bucle externo.</p> <p>El bucle interno imprime los nueve valores en cada fila imprimiendo la expresi\u00f3n col * fila. Obviamente, el valor de esta expresi\u00f3n depende de ambas variables de bucle.</p> <p>Analicemos un poco el ejemplo anterior:</p> <ol> <li>\u00bfCu\u00e1ntas veces se ejecuta la instrucci\u00f3n for en la l\u00ednea 2? El bucle interno se ejecuta una vez por cada iteraci\u00f3n del bucle externo. Por lo tanto, se ejecuta cuatro veces, que es el mismo n\u00famero de veces que se ejecuta la l\u00ednea 4.</li> <li>\u00bfCu\u00e1ntas veces se ejecuta la declaraci\u00f3n de la l\u00ednea 3? El cuerpo del bucle interno se ejecuta 36 veces, 9 veces por cada ejecuci\u00f3n de la l\u00ednea 2.</li> </ol>"},{"location":"ud2/22nestedloop/#patrones-de-for-anidado","title":"Patrones de FOR anidado","text":"<p>A veces es \u00fatil usar la variable del bucle externo como l\u00edmite para el bucle interno. Por ejemplo, veamos el siguiente patr\u00f3n:</p> <p></p> <p>El n\u00famero de s\u00edmbolos # en cada fila var\u00eda inversamente con el n\u00famero de fila. En la fila 1, tenemos cinco s\u00edmbolos; en la fila 2 tenemos cuatro; y as\u00ed sucesivamente hasta la fila 5, donde tenemos un #.</p> <p>Para producir este tipo de patr\u00f3n bidimensional, necesitamos dos contadores:</p> <ul> <li>uno para contar el n\u00famero de fila y</li> <li>otro para contar el n\u00famero de s\u00edmbolos # en cada fila.</li> </ul> <p>Debido a que tenemos que imprimir los s\u00edmbolos de cada fila antes de pasar a la siguiente fila, el ciclo externo contar\u00e1 los n\u00fameros de fila y el ciclo interno contar\u00e1 los s\u00edmbolos en cada fila.</p> <p>La siguiente tabla muestra la relaci\u00f3n que queremos:</p> Fila L\u00edmite (6-i) N\u00fam. s\u00edmbolos 1 6-1 5 2 6-2 4 3 6-3 3 4 6-4 2 5 6-5 1 <p>Si dejamos que j sea el contador del bucle interno, entonces j estar\u00e1 limitado por la expresi\u00f3n 6 - i. Esto conduce a la siguiente estructura de bucle anidado:</p> <pre><code>    for (int i = 1; i &lt;= 5 ; i++) {\nfor (int j = 1; j &lt;= (6 - i); j++) {\nSystem.out.print('#');\n}\nSystem.out.println();\n}\n</code></pre> <p>Otra soluci\u00f3n si no queremos usar un literal en la condici\u00f3n del bucle interno ser\u00eda:</p> <pre><code>    for (int i = 1; i &lt;= 5 ; i++) {\nfor (int j = 5; j &gt;= i; j--) {\nSystem.out.print('#');\n}\nSystem.out.println();\n}\n</code></pre> <p>A menudo los literales que aparecen como l\u00edmites en los bucles for se denominan n\u00fameros m\u00e1gicos y pueden crear problemas de redundancia en el c\u00f3digo o c\u00f3digo no legible. Para solucionar esto utilizamos constantes:</p> <pre><code>    final int MAX_WIDTH = 5;\n\nfor (int i = 1; i &lt;= MAX_WIDTH ; i++) {\nfor (int j = MAX_WIDTH; j &gt;= i; j--) {\nSystem.out.print('#');\n}\nSystem.out.println();\n}\n</code></pre>"},{"location":"ud2/22principlesloop/","title":"Principios del dise\u00f1o de bucles","text":"<ul> <li>Un bucle de conteo se utiliza siempre que se sepa de antemano exactamente cu\u00e1ntas iteraciones se necesitan. La instrucci\u00f3n for de Java es una estructura apropiada para codificar un bucle de conteo.</li> <li>Se debe usar una estructura while cuando el problema sugiera que el cuerpo del bucle puede omitirse por completo.</li> <li>Una estructura do-while debe usarse solo cuando un bucle requiere al menos una o m\u00e1s iteraciones.</li> <li>La variable de bucle se utiliza para especificar la condici\u00f3n de entrada de bucle. Debe inicializarse a un valor inicial apropiado y debe actualizarse en cada iteraci\u00f3n del bucle.</li> <li>El l\u00edmite de un bucle puede ser un recuento, un centinela o, de manera m\u00e1s general, un l\u00edmite condicional. Debe estar correctamente especificado en la expresi\u00f3n de entrada de bucle y el progreso hacia el l\u00edmite debe realizarse en el actualizador.</li> <li>Puede producirse un bucle infinito si el inicializador, la expresi\u00f3n de entrada de bucle o la expresi\u00f3n del actualizador no se especifican correctamente.</li> </ul>"},{"location":"ud2/22while/","title":"Sentencia WHILE","text":"<p>Una estructura de repetici\u00f3n es una estructura de control que repite una declaraci\u00f3n o secuencia de declaraciones de forma controlada. Las estructuras de repetici\u00f3n tambi\u00e9n se denominan estructuras de bucle. Muchos tipos de tareas de programaci\u00f3n requieren una estructura de repetici\u00f3n. Por ejemplo:</p> <ul> <li>Sumar los cuadrados de los n\u00fameros del 1 al 100.</li> <li>Un empleado de seguridad inform\u00e1tica quiere probar todas las contrase\u00f1as posibles para entrar en la cuenta de un presunto esp\u00eda.</li> <li>Quieres que los jugadores inserten movimientos durante un turno en un juego hasta que el juego ha terminado.</li> </ul> <p></p> <p>La instrucci\u00f3n while es una instrucci\u00f3n de bucle en la que la condici\u00f3n de bucle ocurre antes que el cuerpo del bucle. Tiene la siguiente estructura:</p> <pre><code>    while (condici\u00f3n) {\n//cuerpo del bucle\n//bloque de c\u00f3digo: sentencia(s)\n}\n\n//VARIANTES: Si solo tiene una sentencia en el cuerpo \n//tambi\u00e9n se puede escribir as\u00ed\nwhile (condici\u00f3n)\n//sentencia;\n</code></pre> <p>Contiene la palabra reservada while seguida de un bloque de c\u00f3digo. Un bloque es un conjunto de sentencias encerradas entre corchetes { y }.</p> <p>Cuando se ejecuta la instrucci\u00f3n while, se eval\u00faa la condici\u00f3n del bucle, que es una expresi\u00f3n booleana y sucede alguno de los siguientes escenarios:</p> <ol> <li>Si esto se eval\u00faa como falso, la ejecuci\u00f3n contin\u00faa en la instrucci\u00f3n inmediatamente despu\u00e9s del cuerpo del bucle(fuera del bloque).</li> <li>Si la condici\u00f3n de bucle se eval\u00faa como verdadero, el cuerpo del bucle se ejecuta y luego la condici\u00f3n se eval\u00faa nuevamente y se repite el proceso.</li> </ol> <p>El cuerpo del bucle contin\u00faa ejecut\u00e1ndose hasta que la condici\u00f3n se eval\u00faa como falsa.</p> <p>Para que una declaraci\u00f3n while realice una tarea, la variable o variables en la condici\u00f3n de entrada de bucle deben inicializarse correctamente antes; y adem\u00e1s estas variables deben actualizarse correctamente al final del cuerpo de bucle. Podemos reformular las pautas anteriores como un principio de dise\u00f1o:</p> <p>Una estructura while correctamente dise\u00f1ada debe incluir 3 partes:</p> <ul> <li>un inicializador,</li> <li>una condici\u00f3n de bucle y</li> <li>un actualizador. El actualizador debe garantizar que la condici\u00f3n de entrada del bucle finalmente falle, permitiendo as\u00ed que el bucle termine.</li> </ul> <pre><code>    //inicializadores\nwhile ( condici\u00f3n ) {\n//sentencias\n//actualizador\n}\n</code></pre>"},{"location":"ud2/22while/#ejemplo-mostrar-los-3-primeros-numeros","title":"Ejemplo: Mostrar los 3 primeros n\u00fameros","text":"<pre><code>    int i = 1; //inicializador\n\nwhile (i &lt;= 3) {\nSystem.out.println(i);//Sentencia\ni = i + 1;//actualizador\n}\n</code></pre> <p>Salida</p> <pre><code>    1\n    2\n    3\n</code></pre> <p>Traza</p> Iteraci\u00f3n Variable i &lt;= 3 Acci\u00f3n 1a i = 1 true imprime 1, incrementa i=2 2a i = 2 true imprime 2, incrementa i = 3 3a i = 3 true imprime 3, incrementa i = 4 4a i = 4 false termina el bucle"},{"location":"ud2/22while/#ejemplo-sumar-los-numeros-del-0-al-10","title":"Ejemplo: Sumar los n\u00fameros del 0 al 10","text":"<pre><code>    int i = 0; //inicializador\nint suma = 0;\n\nwhile (i &lt;= 10) {\nsuma = suma + i;\ni++;//actualizador\n}\n\nSystem.out.println(suma);\n</code></pre> <p>Salida</p> <pre><code>    55\n</code></pre> <p>Traza</p> Iteraci\u00f3n Variable i &lt;= 10 Acci\u00f3n 1a suma=0, i=0 true suma=0, incrementa i(1) 2a suma=0, i=1 true suma=1, incrementa i(2) 3a suma=1, i=2 true suma=3, incrementa i(3) 4a suma=3, i=3 true suma=6, incrementa i(4) 5a suma=6, i=4 true suma=10, incrementa i(5) .. .. .. .. 12a suma=55, i=11 false termina"},{"location":"ud2/22whileif/","title":"Bucles WHILE con sentencias IF","text":"<p>Este cap\u00edtulo muestra c\u00f3mo los bucles while y las instrucciones if se usan juntas para implementar la l\u00f3gica de un programa.</p> <p>El siguiente c\u00f3digo muestra un esqueleto de un programa que suma todos los n\u00fameros enteros hasta un l\u00edmite y suma tambi\u00e9n los que son n\u00fameros pares.</p> <p></p>"},{"location":"ud2/22whileif/#step-1","title":"STEP 1","text":"<p>Primero, inicializamos la variable count. El bucle debe contar desde uno hasta el l\u00edmite(incluido). En este programa, la mayor parte de la l\u00f3gica est\u00e1 contenida dentro del cuerpo del bucle.</p> <p></p> <p>Comprobamos que el programa se puede compilar y ejecutar. Si no fuera as\u00ed, corrige los errores de sintaxis (si los hay) y busca qu\u00e9 errores tienes. Inserta algunas sentencias println temporales para ayudarte en la b\u00fasqueda de errores. (O usa un depurador).</p> <p>Tip</p> <p>Es mejor escribir un programa por etapas. Escriba y depura cada etapa antes de construir sobre el. En un programa con un bucle principal, la primera etapa es construir el bucle.</p>"},{"location":"ud2/22whileif/#step-2","title":"STEP 2","text":"<p>El bucle de momento solo cuenta n\u00fameros hasta un l\u00edmite, pero todav\u00eda no hace nada con ellos. Esto es lo que queremos que suceda:</p> <ul> <li>Sumar cada entero y asignarlo a sumaTotal.</li> <li>Sumar cada entero par y asginarlo a sumaPar.</li> </ul> <p>\u00bfC\u00f3mo decidimos cuando agregar un n\u00famero entero a sumaPar? Para ello necesitaremos la sentencia if.</p> <p>El cuerpo del bucle en este programa contiene una instrucci\u00f3n if. Una instrucci\u00f3n if dentro de un cuerpo de bucle se denomina if anidado. No tiene nada de especial funciona igual que fuera del cuerpo del bucle.</p> <p></p> <p>\u00bfC\u00f3mo calculamos los n\u00fameros que son pares? Los n\u00fameros pares son aquellos que son divisibles por 2. Podemos hacerlo usando el operador %. Si el resto al dividir entre 2 da 0, entonces obtenemos un n\u00famero par.</p> <p></p>"},{"location":"ud2/23breakcontinue/","title":"Break y continue","text":"<p>Las sentencias break y continue son las sentencias de salto que se utilizan para omitir algunas sentencias dentro del bucle o terminar el bucle inmediatamente sin comprobar la condici\u00f3n. Estas instrucciones se pueden usar dentro de cualquier bucle, como for, while, do-while.</p>"},{"location":"ud2/23breakcontinue/#break","title":"BREAK","text":"<p>Ya se ha visto la instrucci\u00f3n break utilizada en un cap\u00edtulo anterior de este tutorial. En concreto en la estructura switch.</p> <p>La sentencia break en java se usa para terminar el bucle inmediatamente.</p> <p>Cuando se encuentra una sentencia break dentro de un bucle, la iteraci\u00f3n del bucle se detiene ah\u00ed y el control vuelve a la primera sentencia despu\u00e9s del bucle, es decir, la primera sentencia que se encuentra al salir del bucle.</p> <p>B\u00e1sicamente, las instrucciones break se utilizan en situaciones en las que no estamos seguros del n\u00famero real de iteraciones del bucle o queremos terminar el bucle en funci\u00f3n de alguna condici\u00f3n.</p> <pre><code>    for (int i = 0; i &lt; 10; i++) {\nif (i == 3)\nbreak;\nSystem.out.print(i + \" \");\n}\n\nSystem.out.println(\"Fuera del bucle for\");\n</code></pre> <pre><code>Output: 0 1 2\nFuera del bucle for\n</code></pre> <p>Note</p> <p>En el caso de bucles anidados, la instrucci\u00f3n break termina el bucle m\u00e1s interno.</p>"},{"location":"ud2/23breakcontinue/#break-etiquetado","title":"Break etiquetado","text":"<p>Hasta ahora, hemos utilizado la sentencia break sin etiquetar. Sin embargo, hay otra forma de utilizar break en Java conocido como break etiquetado (labeled break).</p> <p></p> <p>En la imagen se ha utilizado un break etiquetado con el identificador label para especificar el bucle exterior. Observa c\u00f3mo se usa la declaraci\u00f3n break con etiqueta.</p> <p>La sentencia break est\u00e1 terminando la sentencia etiquetada (es decir, el bucle externo). Luego, el control del programa salta a la sentencia justo despu\u00e9s de la etiquetada.</p> <p>De esta forma, podr\u00edamos utilizar la sentencia break etiquetada para terminar el bucle m\u00e1s externo como se ve en el siguiente ejemplo:</p> <pre><code>    public static void main(String[] args) {\n\n//el primer bucle es etiquetado como primero\nprimero:\nfor( int i = 1; i &lt; 5; i++) {\n\n// el segundo bucle como segundo\nsegundo:\nfor(int j = 1; j &lt;= 2; j ++ ) {\nSystem.out.println(\"i = \" + i + \"; j = \" +j);\n\n// se realiza un break del primer bucle\nif ( i == 2)\nbreak primero;\n}\n}\n}\n</code></pre> <pre><code>Output\ni = 1; j = 1\ni = 1; j = 2\ni = 2; j = 1\n</code></pre>"},{"location":"ud2/23breakcontinue/#continue","title":"CONTINUE","text":"<p>La instrucci\u00f3n continue en Java se usa para omitir la iteraci\u00f3n actual de un bucle y continuar con la siguiente iteraci\u00f3n del bucle.</p> <p>Podemos usar la instrucci\u00f3n continue dentro de cualquier tipo de bucle, como el bucle for, while y do-while.</p> <p>B\u00e1sicamente, las sentencias continue se utilizan en situaciones en las que queremos continuar el ciclo pero no queremos la sentencia restante despu\u00e9s de la sentencia continue.</p> <pre><code>    for (int i = 0; i &lt; 5; i++) {\nif (i == 2)\ncontinue;\n\nSystem.out.print(i + \" \");\n}\n</code></pre> <pre><code>Output: 0 1 3 4\n</code></pre>"},{"location":"ud2/24exceptions/","title":"Excepciones","text":""},{"location":"ud2/24exceptions/#jerarquia-de-excepciones-en-java","title":"Jerarqu\u00eda de excepciones en Java","text":"<p>La clase Throwable es la clase base incorporada que se usa para manejar todas las excepciones en Java. El tipo m\u00e1s gen\u00e9rico de excepci\u00f3n, java.lang.Exception, se encuentra en el paquete java.lang, pero la mayor\u00eda de sus subclases est\u00e1n contenidas en otros paquetes. </p> <p>Un programa a menudo encuentra problemas mientras se ejecuta. Puede tener problemas para leer datos, puede haber caracteres ilegales en los datos o un \u00edndice puede salirse de los l\u00edmites. La clase Java que gestiona estos problemas se llama Exception.</p> <p>La entrada y la salida son especialmente propensas a errores. El manejo de excepciones es esencial para la programaci\u00f3n de I/O.</p> <p>Por ejemplo, \u00bfqu\u00e9 ha ido mal en el siguiente programa?:</p> <p></p> <p>Si hacemos un seguimiento a la pila de errores, vemos que el usuario insert\u00f3 \"hola\" y la clase Scanner, en concreto el m\u00e9todo nextInt no pudo convertir ese texto en un n\u00famero, por tanto, se lanz\u00f3 una excepci\u00f3n.</p> <p>Eso no significa que el programa est\u00e9 mal, simplemente el fallo est\u00e1 en los datos. Cuando nextInt encuentra el problema lanza la excepci\u00f3n InputMismatchException. La ejecuci\u00f3n del programa Java detecta la excepci\u00f3n y detiene el programa imprimiendo los mensajes de error.</p> <p>Es muy importante leer bien la pila de errores en la consola cuando se lanza una excepci\u00f3n para encontrar el fallo.</p> <p></p>"},{"location":"ud2/24exceptions/#que-es-un-error","title":"\u00bfQu\u00e9 es un error?","text":"<p>Un error indica que se ha producido un fallo no recuperable, del que no se puede recuperar la ejecuci\u00f3n normal del programa. Un error est\u00e1 representado por un objeto de clase Error.</p> <p>La clase Throwable tiene dos subclases: Exception y Error. Un m\u00e9todo Java puede \"lanzar\" un objeto de clase Throwable. Por ejemplo, Scanner lanz\u00f3 una excepci\u00f3n cuando intent\u00f3 convertir \"hola\" en un n\u00famero entero.</p> <p>Las excepciones son diferentes de los errores porque los programas se pueden escribir para recuperarse de las excepciones, pero los programas no se pueden escribir para recuperarse de los errores.</p>"},{"location":"ud2/24exceptions/#que-es-una-excepcion","title":"\u00bfQu\u00e9 es una excepci\u00f3n?","text":"<p>Una excepci\u00f3n es un problema que ocurre cuando se ejecuta un programa. Cuando ocurre una excepci\u00f3n, la m\u00e1quina virtual Java crea un objeto de clase Exception que contiene informaci\u00f3n sobre el problema. Cuando se lanza una excepci\u00f3n, se puede capturar la excepci\u00f3n para recuperarse del programa.</p>"},{"location":"ud2/24exceptions/#bloques-try-catch","title":"Bloques try -  catch","text":"<p>Para capturar una excepci\u00f3n realizamos los siguientes pasos:</p> <ol> <li>Colocar el c\u00f3digo que pueda lanzar una excepci\u00f3n dentro de un bloque try.</li> <li>Colocar el c\u00f3digo que maneja la excepci\u00f3n dentro de un bloque catch (captura).</li> <li>El bloque catch debe seguir inmediatamente al bloque try.</li> </ol> <p>Cada bloque catch es un manejador de excepciones que maneja el tipo de excepci\u00f3n indicado por su argumento. El tipo de argumento, ExceptionType, declara el tipo de excepci\u00f3n que el controlador puede manejar y debe ser el nombre de una clase que hereda de la clase Throwable.</p> <p>El siguiente ejemplo arroja dentro del bloque try una InputMismatchException, el bloque catch comienza a ejecutarse inmediatamente. Se omiten las sentencias restantes en el bloque try.</p> <pre><code>    Scanner sc = new Scanner(System.in);\nint numero;\n\nSystem.out.println(\"Introduzca un entero:\");\n\ntry {\nnumero = sc.nextInt();\n} catch (InputMismatchException e) {\nSystem.out.println(\"No has introducido un n\u00famero.\");\ne.printStackTrace();\n}\n\nSystem.out.println(\"Sigue ejecut\u00e1ndose el programa\");\n</code></pre> <p>El par\u00e1metro dentro de catch e se refiere al objeto de excepci\u00f3n que se lanza. Si queremos mostrar la pila de errores que genera el error usamos el m\u00e9todo e.printStackTrace();</p> <p>Despu\u00e9s de ejecutar el bloque catch, la ejecuci\u00f3n contin\u00faa con la instrucci\u00f3n que sigue al bloque catch. La ejecuci\u00f3n no vuelve al bloque try.</p>"},{"location":"ud2/24exceptions/#como-se-ejecuta-un-try-catch-paso-por-paso","title":"C\u00f3mo se ejecuta un try-catch paso por paso","text":"<ol> <li>Cuando se lanza una excepci\u00f3n dentro de un bloque try, el controlador de excepciones examina la excepci\u00f3n dentro de los bloques catch.</li> <li>Los bloques catch se examinan uno a uno empezando por el primero.</li> <li>El primer bloque catch que encaja con la excepci\u00f3n obtiene el control. Aunque haya muchas excepciones que encajen solo se ejecuta un bloque catch.</li> <li>Si ning\u00fan bloque catch encaja con la excepci\u00f3n lanzada se muestra la pila de errores y se termina la ejecuci\u00f3n del programa ya que no se ha manejado la excepci\u00f3n.</li> <li>Las clases m\u00e1s especificas deben ir primero seguidas de las m\u00e1s generales.</li> <li>Despu\u00e9s de ejecutar la \u00faltima instrucci\u00f3n dentro del catch el control del programa vuelve a la siguiente l\u00ednea fuera del try-catch (o finally si hubiera).</li> </ol>"},{"location":"ud2/24exceptions/#capturar-mas-de-una-excepcion-en-un-solo-catch","title":"Capturar m\u00e1s de una excepci\u00f3n en un solo catch","text":"<p>En Java SE 7 y posteriores, un solo bloque catch puede manejar m\u00e1s de un tipo de excepci\u00f3n. Esta funci\u00f3n puede reducir la duplicaci\u00f3n de c\u00f3digo.</p> <p>En la cl\u00e1usula catch, se especifican los tipos de excepciones que puede manejar el bloque y se separa cada tipo de excepci\u00f3n con una barra vertical (|):</p> <pre><code>catch (IOException | SQLException ex) {\n//realizar acciones\n}\n</code></pre> <p>Note</p> <p>Si un bloque catch maneja m\u00e1s de un tipo de excepci\u00f3n, el par\u00e1metro catch es impl\u00edcitamente final. En este ejemplo, la variable catch ex es final y, por lo tanto, no puede asignarle ning\u00fan valor dentro del bloque catch.</p>"},{"location":"ud2/24exceptions/#sentencia-throw","title":"Sentencia throw","text":"<p>Utilizando la palabra reservada throw podemos lanzar nosotros expl\u00edcitamente una excepci\u00f3n.</p> <p>Podemos construir una instancia de la excepci\u00f3n que queremos lanzar y a\u00f1adirle un mensaje en el constructor.</p> <p>Ejemplo:</p> <pre><code>    try {\nSystem.out.print(\"Inserta el numerador: \");\nnum = scan.nextInt();\nSystem.out.print(\"Inserta el denominador: \");\ndiv = scan.nextInt();\n\nif ( div == 0 ) throw new ArithmeticException(\"Error al intentar dividir entre cero\");\n\n....\n} catch (ArithmeticException ex) { System.out.println(\"No se puede dividir \" + num + \" entre \" + div);\nSystem.out.println(ex.getMessage());\n} </code></pre>"},{"location":"ud2/24exceptions/#bloque-finally","title":"Bloque finally","text":"<p>El bloque finally siempre se ejecuta cuando sale del bloque try-catch incluso si ocurre una excepci\u00f3n inesperada.</p> <p>Estructura:</p> <pre><code>try {\n//c\u00f3digo\n} catch () {\n//c\u00f3digo\n} finally {\n//siempre se ejecuta\n}\n</code></pre> <p>Solo puede haber un bloque finally, y debe estar despu\u00e9s de los bloques catch.</p> <ul> <li>Si el bloque try sale normalmente (no ocurrieron excepciones), entonces el control va directamente al bloque finally.</li> <li>Si el bloque try sale debido a una excepci\u00f3n que es manejada por un bloque catch, primero ese bloque se ejecuta y luego el control va al bloque finally.</li> <li>Si el bloque try sale debido a una excepci\u00f3n que NO es manejada por un bloque catch, el control va directamente al bloque finally. Despu\u00e9s de que se ejecuta el bloque finally, se lanza la excepci\u00f3n a la persona que llama y el control vuelve a la persona que llama.</li> </ul> <p></p> <p>En resumen: si el control entra en un bloque try, siempre entrar\u00e1 en el bloque finally.</p> <p>Importante</p> <p>El bloque finally es una herramienta clave para prevenir fugas de recursos. Al cerrar un archivo o recuperar recursos, coloque el c\u00f3digo en un bloque final para asegurarse de que el recurso siempre se recupere.</p>"},{"location":"ud2/24exceptions/#sentencia-try-with-resources","title":"Sentencia try-with-resources","text":"<p>Pr\u00f3ximamente.</p> <p>Tip</p> <p>M\u00e1s informaci\u00f3n en oracle-exceptions java</p>"},{"location":"ud2/25fallos/","title":"Prueba y depuraci\u00f3n de aplicaciones","text":"<p>Todo IDE ofrece un conjunto de herramientas para hacer debug.</p> <p>El debug permite supervisar la ejecuci\u00f3n de los programas, para localizar y eliminar los errores de programaci\u00f3n.</p> <p>Es necesario que un programa compile para poder depurarlo.</p> <ul> <li>Permite suspender la ejecuci\u00f3n de un programa, examinar y establecer los valores de las variables, comprobar los valores devueltos por un determinado m\u00e9todo, el resultado de una comparaci\u00f3n l\u00f3gica o relacional, etc...</li> </ul>"},{"location":"ud2/25fallos/#debug-en-intellij","title":"Debug en IntelliJ","text":"<p>Run --&gt; Debug</p>"},{"location":"ud2/25fallos/#breakpoint-punto-de-ruptura","title":"Breakpoint / Punto de ruptura","text":"<ul> <li> <p>Permite detener un programa en una l\u00ednea/parte determinada.</p> <p>1) Click sobre el n\u00famero de l\u00ednea o CTRL + F8</p> </li> <li> <p>Una vez se detiene el programa podemos:</p> <p>1) Analizar el valor de cualquier variable/propiedad</p> <p>2) Analizar el valor de una expresi\u00f3n.</p> <p>3) Ejecutar l\u00ednea a l\u00ednea y comprobar el flujo de la aplicaci\u00f3n.</p> </li> <li> <p>Tras realizar la comprobaci\u00f3n, se puede:</p> <p>1) Detener el programa.</p> <p>2) O continuar su ejecuci\u00f3n hasta el final.</p> </li> </ul>"},{"location":"ud2/25fallos/#tipos-de-ejecucion","title":"Tipos de ejecuci\u00f3n","text":"<ul> <li>Primero hemos de lanzar el Debug (ALT + SHIFT + F9)</li> <li>Step Over (F8) / Paso a paso:</li> <li>Step Into (F7) / Paso a paso entrando en el m\u00e9todo/procedimiento</li> <li>Resume (F9) / Continuar</li> <li>Step Out (SHIFT + F8) / Ejecuci\u00f3n de un programa hasta el final</li> </ul>"},{"location":"ud2/25fallos/#examinador-de-variables","title":"Examinador de variables","text":"<ul> <li>En cualquier momento podemos inspeccionar el valor y tipo de una variable</li> <li>Si queremos evaluar esas variables m\u00e1s de una vez, es mejor crear un \u201cWatchpoint\u201d sobre ellas</li> <li>Bot\u00f3n derecho + Add to Watches o pesta\u00f1a variables</li> </ul>"},{"location":"ud2/25fallos/#proceso-de-depuracion","title":"Proceso de depuraci\u00f3n","text":"<p>1) Localizar el problema</p> <p>2) Poner un breakpoint en la l\u00ednea del error o en la entrada a la llamada</p> <pre><code>\u25cf Poner watchpoint sobre los datos m\u00e1s sensibles\n</code></pre> <p>3) Lanzar el Debug y utilizar Step Over o Step Into. En cada paso, evaluar el contenido de las variables o expresiones fijadas.</p> <p>4) Una vez localizado el error, detener el debug.</p>"},{"location":"ud2/25fallos/#cambiar-codigo-en-caliente","title":"Cambiar c\u00f3digo en caliente","text":"<ul> <li>Al detener un programa mediante un breakpoint, podemos modificar el valor de cualquier variable y ver c\u00f3mo act\u00faa nuestro c\u00f3digo.</li> <li>Pesta\u00f1a Variables \u2192 campo bot\u00f3n derecho \u2192 set value...</li> </ul>"},{"location":"ud2/26methods/","title":"Introducci\u00f3n a los m\u00e9todos en Java","text":"<p>Los m\u00e9todos sirven para hacer nuestro c\u00f3digo m\u00e1s legible, m\u00e1s f\u00e1cil de mantener y sin c\u00f3digo duplicado. Todo el tiempo hemos estado usando un m\u00e9todo llamado main, dentro de \u00e9l se encuentran todas las sentencias que hemos ido ejecutando, ahora vamos a crear nuestros propios m\u00e9todos teniendo en cuenta:</p> <p></p> <p></p> <p>Los m\u00e9todos se alinean unos debajo de otros, no se puede insertar un m\u00e9todo dentro de otro m\u00e9todo, y adem\u00e1s deben estar dentro de la clase.</p>"},{"location":"ud2/26methods/#sentencia-return-valores-devueltos","title":"Sentencia <code>Return</code> - Valores devueltos","text":"<p>Un valor devuelto es informaci\u00f3n que un m\u00e9todo devuelve al c\u00f3digo que lo llam\u00f3. Cada m\u00e9todo solo puede devolver un valor: cuando un m\u00e9todo regresa, deja de ejecutarse (y continuamos donde lo dejamos antes de llamar al m\u00e9todo). Para que el c\u00f3digo que llam\u00f3 al m\u00e9todo use el valor devuelto, el valor devuelto debe almacenarse en una variable o usarse inmediatamente.</p> <pre><code>public static type methodName(parameters) { // llamar a nombre de m\u00e9todo devuelve expresi\u00f3n\n...\nreturn expression;\n}\ntype variableName = methodName(parameters);  // variableName almacena el valor de retorno\n</code></pre> <p>Ejemplo</p> <pre><code>public class Main {\n\npublic static void main(String[] args) {\nboolean gameOver = true;\nint puntuacion = 5000;\nint nivelCompletado = 5;\nint bonus = 10;\n\nint score = calcularPuntuacion(gameOver, puntuacion, nivelCompletado, bonus);\nSystem.out.println(score);\n\n//otra forma de hacerlo es pasarle directamente el valor de las variables\nscore = calcularPuntuacion(true, 1000, 10, 30);\nSystem.out.println(score);\n\n}\n\npublic static int calcularPuntuacion(boolean gameOver, int puntuacion, int nivelCompletado, int bonus) {\nif (gameOver) {\nint puntuacionFinal = puntuacion + (nivelCompletado * bonus);\npuntuacionFinal += 100;\nreturn puntuacionFinal;\n} else {\nreturn -1;\n}\n}\n\n//OTRAS FORMAS M\u00c1S EFICIENTES DE CREAR EL M\u00c9TODO calcularPuntuaciones\n//1. M\u00e9todo m\u00e1s eficiente sin sentencia else\npublic static int calcularPuntuacion(boolean gameOver, int puntuacion, int nivelCompletado, int bonus) {\nif (gameOver) {\nint puntuacionFinal = puntuacion + (nivelCompletado * bonus);\npuntuacionFinal += 100;\nreturn puntuacionFinal;\n}\nreturn -1;\n}\n\n//2. Otra forma de realizar el m\u00e9todo calcularPuntuacion sin utilizar dos sentencias de return ser\u00eda\npublic static int calcularPuntuacion(boolean gameOver, int puntuacion, int nivelCompletado, int bonus) {\nint puntuacionFinal = -1;\nif (gameOver) {\nint puntuacionFinal = puntuacion + (nivelCompletado * bonus);\npuntuacionFinal += 100;\n}\nreturn puntuacionFinal;\n}\n\n}\n</code></pre>"},{"location":"ud2/2switch/","title":"Sentencia SWITCH","text":"<p>Otra estructura de selecci\u00f3n o alternativa para agregar a nuestro repertorio es la estructura switch.</p> <p></p> <p>La expresi\u00f3n switch se eval\u00faa una vez. El valor de la expresi\u00f3n se compara con los valores de cada caso. Si hay una coincidencia, se ejecuta el bloque de c\u00f3digo asociado. Las palabras clave break y default son opcionales. Los casos (case) suelen ser literales que no var\u00edan, y a menudo se usan constantes o el tipo de dato enum.</p> <p>Es una forma abreviada de codificar la estructura de selecci\u00f3n m\u00faltiple que vimos en el cap\u00edtulo anterior.</p> <p>De forma que el siguiente c\u00f3digo expresado con if-else m\u00faltiple:</p> <pre><code>    if (numJugadores == 1) {\nSystem.out.println(\"Single player\");\n} else if (numJugadores == 2) {\nSystem.out.println(\"Two player\");\n} else if (numJugadores == 3) {\nSystem.out.println(\"Multiplayer\");\n} else {\nSystem.out.println(\"Not possible, too many players\");\n}\n</code></pre> <p>Es equivalente a:</p> <pre><code>    switch (numJugadores) {\ncase 1:\nSystem.out.println(\"Single player\");\nbreak;\ncase 2:\nSystem.out.println(\"Two player\");\nbreak;\ncase 3:\nSystem.out.println(\"Multiplayer\");\nbreak;\ndefault:\nSystem.out.println(\"Not possible, too many players\");\n}\n</code></pre>"},{"location":"ud2/2switch/#break","title":"BREAK","text":"<p>Cuando el programa Java alcanza la palabra break, se sale del bloque switch. Es decir, ya no se sigue ejecutando m\u00e1s c\u00f3digo dentro del switch ni ning\u00fan case.</p> <p>Un break puede ahorrar mucho tiempo de ejecuci\u00f3n porque \"ignora\" la ejecuci\u00f3n de todo el resto del c\u00f3digo switch.</p>"},{"location":"ud2/2switch/#default","title":"DEFAULT","text":"<p>La palabra default se usa para ejecutar c\u00f3digo cuando no hay ninguna coincidencia con ning\u00fan caso (case). Siempre se pone al final, por tanto no necesita de la instrucci\u00f3n break.</p>"},{"location":"ud3/1metodoclase/","title":"\ud83c\udf0e Clases en Java","text":"<p>Las clases es el componente fundamental en la POO. Para entender el concepto de clase, primero necesitamos entender que son los objetos ya que son la clave en la tecnolog\u00eda orientada a objetos.</p>"},{"location":"ud3/1metodoclase/#objetos","title":"Objetos","text":"<p>Los objetos de software son una parte fundamental de la programaci\u00f3n orientada a objetos. Son muy similares a los objetos que representan cosas del mundo real. Como puede ser un micr\u00f3fono, altavoz, ordenador, etc. Como ya estudiamos en la unidad 1, los objetos del mundo real tienen tres caracter\u00edsticas, identidad, estado y comportamiento.</p> <p></p>"},{"location":"ud3/1metodoclase/#identidad","title":"\u2747\ufe0f Identidad","text":"<p>La identidad de un objeto normalmente se implementa a trav\u00e9s de un ID \u00fanico. El valor del ID no es visible para el usuario externo. Sin embargo, la JVM lo utiliza internamente para identificar cada objeto de forma \u00fanica.</p>"},{"location":"ud3/1metodoclase/#estado-campos","title":"\u2747\ufe0f Estado - Campos","text":"<p>Representa el valor de los datos. Por ejemplo, para un ordenador, el estado podr\u00eda ser la cantidad de memoria RAM que tiene, el sistema operativo que incluye, tama\u00f1o del disco duro, etc. En el caso de una persona, el estado puede ser la edad, el nombre, si est\u00e1 casada, etc.</p>"},{"location":"ud3/1metodoclase/#comportamiento-metodos","title":"\u2747\ufe0f Comportamiento - M\u00e9todos","text":"<p>Atendiendo al comportamiento de un ordenador podr\u00eda ser arrancando, apag\u00e1ndose, reiniciando, escribir en la pantalla, etc. Para una persona ser\u00e1 comer, beber, dormir, etc.</p> <p>Los objetos de software almacenan su estado en campos. Los campos es lo que conocemos como variables. Y exponen su comportamiento en lo que llamamos m\u00e9todos.</p> <p>\ud83d\udc80 Importante</p> <p>Un objeto es una instancia de la clase. Una clase es una plantilla o modelo a partir del cual se crean objetos. Entonces, un objeto es la instancia (resultado) de una clase.</p>"},{"location":"ud3/1metodoclase/#clases","title":"Clases","text":"<p>Teniendo en cuenta todo esto, podemos pasar a hablar de clase. Una clase es una plantilla para crear objetos. Para crear un clase en Java utilizamos la palabra reservada <code>class</code>.</p> <p>La nomenclatura del nombre de la clase es primera letra en may\u00fasculas y usar la regla CamelCase para palabras compuestas.</p> <pre><code>    public class Coche {\n\n}\n</code></pre> <p><code>public</code>: es un modificador de acceso, determina qu\u00e9 acceso queremos permitir a otros en la clase. Existen tres tipos de modificadores de acceso:</p> <ul> <li>public: en este caso, public especifica que no hay ninguna restricci\u00f3n de acceso.</li> <li>private: nadie puede acceder a la clase.</li> <li>protected: permite a las clases de este paquete acceder y subclases.</li> </ul> <ul> <li>class: identificador de clase.</li> </ul> <p>\u00bfDe qu\u00e9 forma nos ayudan las clases en nuestro c\u00f3digo? Bien, hasta ahora solo hemos trabajado con tipos de datos primitivos como int, short, char, etc. Este tipo de datos es bastante limitado. Por tanto, las clases se podr\u00edan considerar como un tipo de dato extra poderoso definido por el usuario que nos permite realizar acciones en las que los datos primitivos se quedan cortos.</p> <p>Una clase puede contener:</p> <ul> <li>Campos</li> <li>M\u00e9todos</li> <li>Constructores</li> <li>Bloques de c\u00f3digo</li> <li>Clases o interfaces anidadas</li> </ul>"},{"location":"ud3/1metodoclase/#miembros-de-la-clase-atributos-y-metodos","title":"Miembros de la clase : atributos y m\u00e9todos","text":""},{"location":"ud3/1metodoclase/#atributos-campos-de-la-clase-o-variables-de-instancia","title":"Atributos, campos de la clase o variables de instancia","text":"<p>Hasta ahora hemos creado variables dentro de un m\u00e9todo. A \u00e9stas se les llama variables locales porque son propias del m\u00e9todo en si. Y no puedes acceder a ellas desde fuera de ese m\u00e9todo. Tambi\u00e9n vimos esto dentro de bloques de c\u00f3digo {}, donde las variables creadas en un bloque m\u00e1s interno no eran accesibles en bloques m\u00e1s externos. Ejemplo:</p> <pre><code>    public static void sumar() {\nint contador = 0;\n\nwhile (contador &lt; 10) {\nint suma = 0;\nsuma += contador;\ncontador ++;\n}\n\nSystem.out.println(suma); // esto da error, la variable\n// suma aqu\u00ed no existe.\n}\n</code></pre> <p>A diferencia de esto, las clases nos permiten crear variables que pueden ser accesibles desde cualquier lugar dentro de la clase que estamos creando. A estas variables se les conoce con el nombre de variables miembro/instancia, o de manera m\u00e1s com\u00fan como campos o atributos de la clase.</p>"},{"location":"ud3/1metodoclase/#creacion-de-atributos-de-la-clase","title":"Creaci\u00f3n de atributos de la clase","text":"<p>Para crear un campo de la clase se debe especificar un modificador de acceso(opcional) + tipo de dato + nombre de la variable + inicializaci\u00f3n(opcional).</p> <p>Si no se pone modificador utiliza el de por defecto en el que la variable es accesible por las clases dentro del mismo paquete.</p> <p>El modificador de acceso funciona de la misma forma a como lo hemos explicado anteriormente para la creaci\u00f3n de una clase.</p> <pre><code>    public class Coche {\n\nprivate int puertas;\nprivate int ruedas;\nprivate String modelo;\nprivate String color;\n\n}\n</code></pre> <p>Estamos definiendo el estado del coche, es decir, sus caracter\u00edsticas.</p>"},{"location":"ud3/1metodoclase/#modificadores-de-acceso-de-atributos","title":"Modificadores de acceso de atributos","text":"<p>Un buen dise\u00f1o de software refuerza la encapsulaci\u00f3n. Aqu\u00ed es donde las variables de instancia de un objeto son visibles solo para los propios m\u00e9todos del objeto. El c\u00f3digo fuera del objeto no puede acceder directamente a estas variables. Se utiliza para hacer esto el modificador de visibilidad privada. Como regla general, cuando definimos campos para la clase el modificador de acceso ser\u00e1 privado. Es decir, usamos el concepto de encapsulaci\u00f3n que es una clave fundamental de la programaci\u00f3n orientada a objetos. Lo que hacemos es ocultar los campos de la clase del acceso p\u00fablico para que nadie pueda acceder y modificar los campos de la clase. Significa que la representaci\u00f3n del objeto se ocultar\u00e1 a la vista, es decir, el funcionamiento interno del objeto.</p> <p>Existen los siguientes tipos de modificadores, ordenados de menor a mayor restricci\u00f3n:</p> <ul> <li>public: son accesibles desde cualquier lugar. </li> <li>protected: son accesibles desde dentro del mismo paquete y en clases heredadas.</li> <li>sin modificador: son accesibles desde la propia clase y clases dentro del mismo paquete.</li> <li>private: solo son accesibles desde la propia clase, no son accesibles desde fuera.</li> </ul> <p></p> <pre><code>    //modificador p\u00fablico\npublic int speed;\n\n//modificador protegido\nprotected int speed;\n\n//sin modificador\nint speed;\n\n//modificador privado\nprivate int speed;\n</code></pre>"},{"location":"ud3/1metodoclase/#consejos-para-elegir-un-nivel-de-acceso","title":"Consejos para elegir un nivel de acceso","text":"<ul> <li>Utiliza el nivel de acceso m\u00e1s restrictivo que tenga sentido para un miembro en particular. Usa private a menos que tengas una buena raz\u00f3n para no hacerlo.</li> <li>Evita los campos p\u00fablicos a excepci\u00f3n de las constantes.</li> </ul>"},{"location":"ud3/1metodoclase/#metodos-de-instancia","title":"M\u00e9todos de instancia","text":"<p>Para actualizar los campos de la clase, como su acceso es privado se utilizan los m\u00e9todos de instancia. Estos m\u00e9todos ya no van a ser public static como hemos visto hasta ahora. Para crear los m\u00e9todos que actualizan los campos debemos usar la siguiente nomenclatura:</p> <ul> <li> <p>Setters: establecen el valor en el campo de la clase</p> <p>public void setNombreCampo(TipoDatoCampo nombreCampo), donde el par\u00e1metro del m\u00e9todo debe ser del mismo tipo ya que vamos a actualizar su valor mediante el m\u00e9todo.</p> </li> <li> <p>Getters: devuelven el campo de la clase</p> <p>public tipoDatoCampo getNombreCampo()</p> </li> </ul> <pre><code>    public class Coche {\n\nprivate int puertas;\nprivate int ruedas;\nprivate String modelo;\nprivate String color;\n\npublic void setPuertas(int puertas) {\nthis.puertas = puertas;\n}\n\npublic int getPuertas() {\nreturn this.puertas;\n}\n\npublic void setRuedas() {\nthis.ruedas = ruedas;\n}\n\npublic int getRuedas() {\nreturn this.ruedas;\n}\n\npublic void setModelo(String modelo) {\nthis.modelo = modelo;\n}\n\npublic String getModelo() {\nreturn this.modelo;\n}\n\npublic void setColor(String color) {\nthis.color = color;\n}\n\npublic String getColor() {\nreturn this.color;\n}\n\n}\n</code></pre>"},{"location":"ud3/1metodoclase/#palabra-reservada-this","title":"Palabra reservada this","text":"<p>En un m\u00e9todo set como el nombre del par\u00e1metro del m\u00e9todo es igual al del campo de la clase, necesitamos algo que nos permita distinguir entre uno u otro. Para esto se utiliza la palabra reservada this que hace alusi\u00f3n al campo de la clase.</p>"},{"location":"ud3/1metodoclase/#clase-object-en-java","title":"Clase Object en java","text":"<p>Es necesario conocer a grandes rasgos la clase <code>Object</code>. Tambi\u00e9n es llamada como clase c\u00f3smica, ya que la clase <code>Object</code>, es la clase que est\u00e1 por encima de todas las clases de la api de java.</p> <p>Esto quiere decir que todas las clases de java que vienen predefinidas en el lenguaje de programaci\u00f3n, como las que nosotros construimos, heredan de la clase <code>object</code>.</p> <p>Por eso cuando creamos un objeto, viene ya definido con ciertos m\u00e9todos que se han heredado de la clase <code>Object</code>.</p>"},{"location":"ud3/2constructor/","title":"\ud83c\udf0e Creaci\u00f3n e inicializaci\u00f3n de objetos de la clase","text":"<p>Para crear objetos de la clase, podemos hacerlo de dos formas:</p> <ul> <li>Creando un variable de la clase como hemos hecho hasta ahora:</li> </ul> <pre><code>Coche seat; //(Aqu\u00ed la variable no est\u00e1 inicializada y\n// puede dar errores de compilaci\u00f3n).\n</code></pre> <ul> <li>Utilizando la palabra resevada new m\u00e1s el nombre de la clase:</li> </ul> <pre><code>Coche seat = new Coche(); //En este caso la variable es creada e inicializada\n</code></pre>"},{"location":"ud3/2constructor/#constructor","title":"Constructor","text":"<p>Cuando usamos la palabra new Coche(); para crear un objeto de la clase Coche, en realidad estamos usando lo que se conoce como el constructor de la clase para crear el coche. El constructor por normal general da valor a los campos de la clase.</p>"},{"location":"ud3/2constructor/#constructor-por-defecto","title":"Constructor por defecto","text":"<p>En Java cuando creamos un objeto con la sentencia new Coche(), se lanza el llamado contructor por defecto. Si no se ha definido este en la clase, Java lo crea y lo lanza autom\u00e1ticamente e iniciliza los campos de la clase con valores por defecto.</p> <p>Si queremos definirlo nosotros tenemos que usar public m\u00e1s el nombre de la clase.</p> <pre><code>public class Coche {\n\nprivate int puertas;\nprivate String modelo;\nprivate String color;\n\n//Constructor por defecto\npublic Coche() {\n\n}\n\n//getters y setters\n}\n</code></pre>"},{"location":"ud3/2constructor/#constructor-parametrizado","title":"Constructor parametrizado","text":"<p>Un constructor parametrizado tiene uno o m\u00e1s par\u00e1metros. Podemos usar un constructor parametrizado en caso de que necesitemos pasar algunos valores iniciales a la variable miembro de la clase.</p> <pre><code>public Coche(int puertas, String color) {\nthis.puertas = puertas;\nthis.color = color;\n}\n</code></pre>"},{"location":"ud3/2constructor/#constructor-sobrecargado","title":"Constructor sobrecargado","text":"<p>Ahora surge la pregunta de si una clase puede tener m\u00e1s de un constructor o si una clase solo puede tener un constructor. Podemos tener varios constructores en una clase. Los constructores pueden ser sobrecargados al igual que los m\u00e9todos, es decir, podemos tener m\u00e1s de un constructor en nuestra clase siempre que cambiemos el n\u00famero de par\u00e1metros. Por ejemplo:</p> <pre><code>public Coche(String modelo) {\nthis.modelo = modelo;\n}\n\npublic Coche(int puertas, String color) {\nthis.puertas = puertas;\nthis.color = color;\n}\n\npublic Coche(int puertas, String modelo, String color) {\nthis.puertas = puertas;\nthis.color = color;\nthis.modelo = modelo;\n}\n</code></pre> <p>Estos ser\u00edan dos constructores diferentes para el objeto Coche, donde en uno se construye usando el modelo y en el otro el n\u00famero de puertas.</p> <p>A estos constructores tambi\u00e9n se les conoce como constructor parametrizado.</p> <p>Warning</p> <p>Si se define un constructor con par\u00e1metros en la clase, Java entiende que la clase tiene una forma de construirse y no crear\u00e1 de forma autom\u00e1tica el constructor por defecto Coche(). Por tanto si tenemos c\u00f3digo como Coche coche = new Coche(); nos lanzar\u00e1 un error de compilaci\u00f3n.</p>"},{"location":"ud3/2constructor/#llamar-a-un-constructor-desde-otro-dentro-de-la-misma-clase","title":"Llamar a un constructor desde otro dentro de la misma clase","text":"<p>Hemos comentado que podemos tener m\u00e1s de un constructor en nuestra clase gracias a la sobrecarga. En corcondancia con esto, tambi\u00e9n podemos llamar a un constructor desde otro constructor.</p> <p>Por ejemplo, el constructor por defecto es llamado cuando hacemos new Coche(); pero dentro de este constructor no se inicializa ning\u00fan campo, y tal vez nosotros queramos crear el objeto con algunos valores predeterminados. Entonces llamar\u00edamos desde dentro del constructor por defecto a un constructor parametrizado.</p> <pre><code>public Coche() {\nthis(5, \"blanco\");//invoco al constructor con 2 par\u00e1metros\n}\n\npublic Coche(int puertas, String color) {\nthis(puertas, \"desconocido\", color);//invoco al constructor con 3 par\u00e1metros\n}\n\npublic Coche(int puertas, String modelo, String color) {\nthis.puertas = puertas;\nthis.color = color;\nthis.modelo = modelo;\n}\n</code></pre> <p>En el c\u00f3digo anterior, cada vez que creamos un coche vac\u00edo, le asignamos por defecto 5 puertas y color blanco como valores predeterminados.</p> <p>Con esto te aseguras que el objeto se crea con todos los campos inicializados.</p>"},{"location":"ud3/2constructor/#constructor-copia-en-java","title":"Constructor copia en Java","text":"<p>Cuando igualamos dos objetos, no estamos haciendo una copia del objeto, lo que hacemos es apuntar a ese mismo objeto en memoria. En el siguiente ejemplo tenemos dos variables <code>book</code> y <code>book2</code> apuntando al mismo objeto en memoria, es decir, cualquier cambio que realice alguna de las variables, afectar\u00e1 al objeto en s\u00ed apuntado por las mismas.</p> <pre><code>    Book book = new Book(\"1234ASICK\", \"War and Fire\", \"David Haig\");\nBook book2 = book;\nbook2.setIsbn(\"9000ISBN234\");\nSystem.out.println(book.getIsbn());//imprimir\u00e1 9000ISBN234\n</code></pre> Variables <code>book</code> y <code>book2</code> apuntando a un mismo objeto Modificaci\u00f3n del isbn por la variable <code>book2</code>, pero <code>book</code> tambi\u00e9n se ve reflejada <p>Si queremos realizar una copia de un objeto, es decir, traspasar los valores que tiene a un nuevo objeto, necesitamos invocar al constructor copia.</p> <p>El constructor copia es un tipo de constructor que recibe como par\u00e1metro un objeto de la misma clase. Es decir, en este caso estamos creando objetos de tipo coche, por lo que el constructor recibir\u00e1 por par\u00e1metro un objeto de este tipo. Veamos entonces un ejemplo donde se muestra este tipo de constructor:</p> <pre><code>public class Coche {\n\nprivate int puertas;\nprivate String modelo;\nprivate String color;\n\n//Constructor copia\npublic Coche(Coche objCoche) {\nthis.puertas = objCoche.puertas;\nthis.color = objCoche.color;\nthis.modelo = objCoche.modelo;\n}\n\n}\n</code></pre>"},{"location":"ud3/2constructor/#destructor","title":"Destructor","text":"<p>En algunos lenguajes de programaci\u00f3n, para destruir un objeto, existen varios m\u00e9todos o funciones que se ejecutan de forma autom\u00e1tica para destruirlo. Esta funci\u00f3n no devuelve ning\u00fan valor, (por lo tanto es de tipo void), y no recibe ning\u00fan par\u00e1metro.</p> <p>Por otro lado, es importante destacar que en java no existen destructores. Java es un lenguaje que posee un recolector de basura (garbage collector). Este recolector de basura, ejecuta autom\u00e1ticamente un m\u00e9todo llamado finalize(). Por lo tanto, cuando un programa java ya no est\u00e1 utilizando un objeto se realizan dos acciones:</p> <ul> <li>Por un lado entra en acci\u00f3n de forma autom\u00e1tica el garbage collector.</li> <li>Este recolector de basura llama al m\u00e9todo finalize() y lo ejecuta.</li> <li>Para finalizar, se destruye el objeto y se liberan los recursos utilizados en la memoria RAM del ordenador.</li> </ul>"},{"location":"ud3/3sobrecargametodos/","title":"\ud83c\udf0e M\u00e9todos y sobrecarga de m\u00e9todos","text":"<p>En el punto 2.6 del curso vimos una introducci\u00f3n a los m\u00e9todos, qu\u00e9 son, c\u00f3mo definirlos y sus partes. En los siguientes puntos vamos estudiar conceptos relacionados con los m\u00e9todos.</p>"},{"location":"ud3/3sobrecargametodos/#sobrecarga-de-metodos","title":"Sobrecarga de m\u00e9todos","text":"<p>La sobrecarga de m\u00e9todos es una caracter\u00edstica que nos permite tener m\u00e1s de un m\u00e9todo con el mismo nombre, siempre que usemos diferentes par\u00e1metros. Es la capacidad de crear m\u00faltiples m\u00e9todos con el mismo nombre pero diferentes implementaciones</p> <p>Esto tambi\u00e9n se aplica a los constructores como ya hemos visto, ten\u00edamos m\u00e1s de un constructor con el mismo nombre pero diferente n\u00famero de argumentos.</p> <p></p> <p>No hay l\u00edmite en la cantidad de sobrecarga que se puede hacer al dise\u00f1ar constructores y m\u00e9todos, la \u00fanica restricci\u00f3n es que cada m\u00e9todo debe tener una signature distinta con el mismo nombre.</p> <p>La signature(firma) de un m\u00e9todo consta del nombre del m\u00e9todo, m\u00e1s el n\u00famero, los tipos y el orden de sus par\u00e1metros formales. Una clase no puede contener dos m\u00e9todos con la misma signature.</p> <p></p>"},{"location":"ud3/3sobrecargametodos/#ambito-de-variables-locales-y-argumentos","title":"\u00c1mbito de variables locales y argumentos","text":"<p>El estado de un objeto consta de los datos que contiene en sus variables de instancia(campos o atributos). Las variables de instancia mantienen sus valores hasta que se cambian expl\u00edcitamente o hasta que se destruye el objeto.</p> <p>Los m\u00e9todos de un objeto suelen trabajar con otros valores que no se mantienen en las variables de instancia. Estos valores se mantienen en variables y par\u00e1metros locales.</p> <p>En el ejemplo de la clase Cuenta.java ten\u00edamos:</p> <pre><code>public class Cuenta {\n\nprivate double balance;\n...\n\npublic void ingresar(double cantidad) {\nthis.balance = this.balance + cantidad;\nSystem.out.println(\"Balance actual \" + this.balance);\n}\n}\n</code></pre> <p>La persona que llama al m\u00e9todo ingresar utiliza el par\u00e1metro cantidad para enviar un valor al m\u00e9todo. A esto se le llama pasar un valor al m\u00e9todo.</p> <p>Desde el m\u00e9todo main() llamamos al m\u00e9todo ingresar que usa el par\u00e1metro para pasar un valor al m\u00e9todo:</p> <pre><code>public static void main( String[] args ) {\nCuenta patriCuenta = new Cuenta(\"1234567\", 0.0, \"Patricia\");\nc.ingresar(50);\n}\n</code></pre> <p>Cuando se ejecuta al m\u00e9todo ingresar(50), al par\u00e1metro cantidad se le da el valor 50, luego se ejecuta el interior del m\u00e9todo, y el valor se suma a la variable de instancia o campo balance. El m\u00e9todo termina y el control vuelve al m\u00e9todo main(), pero el balance del objeto patriCuenta ha cambiado.</p> <p>Las variables de instancia se utilizan para almacenar el estado de un objeto. Mantienen los valores mientras exista el objeto.</p> <p>Si intent\u00e1ramos usar la variable cantidad en otro m\u00e9todo, nos dar\u00eda error de compilaci\u00f3n, puesto que esa variable no existe fuera del m\u00e9todo ingresar, es lo que se conoce como una variable local.</p> <p></p> <p>Podr\u00edamos tener otro m\u00e9todo que definiera o usara otra variable llamada cantidad.</p> <pre><code>public class Cuenta {\n\nprivate double balance;\n...\n\npublic void ingresar(double cantidad) {\nthis.balance = this.balance + cantidad;\nSystem.out.println(\"Balance actual \" + this.balance);\n}\n\npublic void retirar(double cantidad) {\nthis.balance = this.balance - cantidad;\n}\n}\n</code></pre> <p>En el m\u00e9todo retirar la variable cantidad es una variable diferente a la que usamos en el m\u00e9todo ingresar, aunque tengan el mismo nombre ya que est\u00e1n en \u00e1mbitos diferentes, no pueden verse entre ellas.</p>"},{"location":"ud3/4referencevalue/","title":"\ud83c\udf0e Paso de argumentos por valor y referencia","text":""},{"location":"ud3/4referencevalue/#argumentos-paso-por-valor","title":"Argumentos paso por valor","text":"<p>Un par\u00e1metro es un \"mensaje unidireccional\" que la persona que llama usa para enviar valores a un m\u00e9todo.</p> <p>Dentro del cuerpo de un m\u00e9todo, un par\u00e1metro se usa como cualquier variable. Se puede utilizar en expresiones aritm\u00e9ticas, en sentencias de asignaci\u00f3n, etc.</p> <p>Sin embargo, los cambios realizados en el par\u00e1metro no tienen ning\u00fan efecto fuera del cuerpo del m\u00e9todo. Un par\u00e1metro es una copia local de cualquier valor que la persona que llama haya pasado al m\u00e9todo. Cualquier cambio realizado afectar\u00e1 solo a esta copia local.</p> <p>Esto ocurre cuando se pasa una dato de tipo primitivo.</p> <p>Por ejemplo:</p> <pre><code>------Clase Cuenta\npublic void cambiarCantidad(double cantidad) {\ncantidad -= 20;\n}\n------------------Clase Main\npublic static void main() {\nCuenta cuenta = new Cuenta(\"Pepe\", \"pepe@gmail.com\", \"873463774\");\nint cantidad = 50;\n\ncuenta.ingresar(cantidad);\nSystem.out.println(cantidad);//imprime 50\ncuenta.cambiarCantidad(cantidad);\nSystem.out.println(cantidad);//imprime 50\n}\n</code></pre> <p>cantidad es el nombre de la variable para el valor 50 que se ha enviado al m\u00e9todo cambiarCantidad(). Ese m\u00e9todo cambia el valor de la cantidad, pero esto no tiene ning\u00fan efecto sobre ninguna otra variable fuera del m\u00e9todo.</p> <p>Cuando el m\u00e9todo regresa a su llamador (main), el valor del par\u00e1metro cantidad se olvida.</p> <p>Una variable local es una variable que se declara dentro del cuerpo de un m\u00e9todo.</p> <p>El alcance de una variable local comienza desde donde se declara y termina al final del bloque en el que se encuentra. Recuerde que un bloque es un grupo de declaraciones entre llaves, {}.</p> <p>As\u00ed es como funciona el paso de par\u00e1metros por valor:</p> <ol> <li>Cuando la persona invoca un m\u00e9todo, es persona proporciona una lista de valores (los par\u00e1metros) en la lista de par\u00e1metros del m\u00e9todo.</li> <li>Cuando el m\u00e9todo invocado comienza a ejecutarse, estos valores se copian en los par\u00e1metros formales o argumentos.</li> <li>El m\u00e9todo invocado utiliza los par\u00e1metros formales para acceder a estos valores copiados.</li> <li>Cualquier cambio que realice el m\u00e9todo en el valor contenido en un par\u00e1metro formal cambia solo esa copia.</li> <li>El m\u00e9todo invocado no puede utilizar un par\u00e1metro formal para enviar un valor a la persona que ha invocado el m\u00e9todo.</li> </ol> <p>Como hemos visto un cambio en un par\u00e1metro dentro del m\u00e9todo no afecta a ninguna variable desde donde se invoc\u00f3. Entonces, \u00bfc\u00f3mo puede un m\u00e9todo enviar un valor a la persona que lo invoca?</p> <p>Para devolver un valor \u00fanico a la persona que invoca, un m\u00e9todo invocado puede utilizar la declaraci\u00f3n de retorno return junto con el valor que se devolver\u00e1.</p>"},{"location":"ud3/4referencevalue/#paso-por-referencia","title":"Paso por referencia","text":"<p>Las referencias a objetos o variable de referencia pueden ser par\u00e1metros. Esto sigue siendo una llamada por valor, pero ahora el valor es una referencia de objeto. Esta referencia se puede utilizar para acceder al objeto y posiblemente cambiarlo.</p> <pre><code>public class Test {\n\npublic static void ingresarCienEuros(Cuenta cuenta) {\nSystem.out.println(\"El balance es \" + cuenta.getBalance());\ncuenta.ingresar(100);\nSystem.out.println(\"El balance es \" + cuenta.getBalance());\n}\n\npublic static void main(String[] args) {\nCuenta c = new Cuenta();\nSystem.out.println(\"El balance es \" + cuenta.getBalance());\ningresarCienEuros(c);\nSystem.out.println(\"El balance es \" + cuenta.getBalance());\n}\n}\n</code></pre> <p>Las variables de instancia p\u00fablica de los objetos se pueden cambiar mediante cualquier m\u00e9todo que tenga una referencia al objeto. Como se ha hecho en el ejemplo anterior en la variable de instancia balance.</p>"},{"location":"ud3/4referencevalue/#resumen","title":"Resumen","text":"<p>Un par\u00e1metro formal es una variable en una declaraci\u00f3n de m\u00e9todo. Siempre consta de un tipo seguido de un identificador de variable. Un argumento es un valor que se pasa a un m\u00e9todo a trav\u00e9s de un par\u00e1metro formal cuando se invoca el m\u00e9todo. Los par\u00e1metros de un m\u00e9todo limitan el tipo de informaci\u00f3n que se puede pasar a un m\u00e9todo.</p> <ol> <li> <p>El paso de par\u00e1metros siempre se realiza por valor.</p> </li> <li> <p>Si el par\u00e1metro de un m\u00e9todo es un tipo de datos primitivo, el m\u00e9todo puede cambiar el valor contenido en su par\u00e1metro, pero ese cambio no tiene ning\u00fan efecto en otros lugares.</p> </li> <li> <p>Sin embargo, si el par\u00e1metro de un m\u00e9todo es una referencia a un objeto, el m\u00e9todo puede usar la referencia para acceder al objeto y luego cambiar las variables de instancia del objeto (a menos que sean privadas o en un paquete diferente).</p> </li> <li> <p>Por supuesto, incluso si un m\u00e9todo tiene una referencia a un objeto, el objeto se puede cambiar solo si el objeto permite que se realicen cambios.</p> </li> </ol>"},{"location":"ud3/5static/","title":"\ud83c\udf0e Variables, m\u00e9todos y clases est\u00e1ticas","text":"<p>Una clase, m\u00e9todo o campo declarado como est\u00e1tico puede ser accedido o invocado sin la necesidad de tener que instanciar un objeto de la clase.</p> <p>Para entender mejor que son las variables y m\u00e9todos est\u00e1ticos vamos a ver las diferencias de cada uno de ellos con variables y m\u00e9todos de instancia.</p>"},{"location":"ud3/5static/#variables-estaticas","title":"Variables est\u00e1ticas","text":"<p>Si una variable se declara est\u00e1tica, hay exactamente una copia de esa variable creada sin importar cu\u00e1ntas veces se instancia su clase.</p> <ul> <li>Se declaran usando la palabra reservada static.</li> <li>Cada instancia de la clase comparte la misma variable est\u00e1tica, por lo que si se realizan cambios en esa variable est\u00e1tica todas las dem\u00e1s instancias de esa clase ver\u00e1 el efecto de ese cambio.</li> <li>No se usan muy amenudo.</li> </ul> <pre><code>class Persona {\nprivate static String name;\n\npublic Persona(String name) {\nPersona.name = name;\n}\n\npublic void printName() {\nSystem.out.println(name);\n}\n}\n\npublic class Main {\npublic static void main(String[] args) {\nPersona p1 = new Persona(\"Patricia\");\nPersona p2 = new Persona(\"Maxi\");\np1.printName();//imprime Maxi\np2.printName();//imprime Maxi\n}\n}\n</code></pre>"},{"location":"ud3/5static/#variables-constantes-estaticas","title":"Variables constantes est\u00e1ticas","text":"<p>Tambi\u00e9n se puede declarar un variable constante (final) como est\u00e1tica, esto significa que solo habr\u00e1 una copia de la constante aunque hayan muchas instancias de esa clase. Son tambi\u00e9n llamadas constantes de clase:</p> <pre><code>private static final int NUMERO_JUGADORES = 2;\n</code></pre> <p>No todas las constantes son constantes de clase. Es decir, no todas las constantes se declaran est\u00e1ticas. Sin embargo, la idea de asociar constantes con una clase tiene sentido. Ya que te permite ahorrar recursos de memoria, al crear una \u00fanica copia de la constante.</p> <p>Otra ventaja de las constantes de clase es que se pueden usar antes de que existan instancias de la clase. Por ejemplo, una constante de clase (a diferencia de una constante de instancia) se puede usar durante la instanciaci\u00f3n de objetos:</p> <pre><code>public class Game {\n\npublic static final int MULTIPLAYER = 2;\npublic static final int ONE_PLAYER = 1;\n\nprivate int numeroJugadores;\n\npublic Game(int jugadores) {\nthis.numeroJugadores = jugadores;\n}\n\npublic static void main(String[] args) {\nGame game = new Game(Game.MULTIPLAYER);\n}\n}\n</code></pre>"},{"location":"ud3/5static/#variables-de-instancia","title":"Variables de instancia","text":"<ul> <li>Las variables de instancia tambi\u00e9n son conocidas como campos o atributos.</li> <li>Las variables de instancia pertenecen a una instancia de la clase.</li> <li>Cada instancia tiene su propia copia de una variable de instancia, as\u00ed que cada instancia puede tener un valor(estado) diferente.</li> <li>Las variables de instancia representan el estado de una instancia.</li> </ul> <pre><code>class Persona {\nprivate String name;\n\npublic Persona(String name) {\nthis.name = name;\n}\n\npublic void printName() {\nSystem.out.println(name);\n}\n}\n\npublic class Main {\npublic static void main(String[] args) {\nPersona p1 = new Persona(\"Patricia\");\nPersona p2 = new Persona(\"Maxi\");\np1.printName();//imprime Patricia\np2.printName();//imprime Maxi\n}\n}\n</code></pre>"},{"location":"ud3/5static/#metodos-estaticos","title":"M\u00e9todos est\u00e1ticos","text":"<ul> <li>Los m\u00e9todos est\u00e1ticos son declarados usando el modificador static.</li> <li>No se puede acceder desde los m\u00e9todos est\u00e1ticos a m\u00e9todos de instancia o variables de instancia directamente.</li> <li>Para invocar a un m\u00e9todo est\u00e1tico se utiliza el nombre de la clase + \".\" + el nombre del m\u00e9todo, o solamente el nombre del m\u00e9todo si est\u00e1 en la misma clase.(VEASE EJEMPLO)</li> <li>Normalmente se usan para operaciones que no requieren ning\u00fan dato de instancia de la clase, es decir, nada que venga de this.</li> <li>Dentro de un m\u00e9todo est\u00e1tico no podemos usar la palabra this.</li> <li>Cada vez que veas un m\u00e9todo que no utilice variables de instancia, significa que ese m\u00e9todo deber\u00eda declararse como est\u00e1tico.</li> <li>Por ejemplo, el main es declarado como est\u00e1tico y es llamado por la JVM cuando se lanza la aplicaci\u00f3n.</li> </ul> <pre><code>public class Calculadora {\npublic static void printSuma(int a, int b) {\nSystem.out.println(a+b);\n}\n}\n\npublic class Main {\npublic static void main(String[] args) {\nCalculadora.printSuma(5, 6);\nprintHolaMundo();\n}\n\npublic static void printHolaMundo() {\nSystem.out.println(\"Hola mundo.\");\n}\n}\n</code></pre>"},{"location":"ud3/5static/#metodos-de-instancia","title":"M\u00e9todos de instancia","text":"<ul> <li>Los m\u00e9todos de instancia pertenecen a una instancia espec\u00edfica de la clase.</li> <li>Para usar un m\u00e9todo de instancia tenemos que instanciar un objeto de la clase primero, normalmente utilizando la palabra resevada new.</li> <li>Los m\u00e9todos de instancia pueden acceder a otros m\u00e9todos de instancia y variables de instancia directamente.</li> <li>Los m\u00e9todos de instancia pueden tambi\u00e9n acceder a m\u00e9todos est\u00e1ticos y variables est\u00e1ticas.</li> </ul>"},{"location":"ud3/5static/#metodo-estatico-o-metodo-de-instancia","title":"\u00bfM\u00e9todo est\u00e1tico o m\u00e9todo de instancia?","text":"<p>Cuando voy a crear un m\u00e9todo y tengo dudas sobre si crearlo est\u00e1tico o de instancia debo seguir la siguiente l\u00f3gica:</p> <p>\u00bfEl m\u00e9todo usa alg\u00fan campo o variable de instancia o invoca en su interior a alg\u00fan m\u00e9todo de instancia?</p> <ul> <li>SI --&gt; Entonces deber\u00eda crear un m\u00e9todo de instancia.</li> <li>NO --&gt; Deber\u00eda crear un m\u00e9todo est\u00e1tico.</li> </ul>"},{"location":"ud3/5static/#clases-estaticas","title":"Clases est\u00e1ticas","text":"<p>En el lenguaje Java, no podemos crear una clase externa como una clase est\u00e1tica, pero existe el privilegio de crear una clase interna anidada como una clase est\u00e1tica.</p> <ul> <li>Una clase interna est\u00e1tica nunca puede acceder a un miembro no est\u00e1tico de la clase externa.</li> <li>Una clase interna est\u00e1tica no necesita ninguna referencia de clase externa para acceder a las variables miembro.</li> <li>La clase est\u00e1tica nunca se puede instanciar. Por lo tanto, los m\u00e9todos son directamente accesibles por el nombre de la clase.</li> </ul> <pre><code>public class Estatica {\nstatic int i = 1;\nint j = 9;\n\npublic static void main(String[] args) {\nEstatica s = new Estatica();\n//s.ClaseInterna.printNum(); NO ES CORRECTO\n//Estatica.ClaseInterna.printNum(); SI se podr\u00eda hacer\nClaseInterna.printNum();\n}\n\npublic static class ClaseInterna {\npublic static void printNum() {\nSystem.out.println(i);\n//System.out.println(j); //NO PODEMOS ACCEDER A ATRIBUTOS NO EST\u00c1TICOS\n}\n}\n}\n</code></pre>"},{"location":"ud3/5static/#bloques-estaticos","title":"Bloques est\u00e1ticos","text":"<p>Es posible declarar bloques de c\u00f3digo como est\u00e1ticos, de tal manera que sean ejecutados cuando se cargue la clase. Este tipo de bloques se conocen como bloques de inicializaci\u00f3n est\u00e1ticos (static initializer block). Si no se declara un bloque de este tipo de forma expl\u00edcita, el compilador Just-in-Time combina todos los campos est\u00e1ticos en un bloque y los ejecuta durante la carga de clases.</p> <pre><code>public class Objeto {\n\nprivate static int campo1;\n\nstatic {\ncampo1 = 10;\n}\n}\n</code></pre>"},{"location":"ud3/5static/#imports-estaticos","title":"Imports est\u00e1ticos","text":"<p>Una de las caracter\u00edsticas incluidas en Java 5 fu\u00e9 la capacidad de importar los m\u00e9todos y variables est\u00e1ticas de un m\u00f3dulo y acceder a ellos como si hubieran sido declarados en la propia clase. Es especialmente \u00fatil, y mejora la legibilidad, cuando se est\u00e1n definiendo test unitarios, ya que la mayor\u00eda de los m\u00e9todos de aserci\u00f3n de JUnit son est\u00e1ticos.</p> <pre><code>import static java.lang.Math.PI;\n\npublic static void main(String[] args) {\ndouble a = PI;\n}\n</code></pre>"},{"location":"ud3/6recursion/","title":"\u267e\ufe0f Recursividad","text":"<p>Un m\u00e9todo recursivo es un m\u00e9todo que se llama a s\u00ed mismo. Un m\u00e9todo iterativo es un m\u00e9todo que usa un bucle para repetir una acci\u00f3n. En cierto sentido, la recursividad es una alternativa a las estructuras de control iterativas (en bucle).</p> <p>Por ejemplo, tenemos el siguiente m\u00e9todo iterativo:</p> <pre><code>public void hola(int n) {\nfor (int k = 0; k &lt; n; k++) {\nSystem.out.println(\"Hola\");\n}\n} </code></pre> <p>Una versi\u00f3n recursiva de ese m\u00e9todo ser\u00eda:</p> <pre><code>public void hola(int n) {\nif(n &gt; 0 ) {\nSystem.out.println(\"Hola\");\nhola(n \u2212 1); //Llamada recursiva\n}\n}\n</code></pre> <p>Este m\u00e9todo es recursivo porque se llama a s\u00ed mismo cuando n es mayor que 0. Sin embargo, ten en cuenta que cuando se llama a s\u00ed mismo, pasa n - 1 como el valor de su par\u00e1metro. Si este m\u00e9todo se llama inicialmente con n igual a 5, lo siguiente es una pila de lo que sucede. Las indentaciones indican cada vez que el m\u00e9todo se llama a s\u00ed mismo:</p> <pre><code>hola(5)\n    imprime \"Hola\"\n    hola(4)\n        imprime \"Hola\"\n        hola(3)\n            imprime \"Hola\"\n            hola(2)\n                imprime \"Hola\"\n                hola(1)\n                    imprime \"Hola\"\n                    hola(0)\n</code></pre> <p>En el ejemplo anterior, es mucho menos eficiente llamar a un m\u00e9todo cinco veces que repetir un bucle for cinco veces. Las llamadas a m\u00e9todos ocupan m\u00e1s memoria que los bucles e implican m\u00e1s sobrecarga computacional, en tareas como pasar par\u00e1metros, asignar almacenamiento para las variables locales del m\u00e9todo y devolver los resultados del m\u00e9todo.</p> <p>Note</p> <p>Los algoritmos y m\u00e9todos iterativos son generalmente m\u00e1s eficientes que los algoritmos recursivos que hacen lo mismo.</p>"},{"location":"ud3/6recursion/#recursividad-como-un-enfoque-de-resolucion-de-problemas","title":"Recursividad como un enfoque de resoluci\u00f3n de problemas","text":"<p>Dado que la recursividad no es realmente necesaria, si un lenguaje de programaci\u00f3n tiene bucles, y no es m\u00e1s eficiente que los bucles, \u00bfpor qu\u00e9 es tan importante?</p> <p>Porque la recursividad es un enfoque eficaz para la resoluci\u00f3n de problemas. Es una forma de ver un problema.</p> <p>La recursividad se basa en dos conceptos clave de resoluci\u00f3n de problemas: divide y vencer\u00e1s y auto-similaridad. En la resoluci\u00f3n de problemas recursivos, utilizamos la estrategia de divide y vencer\u00e1s repetidamente para dividir un gran problema en una secuencia de problemas cada vez m\u00e1s peque\u00f1os hasta que llegamos a un problema que es pr\u00e1cticamente trivial de resolver. Lo que nos permite crear esta serie de subproblemas es que cada subproblema es similar al problema original, es decir, cada subproblema es solo una versi\u00f3n m\u00e1s peque\u00f1a del problema original.</p> <p>La capacidad de ver un problema, por uno compuesto por problemas m\u00e1s peque\u00f1os y similares es el n\u00facleo del enfoque recursivo.</p>"},{"location":"ud3/6recursion/#parte-recursiva-y-caso-base","title":"Parte recursiva y caso base","text":"<p>Una definici\u00f3n recursiva consta de dos partes: una parte recursiva que se repite y reduce el problema en una versi\u00f3n m\u00e1s peque\u00f1a del problema original, y un caso base o l\u00edmite no recursivo, que define una condici\u00f3n l\u00edmite y se utiliza para detener la recursividad.</p> <p>Veamos esto con un ejemplo:</p>"},{"location":"ud3/6recursion/#ejemplo-1-factorial-n","title":"EJEMPLO 1: Factorial: N!","text":"<p>Recordamos como se hac\u00eda el c\u00e1lculo de n!:</p> <p>n! = n * (n-1) * n(n-2) * .... mientras n &gt; 0</p> <p>Adem\u00e1s, 0! se define como 1.</p> <p>Ejemplos:</p> <ul> <li>4! = 4 * 3 * 2 * 1 = 24</li> <li>3! = 3 * 2 * 1 = 6</li> <li>1! = 1</li> <li>0! = 1</li> </ul> <p>Como vemos en el ejemplo, podemos deducir que el factorial se repite en t\u00e9rminos de (n-1) y el \u00fanico caso donde no se calcula el factorial es 0!, esto nos lleva a que:</p> <p>n! = 1             --&gt; if n = 0 //caso base</p> <p>n! = n * (n-1)     --&gt; if n &gt; 0 //caso recursivo</p> <p>De forma que el factorial de un n\u00famero quedar\u00eda codificado de la siguiente forma:</p> <pre><code>    public static int factorial(int n) {\nif (n &lt;= 0) {\nreturn 1;\n} else {\nreturn n * factorial(n-1);\n}\n}\n</code></pre>"},{"location":"ud3/6recursion/#traza","title":"Traza","text":"<pre><code>factorial(4)\n    4 * factorial(3)\n        3 * factorial(2)\n            2 * factorial(1)\n                1 * factorial(0)\n                    return 1\n                return 1 * 1 --&gt; 1   \n            return 2 * 1 --&gt; 2\n        return 3 * 2 --&gt; 6 \n    return 4 * 6 --&gt; 24\nreturn 24\n</code></pre>"},{"location":"ud3/6recursion/#ejemplo-2-verificar-si-un-numero-es-palindromo","title":"EJEMPLO 2: Verificar si un n\u00famero es pal\u00edndromo","text":"<p>Un n\u00famero es pal\u00edndromo si al leerse en ambos sentidos, tanto de izquierda a derecha como de derecha a izquierda, se obtiene el mismo n\u00famero. Por ejemplo: 121, 1001, etc.</p> <pre><code>public static int revertir(int n, int reverso) {\nif (n &gt; 0) {\nint ud = n % 10;\nreverso = reverso * 10;\nreturn revertir(n/10, ud+reverso);\n} else {\nreturn reverso;\n}\n}\n\npublic static void main (String[] args) {\nint reverso = revertir(121, 0);\n\nif (reverso == n)\nSystem.out.println(\"Son pal\u00edndromos.\");\nelse\nSystem.out.println(\"No lo son\" );\n}\n</code></pre>"},{"location":"ud3/6recursion/#ejemplo-3-revertir-un-string","title":"EJEMPLO 3: Revertir un String","text":"<p>Para revertir un String, nos quedamos con el primer car\u00e1cter que iremos a\u00f1adiendo al final de la recursividad, y vamos acortando el String para llegar al caso base.</p> <pre><code>public static String reverseRecursive(String str) {\nif (str.isEmpty()) { //caso base\nreturn \"\";\n}\nreturn reverseRecursive(str.substring(1)) + str.charAt(0);\n}\n</code></pre>"},{"location":"ud3/7nullvalue/","title":"\ud83c\udf0e Valor nulo","text":"<p>Una variable de referencia contiene informaci\u00f3n sobre la ubicaci\u00f3n de un objeto. No contiene el objeto en s\u00ed.</p> <p>Por ejemplo el siguiente c\u00f3digo:</p> <pre><code> String str;\nPersona p;\n</code></pre> <p>declara dos variables de referencia pero no construye ning\u00fan objeto. Con el siguiente c\u00f3digo:</p> <pre><code> str = \"Programaci\u00f3n\";\np = new Persona(\"Patricia\");\n</code></pre> <p>se construyen los objetos y se colocan referencias en las variables.</p> <p>null es un valor especial que significa \"sin objeto\". Se establece una variable de referencia a null cuando no se refiere a ning\u00fan objeto. Las variables a menudo se asignan en nulas cuando se declaran:</p> <pre><code> String str = null;\nPersona p = null;\n</code></pre> <p>str y p todav\u00eda no son objetos, son variables que en un futuro pueden referenciar a objetos.</p> <p>Podemos asignar el valor null a cualquier variable de tipo referencia, ya sea un objeto, string, array, etc.</p> <p>Una variable de referencia a veces hace referencia a un objeto y otras veces no, y puede referirse a diferentes objetos en diferentes momentos. Por tanto, necesitamos una forma de decir que una variable ahora no se refiere a un objeto. Para ello, se le asigna un valor null a la variable.</p> <p></p> <p>El objeto Persona con el nombre de Patricia se destruir\u00e1 eventualmente por el garbage collector ya que no es referenciado por nadie.</p>"},{"location":"ud4/1arrays/","title":"Arrays de datos primitivos","text":"<p>Los arrays es una estructura de datos que te permite almacenar una secuencia de valores todos del mismo tipo.</p> <p>Un array est\u00e1 hecho de bloques contiguos de memoria que se divide en varias celdas. Cada celda tiene un valor y todos los valores son del mismo tipo. A veces, las celdas de un array se denominan slots. En el array de la imagen cada celda contiene un int.</p> <p>En el ejemplo de la imagen hemos creado un array de enteros. Tambi\u00e9n se podr\u00eda crear un array de caracteres, de String, etc. Esto se podr\u00eda hacer tanto para tipos de datos primitivos como para objetos.</p> <ul> <li>Las celdas est\u00e1n numeradas secuencialmente empezando por cero.</li> <li>Si hay N celdas en un array, entonces los \u00edndices van del 0 hasta N-1.</li> <li>La longitud de un array es el n\u00famero de celdas.</li> </ul> <p>Al valor almacenado en la celda de un array se le suele llamar elemento.</p> <p>Es muy importante tener en cuenta que los arrays empiezan siempre en la posici\u00f3n cero. Por tanto, si se desea acceder al primer elemento del array, estar\u00e1 almacenado en la posici\u00f3n 0.</p>"},{"location":"ud4/1arrays/#declaracion-y-reseva-de-memoria","title":"Declaraci\u00f3n y reseva de memoria","text":"<p>Para declarar un array, se hace de la misma forma que har\u00edamos si quisi\u00e9ramos declarar una variable pero a\u00f1adiendo [ ]:</p> <pre><code>    int miVariable; //declaramos una variable normal\nint[] miArray; //declaramos una variable array\n</code></pre> <p>Si usamos la declaraci\u00f3n tipo[] arrayName crea una referencia a una variable de tipo de array, pero no construye el objeto.</p> <p>Los arrays en Java se crean como objetos, y como cualquier otro objeto en Java, para construirlo utilizamos la palabra reservada new. Para inicializar un array usaremos la palabra new + tipo de dato + tama\u00f1o del array entre corchetes[]:</p> <pre><code>    int[] miArray = new int[10]; //creamos y reservamos memoria para el array con 10 elementos\n// y valores 0 en cada posici\u00f3n\n\ndouble[] dArray = new double[5];\n</code></pre> <p>Una vez ha sido construido no es posible cambiar su tama\u00f1o. La variable miArray va a ser un array con espacio para 10 elementos de tipo entero.</p>"},{"location":"ud4/1arrays/#acceso-a-los-elementos-del-array","title":"Acceso a los elementos del array","text":"<p>Para guardar un valor dentro de una celda del array tenemos que acceder a su posici\u00f3n dentro del array.</p> <pre><code>    int[] miArray = new int[10];\nmiArray[2] = 5; //guardamos en la posici\u00f3n 2 del array el valor 5\n</code></pre> <p>Warning</p> <p>Recuerda que los elementos del array empiezan con \u00edndice 0, por tanto, en realidad la posici\u00f3n 2 ser\u00eda la 3.</p> <p>Para acceder a un valor de una determinada posici\u00f3n del array y mostrarlo lo har\u00edamos de la siguiente forma:</p> <pre><code>    int elemento = miArray[2]; //almacenamos el valor 5 en la variable entera elemento\nSystem.out.println(elemento);\n\n// o tambi\u00e9n podemos hacer directamente\nSystem.out.println(miArray[2]);\n</code></pre>"},{"location":"ud4/1arrays/#inicializacion-del-array","title":"Inicializaci\u00f3n del array","text":"<p>Hay varias formas de inicializar un array. Por ejemplo, si quisi\u00e9ramos darle valor a todas las posiciones del array podr\u00edamos hacerlo de la forma:</p> <pre><code>    miArray[0] = 2;\nmiArray[1] = 31;\nmiArray[2] = 5;\n....\nmiArray[10] = 4;\n</code></pre> <p>Lo cual es una forma muy pesada y tediosa. Java nos ofrece otras formas de inicializar los arrays en una sola l\u00ednea de c\u00f3digo que solo es aplicable a la vez que definimos la variable:</p> <pre><code>    int[] miArray = {2,31,5,7,12,89,6,11,50,4};//correcto\n\n//no puedo inicializar el array despu\u00e9s de haberlo creado\nmiArray = {2,31,5,7,12,89,6,11,50,4};//eso da ERROR\n</code></pre> <p>De esa forma, tambi\u00e9n le indicamos indirectamente el tama\u00f1o del array. Java cuenta el n\u00famero de elementos que hay entre {} y crea un array de ese tama\u00f1o y adem\u00e1s los asigna en posiciones consecutivas dentro del array.</p> <p>Los \u00edndices en un array son enteros que especifican la posici\u00f3n que ocupa el elemento dentro del array. Por tanto podemos manejar los \u00edndices con variables enteras.</p> <p>Una tercera forma ser\u00eda utilizando la estructura de bucle for, para esto, debemos saber con antelaci\u00f3n el valor de los elementos del array:</p> <pre><code>    int[] miArray = new int[10];\n\nfor(int i = 0; i &lt; 10; i++) {\nmiArray[i] = i * 10;\n}\n</code></pre> <p>Lo que hacemos es inicializar cada posici\u00f3n del array utilizando el bucle. Estamos almacenando dentro del array el valor del \u00edndice multiplicado por 10, de forma que tendremos, {0, 10, 20, ...., 90}.</p> <p>La estructura for tambi\u00e9n es de gran ayuda si queremos imprimir los valores que est\u00e1n guardados en cada posici\u00f3n del array:</p> <pre><code>    for(int i = 0; i &lt; 10; i++) {\nSystem.out.println(\"Elemento \" + i + \" valor \" + miArray[i]);\n}\n</code></pre> <p>A falta de cualquier otra informaci\u00f3n, las celdas de un array se inicializan con el valor predeterminado para su tipo. Cada celda de un array de tipo num\u00e9rico se inicializa a cero.</p> <p>Y cada celda de un array de referencias a objetos se inicializa en nulo (null).</p>"},{"location":"ud4/1arrays/#longitud-del-array","title":"Longitud del array","text":"<p>Una buena pr\u00e1ctica, es utilizar una propiedad integrada dentro de array, en vez de hardcodear literales de tama\u00f1o dentro del bucle. Esta propiedad es length:</p> <pre><code>    for(int i = 0; i &lt; miArray.length; i++) {\nSystem.out.println(\"Elemento \" + i + \" valor \" + miArray[i]);\n}\n</code></pre> <p>Si ahora cambiamos la longitud del array en su definici\u00f3n, no se ver\u00eda afectado ning\u00fan bucle o lugar donde se utilizara miArray.length.</p>"},{"location":"ud4/1arrays/#pasar-un-array-como-argumento-en-un-metodo","title":"Pasar un array como argumento en un m\u00e9todo","text":"<p>Al igual que hac\u00edamos con las variables simples, tambi\u00e9n podemos pasar arrays a los m\u00e9todos.</p> <pre><code>public static void imprimirArray(int[] array) {\nfor(int i = 0; i &lt; array.length; i++) {\nSystem.out.println(\"Elemento \" + i + \" valor \" + array[i]);\n}\n}\n\npublic static void main() {\nint[] miArray = new int[10];\nimprimirArray(miArray);\n}\n</code></pre>"},{"location":"ud4/1arrays/#devolver-un-array-en-un-metodo","title":"Devolver un array en un m\u00e9todo","text":"<p>Para devolver un objeto de tipo array en un m\u00e9todo simplemente a\u00f1adiremos []:</p> <pre><code>public static int[] calcular() {\nint[] miArray = new int[10];\n....//realizo calculos con el array\nreturn miArray;\n}\n</code></pre>"},{"location":"ud4/1arrays/#caso-practico-real-uso-de-un-array","title":"Caso pr\u00e1ctico real uso de un array","text":"<p>Vamos a presentar un ejemplo de un caso real para el que los arrays son muy efectivos. Por ejemplo pedir al usuario que inserte n\u00fameros y mostrar la media de los n\u00fameros insertados.</p> <pre><code>public class MiArray {\n\nprivate static Scanner sc = new Scanner(System.in);\n\npublic static void main(String[] args) {\nint[] enteros = leerEnteros(5);\n\n//imprimimos los valores\nfor (int i = 0; i &lt; enteros.length; i++) {\nSystem.out.println(\"Elemento en posici\u00f3n \" + i + \" valor \" + enteros[i]);\n}\nSystem.out.println(\"La media del array es \" + calcularMedia(enteros));\n}\n\npublic static int[] leerEnteros(int elementos) {\nSystem.out.println(\"Inserta \" + elementos + \" de tipo entero.\");\nint[] array = new int[elementos];\n\nfor (int i = 0; i &lt; array.length; i++) {\narray[i] = sc.nextInt();\n}\n\nreturn array;\n}\n\npublic static double calcularMedia(int[] array) {\nint suma = 0;\nfor (int i = 0; i &lt; array.length; i++) {\nsuma += array[i];\n}\nreturn (double) suma / (double) array.length;\n}\n}\n</code></pre>"},{"location":"ud4/2usefularrays/","title":"Algoritmos de arrays \u00fatiles","text":"<p>Un array que utiliza un solo \u00edndice para acceder a sus valores se denomina array unidimensional, ya que utilizamos el \u00edndice para acceder a todas las celdas del array. \u00c9stas celdas est\u00e1n alineadas de forma secuencial.</p> <p>Un array bidimensional necesita dos \u00edndices para acceder a los valores. En este caso las celdas est\u00e1n dispuestas en forma de matriz, como una estructura rectangular.</p> <p>Es posible crear arrays de mayores dimensiones aunque rara vez se utilizan.</p>"},{"location":"ud4/2usefularrays/#contar-los-elementos-que-contiene-un-array","title":"Contar los elementos que contiene un array","text":"<p>Cuando utilizamos arrays, es muy molesto contar los elementos de un array para saber su tama\u00f1o. Afortunadamente, todo objeto de tipo array tiene una variable de instancia llamada length que contiene el tama\u00f1o del array, es decir, el n\u00famero de celdas.</p>"},{"location":"ud4/2usefularrays/#imprimir-los-elementos-de-un-array","title":"Imprimir los elementos de un array","text":"<p>Un algoritmo muy utilizado cuando trabajamos con arrays es mostrar los valores que contiene el array en cada una de sus celdas. Para ello nos ayudamos del campo length que nos devuelve la longitud del array.</p> <pre><code>public static void imprimirArray(int[] array) {\nfor(int i = 0; i &lt; array.length; i++) {\nSystem.out.println(\"Elemento \" + i + \" valor \" + array[i]);\n}\n}\n</code></pre>"},{"location":"ud4/2usefularrays/#leer-y-rellenar-los-elementos-de-un-array-por-teclado","title":"Leer y rellenar los elementos de un array por teclado","text":"<p>Es muy com\u00fan que los elementos de un array sean valores introducidos de alguna forma por el usuario. El ejemplo m\u00e1s sencillo es leerlos directamente desde la entrada de flujo, a la vez que leemos el valor insertado por el usuario se lo asignamos al array.</p> <pre><code>    int[] array = new int[elementos];\n\nfor (int i = 0; i &lt; array.length; i++) {\narray[i] = sc.nextInt();\n}\n</code></pre>"},{"location":"ud4/2usefularrays/#algoritmo","title":"Algoritmo","text":"<p>Cualquier procedimiento sistem\u00e1tico utilizado para calcular algo se llama algoritmo. Por ejemplo si queremos sumar todos los elementos de un array realizaremos un algoritmo. Un algoritmo es una descripci\u00f3n de c\u00f3mo hacer algo. No est\u00e1 vinculado a ning\u00fan idioma en particular. Un algoritmo se puede implementar en cualquier lenguaje de programaci\u00f3n de computadoras.</p> <p>El programa siguiente muestra un ejemplo de un algoritmo. Aqu\u00ed la variable suma juega el papel de almacenar la suma de los elementos que se van leyendo. El programa recorre elementos del array comenzando en el \u00edndice 0 y yendo hasta el final.</p> <pre><code>    public static int suma(int[] array) {\nint suma = 0;\nfor (int i = 0; i &lt; array.length; i++) {\nsuma += array[i];\n}\nreturn suma;\n}\n</code></pre>"},{"location":"ud4/2usefularrays/#clasico-error-1-no-testear-los-limites-del-array","title":"Cl\u00e1sico error 1: no testear los l\u00edmites del array","text":"<p>Cuando trabajamos con arrays, a menudo nos puede ocurrir que olvidamos el \u00faltimo elemento del array, si cambiamos la condici\u00f3n del bucle por i &lt; array.length -1, o olvidamos el primer elemento si establecemos el \u00edndice en  int i = 1 porque creemos que el primer elemento est\u00e1 en la posici\u00f3n 1 del array.</p> <p>Estos son errores cl\u00e1sicos: no probar los l\u00edmites de los arrays, es decir, el primer elemento o el \u00faltimo.</p> <p>Por ejemplo, en el siguiente c\u00f3digo no quiero tener n\u00fameros de una cifra en mi array.</p> <pre><code>    int[] array =  {2, 19, 1, 5, 1, 27, 9, 5};\n\nfor (int i = 0; i &lt; array.length-1; i++) {\nif (array[i] &lt; 10)\narray[i] = array[i] * 10;\n}\n</code></pre> <p>Cuando recorro el array, el \u00faltimo elemento no ser\u00eda testeado por tanto me devolver\u00eda un 5 en vez de 50. El programa ser\u00eda incorrecto.</p>"},{"location":"ud4/2usefularrays/#clasico-error-2-exceder-los-limites-del-array","title":"Cl\u00e1sico error 2: exceder los l\u00edmites del array","text":"<p>Al contrario que, en el apartado anterior, si intentamos acceder a una celda del array que no existe, se lanzar\u00e1 una ArrayIndexOutOfBoundsException y el programa se detendr\u00e1.</p> <p>Los errores de acceso a la \u00faltima posici\u00f3n del array + 1 son muy comunes. Un ejemplo ser\u00eda:</p> <pre><code>    int[] array =  {2, 19, 1, 5, 1, 27, 9, 5};\n\nfor (int i = 0; i &lt;= array.length; i++) {\nif (array[i] &lt; 10)\narray[i] = array[i] * 10;\n}\n</code></pre>"},{"location":"ud4/2usefularrays/#bucle-foreach-enhanced-for-loop","title":"Bucle foreach (enhanced for loop)","text":"<p>Para evitar que los errores mencionados anteriormente ocurran, Java dispone de un bucle mejorado que visita cada elemento del array en orden sin necesidad de establecer un \u00edndice. Por tanto, los errores de exceder los l\u00edmites del array se eliminan autom\u00e1ticamente con este bucle.</p> <p>La sintaxis es la siguiente:</p> <p></p> <p>Este bucle de lee en voz alta de la siguiente manera: \"para cada valor del array...\" (for each value in array...)</p> <p>El tipo de dato de la variable que se crea en el bucle es igual al de cada una de las celdas del array, y va a contener los valores de ellas. En la primera iteraci\u00f3n contrendr\u00e1 el valor de la primera celda del array, y as\u00ed sucesivamente hasta llegar a la \u00faltima celda del array.</p> <p>Ejemplo:</p> <pre><code>    int[] array =  {2, 19, 1, 5, 1, 27, 9, 5};\nint suma = 0;\nfor (int numero : array) {\nsuma += numero;\n}\n</code></pre>"},{"location":"ud4/2usefularrays/#comparar-si-dos-arrays-son-iguales","title":"Comparar si dos arrays son iguales","text":"<p>Es muy usual utilizar el operador \"==\" cuando queremos comparar si dos arrays son iguales, es decir, si contienen los mismos elementos. Pero si ejecutamos el siguiente c\u00f3digo:</p> <pre><code>    int[] array1 =  {1, 2, 3};\nint[] array2 =  {1, 2, 3};\n\nSystem.out.println(array1 == array2); //imprime false\n</code></pre> <p>Obtenemos false, esta situaci\u00f3n es parecida a cuando intent\u00e1bamos comparar dos String. Recordar que utilizar el operador \"==\" era incorrecto ya que son objetos diferentes aunque tuvieran el mismo contenido.</p> <p>Si utilizamos el m\u00e9todo equals() para arrays, devolver\u00eda el mismo valor booleano que el operador \"==\".</p> <pre><code>    System.out.println(array1.equals(array2)); //imprime false\n</code></pre> <p>Para comprobar que dos arrays contienen los mismos elementos se utiliza la clase Arrays.</p> <p>La clase Arrays contiene muchos m\u00e9todos est\u00e1ticos para manipular matrices. Dado que los m\u00e9todos son est\u00e1ticos, los invoca utilizando el nombre de la clase.</p> <pre><code>    int[] array1 =  {1, 2, 3};\nint[] array2 =  {1, 2, 3};\n\nSystem.out.println(Arrays.equals(array1, array2)); //imprime true\n</code></pre> <p>El m\u00e9todo Arrays.equals comprueba que dos arrays son iguales si tienen la misma longitud y contienen los mismos elementos en el mismo orden.</p>"},{"location":"ud4/3referencetypearrays/","title":"Tipos de referencia vs tipos de valor","text":"<p>Sabemos que los tipos de datos primitivos como int, double, etc. son tipos de datos primitivos, es decir, son tipos de valor ya que almacenan valores.</p> <p>A diferencia de \u00e9stos, los arrays son tipos de referencia como tambi\u00e9n los son los String.</p> <p>Cuando creamos una variable de tipo valor, se asigna un solo espacio en la memoria para almacenar su valor y esa variable contiene directamente el valor.</p> <p>Si creamos otra variable y le asignamos esa variable como se ve en el siguiente c\u00f3digo:</p> <pre><code>    int variable = 2;\nint otraVariable = variable;//asignamos un 2 a otraVariable\n\notraVariable = 5;\n\nSystem.out.println(variable);//imprime 2\nSystem.out.println(otraVariable);//imprime 5\n</code></pre> <p>El valor es copiado directamente y ambas variables trabajan independientemente. Cada una tiene su propia copia del valor espec\u00edfico, en este caso 2.</p> <p>Ahora bien, tipos de referencia, como clases o arrays trabajan de forma diferente. Utilizamos la palabra new para crear un nuevo objeto.</p> <pre><code>    int[] array = new int[5];\n</code></pre> <p>En este caso, tenemos una referencia a un array. Los tipos de referencia son usados por una referencia. Por lo tanto, una referencia contiene una referencia o una direcci\u00f3n de objeto pero no el objeto en s\u00ed.</p> <p>En el ejemplo anterior, la variable array contiene una referencia o direcci\u00f3n al array en la memoria.</p> <p>Con los tipos de referencia, usamos una referencia para controlar el objeto en memoria, no podemos acceder al objeto directamente.</p> <p>Una referencia es como una direcci\u00f3n de alg\u00fan objeto en memoria.</p> <pre><code>    int[] array = new int[5];\nint[] otroArray = array;\n</code></pre> <p>En el c\u00f3digo anterior, hemos declarado otroArray que es una referencia al mismo array en memoria. Es decir, ahora tenemos dos referencias apuntando al mismo array en memoria. O dicho de otra forma, tanto array como otroArray contienen la misma direcci\u00f3n en memoria.</p> <p>Como se puede observar, una forma de saber si es de tipo de referencia es con el operador new, ya que este crea un nuevo objeto en memoria.</p> <p>Para imprimir el contenido de un array, podemos usar un m\u00e9todo integrado en Java en la clase <code>Arrays.toString</code>. Este m\u00e9todo imprime el contenido del array en una sola l\u00ednea separando los elementos con comas.</p> <pre><code>    int[] array = new int[5];\nint[] otroArray = array;\n\nSystem.out.println(Arrays.toString(array));\nSystem.out.println(Arrays.toString(otroArray));\n</code></pre> <p>Ahora mismo, los arrays est\u00e1n vac\u00edos por tanto se imprime todo con valores 0. Vamos a ver que ocurre si modificamos un valor en el array otroArray.</p> <pre><code>    int[] array = new int[5];\nint[] otroArray = array;\n\nSystem.out.println(Arrays.toString(array));\nSystem.out.println(Arrays.toString(otroArray));\n\notroArray[0] = 3;\n\nSystem.out.println(Arrays.toString(array));\nSystem.out.println(Arrays.toString(otroArray));\n</code></pre> <p>Si ejecutamos el c\u00f3digo, veremos que ambos arrays han cambiado. Esto ocurre porque las dos variables apuntan al mismo array en memoria. Solo hay una copia del array en la memoria. Las dos variables contienen la direcci\u00f3n que apunta al array en memoria.</p> <p></p> <p>Para desreferenciar un array y que apunte a otro array en memoria tenemos que usar el operador new:</p> <pre><code>    int[] array = new int[5];\nint[] otroArray = array;\n\nSystem.out.println(Arrays.toString(array));\nSystem.out.println(Arrays.toString(otroArray));\n\narray = new int[]{1, 2, 3};\notroArray[0] = 3;\n\nSystem.out.println(Arrays.toString(array));\nSystem.out.println(Arrays.toString(otroArray));\n</code></pre>"},{"location":"ud4/3referencetypearrays/#metodos-paso-por-referencia","title":"M\u00e9todos: paso por referencia","text":"<p>Recuerda que Java usa llamada por valor para pasar datos a m\u00e9todos, esto es que env\u00eda una copia del dato, por tanto cualquier modificaci\u00f3n de la copia dentro del m\u00e9todo no afecta al original. Con par\u00e1metros de tipo array es diferente. Si pasamos a un m\u00e9todo el array, ya que le estamos pasando la referencia al array, crear\u00eda una nueva variable dentro del m\u00e9todo pero \u00e9sta apuntar\u00eda al mismo array en memoria. Cualquier modificaci\u00f3n dentro del m\u00e9todo en el array se ver\u00eda fuera del m\u00e9todo puesto que solo hay un objeto array en memoria.</p>"},{"location":"ud4/4arrayobjects/","title":"Array de objetos","text":"<p>Una caracter\u00edstica importante de los arrays, es que todos los elementos deben ser del mismo tipo.</p> <p>Hasta ahora, hemos estudiado arrays con elementos de tipos primitivos. Sin embargo, tambi\u00e9n se puede crear arrays con elementos de cualquier tipo de datos, incluidas las referencias a objetos.</p> <p>Recordemos que, cuando hacemos <code>String str;</code>, se declara una variable llamada <code>str</code> que almacena la referencia a un objeto de tipo String, pero el objeto todav\u00eda no ha sido creado.</p> <p>Un objeto existe solo despu\u00e9s de haber sido construido. Los objetos se construyen solo mientras se ejecuta un programa cuando se invoca el constructor.</p> <p>Una vez construido, se accede a un objeto siguiendo una referencia al objeto. A menudo, la referencia se mantiene en una variable de referencia como <code>str</code>.</p> <p>En el siguiente ejemplo, se declara una variable de referencia, se construye un objeto y luego la referencia al objeto se coloca en la variable de referencia:</p> <pre><code>String str;             // declara una variable de tipo referencia\nstr = \"Hello World\" ;   // construye el objeto y \n// almacena su referencia\n</code></pre> <p></p>"},{"location":"ud4/4arrayobjects/#array-de-strings","title":"Array de Strings","text":"<p>Para declarar un array de Strings ser realizar\u00eda de la siguiente forma:</p> <pre><code>String[] array = new String[5];\n\narray[0] = \"Hello\";\narray[1] = \"World\";\n...\n</code></pre> <p></p> <p>Cada objeto String del ejemplo es un String normal. Nada en \u00e9l ha cambiado porque su referencia se mantiene en el array. Cada cadena puede tener cualquier n\u00famero de caracteres.</p>"},{"location":"ud4/4arrayobjects/#argumentos-de-linea-de-comandos","title":"Argumentos de l\u00ednea de comandos","text":"<p>Como ya sabemos el m\u00e9todo <code>main</code> recibe un array de Strings como par\u00e1metro:</p> <pre><code>    public static void main(String[] args) {\n}\n</code></pre> <p>Es decir, main recibe una referencia a un array de referencias de String. Este array es construido por el sistema Java justo antes de que <code>main()</code> obtenga el control. Los elementos que contiene el array son cadenas de texto que se pasan en la l\u00ednea de comando que inicia el programa. Por ejemplo, digamos que un programa se inicia con esta l\u00ednea de comando:</p> <p>java Demo cadena1 cadena1</p> <p>Donde <code>Demo</code> es el nombre del programa, <code>cadena1</code> es el primer argumento y <code>cadena2</code> el segudno.</p> <p>Por tanto <code>args[0]</code> contendr\u00e1 cadena1 y <code>args[1]</code> cadena2.</p> <p>Puede haber cualquier n\u00famero de argumentos en la l\u00ednea de comandos. Los argumentos son siempre cadenas de caracteres. Cada argumento est\u00e1 separado del resto por espacios.</p> <p>A veces, se quieren enviar n\u00famero por l\u00ednea de comandos. Por tanto necesitaremos convertir las cadenas de d\u00edgitos en n\u00fameros. Para ello, utilizaremos el m\u00e9todo <code>Integer.parseInt(String)</code> o <code>Double.parseDouble(String)</code>.</p>"},{"location":"ud4/4arrayobjects/#espacio-de-memoria-en-arrays-de-objetos","title":"Espacio de memoria en arrays de objetos","text":"<p>Como hemos comentado, en arrays de objetos, Java almacena solo la referencia al objeto en el propio array, en lugar de todo el objeto. Esto conserva la memoria, ya que las referencias requieren solo 4 bytes cada una, mientras que cada objeto puede requerir cientos de bytes.</p> <p>Ejemplo, para un array de 15 enteros, sabiendo que cada entero requiere 4 bytes de almacenamiento, se almacenar\u00e1 60 bytes contiguos de memoria.</p>"},{"location":"ud4/5sortarrays/","title":"Algoritmos de ordenaci\u00f3n","text":"<p>La ordenaci\u00f3n es una de las t\u00e9cnicas fundamentales que se utilizan en la resoluci\u00f3n de problemas, especialmente en los relacionados con la escritura y la implementaci\u00f3n de algoritmos eficientes.</p> <p>Por lo general, la ordenaci\u00f3n se combina con la b\u00fasqueda, lo que significa que primero ordenamos los elementos de la colecci\u00f3n dada, luego buscamos algo dentro de ella, ya que generalmente es m\u00e1s f\u00e1cil buscar algo en una colecci\u00f3n ordenada, en lugar de sin ordenar.</p> <p>Ordenar un array es el proceso de ordenar sus elementos en orden ascendente o descendente. Los algoritmos de ordenaci\u00f3n se encuentran entre los algoritmos m\u00e1s utilizados en computaci\u00f3n.</p>"},{"location":"ud4/5sortarrays/#bubble-sort-burbuja","title":"Bubble sort (Burbuja)","text":"<p>Funciona intercambiando elementos adyacentes si no est\u00e1n en el orden deseado. Este proceso se repite desde el principio del array hasta que todos los elementos est\u00e1n en orden.</p> <p>Sabemos que todos los elementos est\u00e1n en orden cuando logramos hacer toda la iteraci\u00f3n del array sin intercambiar ning\u00fan elemento en absoluto; entonces, todos los elementos que comparamos estaban en el orden deseado con sus elementos adyacentes y, por extensi\u00f3n, todo el array.</p> <p>Ejemplo:</p> <pre><code>[4, 2, 1, 5, 3] - Paso 1: como 4 &gt; 2, los intercambiamos \n[2, 4, 1, 5, 3] - Paso 2: como 4 &gt; 1, los intercambiamos\n[2, 1, 4, 5, 3] - Paso 3: como no se cumple 4 &gt; 5, los dejamos igual\n[2, 1, 4, 5, 3] - Paso 4: como 5 &gt; 3, los intercambiamos\n[2, 1, 4, 3, 5] - Este es el resultado del array despu\u00e9s de la primera iteraci\u00f3n del bucle externo.\n</code></pre> <p>Como al menos se produjo un intercambio durante la primera iteraci\u00f3n (en realidad hubo tres), debemos revisar todo el array otra vez y repetir el mismo proceso.</p> <p>Repetiremos este proceso, hasta que no se realicen m\u00e1s intercambios, que ser\u00e1 cuando tengamos el array ordenado.</p> <p>La raz\u00f3n por la que este algoritmo se llama Bubble sort es porque los n\u00fameros \"burbujean\" hasta la \"superficie\".</p> <p>Si seguimos haciendo trazas en el ejemplo, siguiendo un n\u00famero en particular (4 es un gran ejemplo), ver\u00e1s que se mueve lentamente hacia la derecha durante el proceso.</p>"},{"location":"ud4/5sortarrays/#complejidad-temporal","title":"Complejidad temporal","text":"<p>Para calcular la complejidad temporal de Bubble Sort, necesitamos mirar el peor escenario posible. \u00bfCu\u00e1l es la cantidad m\u00e1xima de veces que necesitamos pasar por todo el array antes de ordenarlo?</p> <p>El peor escenario ser\u00eda <code>[5, 4, 3, 2, 1]</code>. En la primera iteraci\u00f3n, 5 \"burbujear\u00e1 hasta la superficie\", pero el resto de los elementos permanecer\u00e1n en orden descendente. Tendr\u00edamos que hacer una iteraci\u00f3n para cada elemento excepto 1, y luego otra iteraci\u00f3n para verificar que todo est\u00e9 en orden, por lo que un total de 5 iteraciones.</p> <p>Si pensamos en un array de n elementos, eso significa que necesitamos hacer n iteraciones.</p> <p>Cada una de esas n veces estamos iterando a trav\u00e9s de todo el array, lo que significa que la complejidad temporal en el peor de los casos ser\u00eda Big-O: O(n^2).</p>"},{"location":"ud4/5sortarrays/#counting-sort","title":"Counting sort","text":"<p>El ordenamiento por conteo es un algoritmo de ordenamiento que ordena los elementos de un array contando el n\u00famero de apariciones de cada elemento \u00fanico en el array. El recuento se almacena en un array auxiliar y la ordenaci\u00f3n se realiza mapeando la cuenta como un \u00edndice del array auxiliar.</p>"},{"location":"ud4/5sortarrays/#como-funciona","title":"\u00bfC\u00f3mo funciona?","text":"<ol> <li>Encuentra el elemento m\u00e1ximo <code>max</code> del array dado. </li> <li>Crea un array de longitud <code>max + 1</code> con todos los elementos a 0. Este array se utiliza para almacenar el recuento de los elementos del array. </li> <li>Almacena el recuento de cada elemento en su \u00edndice respectivo en el array de recuento. Por ejemplo: si el elemento 3 aparece 2 veces en el array, entonces 2 se almacena en la tercera posici\u00f3n del array de recuentos. Si el elemento \"5\" no est\u00e1 presente en el array, entonces 0 se almacena en la quinta posici\u00f3n. </li> <li>Almacena la suma acumulativa de los elementos del array de recuentos. Es \u00fatil colocar los elementos en el \u00edndice correcto del array ordenado. </li> <li>Encuentra el \u00edndice de cada elemento del array original en el array de conteo. Esto da el recuento acumulativo. Coloca el elemento en el \u00edndice calculado como se muestra en la figura siguiente. </li> <li>Despu\u00e9s de colocar el elemento en la posici\u00f3n correcta del array ordenado, disminuye el array de recuento para ese \u00edndice en uno.</li> </ol>"},{"location":"ud4/5sortarrays/#complejidad","title":"Complejidad","text":"<p>La complejidad temporal en el peor caso es Big-O: O(n).</p>"},{"location":"ud4/6searcharrays/","title":"Algoritmos de b\u00fasqueda","text":"<p>Supongamos que tenemos un array de grandes dimensiones y necesitamos encontrar uno de sus elementos. Necesitamos un algoritmo para buscar en el array un valor particular, generalmente llamado <code>clave</code>. Si los elementos del array no est\u00e1n organizados en ning\u00fan orden en particular, la \u00fanica forma en que podemos estar seguros de encontrar la clave, asumiendo que est\u00e1 en el array, es buscar cada elemento, comenzando por el primer elemento, hasta encontrarlo. Este algoritmo es conocido como b\u00fasqueda lineal o secuencial.</p>"},{"location":"ud4/6searcharrays/#busqueda-secuencial","title":"B\u00fasqueda secuencial","text":"<p>En la b\u00fasqueda secuencial, cada elemento del array se examinar\u00e1 en secuencia hasta que se encuentre la clave (o se llegue al final del array).</p>"},{"location":"ud4/6searcharrays/#algoritmo-busqueda-secuencial","title":"Algoritmo b\u00fasqueda secuencial","text":"<p>Este algoritmo se puede implementar f\u00e1cilmente en un m\u00e9todo que busca un array de enteros, que se pasa como par\u00e1metro del m\u00e9todo y la <code>clave</code> a buscar. Si la <code>clave</code> se encuentra en el array, se devuelve su ubicaci\u00f3n. Si no se encuentra, se devuelve <code>\u22121</code> para indicar fallo.</p> <pre><code>public class Search {\n\npublic static int sequentialSearch(int[] array, int key) {\nfor (int i = 0; i &lt; array.length; i++) {\nif (array[i] == key) {\nreturn i;\n}\n}\nreturn -1; //no lo ha encontrado\n}\n\n}\n</code></pre> <p>Big O notation es una notaci\u00f3n para representar la complejidad temporal de un algoritmo, su rendimiento. Generalmente describe el peor escenario, es decir, el m\u00e1ximo tiempo en la mayor cantidad de repeticiones que el algoritmo tiene que ejecutar.</p> <ul> <li>Big-O de una b\u00fasqueda secuencial es O(n) en el peor de los casos y O(1) en el mejor.</li> </ul>"},{"location":"ud4/6searcharrays/#busqueda-binaria","title":"B\u00fasqueda binaria","text":"<p>La b\u00fasqueda binaria es un algoritmo de b\u00fasqueda para encontrar la posici\u00f3n de un elemento en un array ordenado.</p> <p>La b\u00fasqueda binaria solo se puede implementar en una lista ordenada de elementos. Si los elementos no est\u00e1n ordenados, primero debemos ordenarlos.</p> <p>El algoritmo de b\u00fasqueda binaria se puede implementar de dos formas diferentes:</p> <ol> <li>M\u00e9todo iterativo</li> <li>M\u00e9todo recursivo. El m\u00e9todo recursivo sigue el enfoque de divide y vencer\u00e1s.</li> </ol>"},{"location":"ud4/6searcharrays/#como-se-hace","title":"\u00bfC\u00f3mo se hace?","text":"<ol> <li>El array en el que se va a realizar la b\u00fasqueda es. Sea <code>x = 4</code> el elemento a buscar. </li> <li>Establezce dos punteros <code>low</code> y <code>high</code> en las posiciones m\u00e1s baja y m\u00e1s alta, respectivamente. </li> <li>Encuentra el elemento del medio <code>mid</code> en la mitad del array, es decir, <code>mid = (low + high)/2; array[mid] = 6</code>. </li> <li>Si <code>x == array[mid]</code>, devuelve <code>mid</code>. De lo contrario, compara el elemento que se va a buscar con <code>m</code>.</li> <li>Si <code>x &gt; array[mid]</code>, comparamos <code>x</code> con el elemento medio de los elementos en el lado derecho de <code>mid</code>. Esto se hace estableciendo <code>low</code> a <code>low = mid + 1</code>.</li> <li>De lo contrario, comparamos <code>x</code> con el elemento central de los elementos en el lado izquierdo de <code>mid</code>. Esto se hace estableciendo <code>high</code> a <code>high = mid - 1</code>. </li> <li>Repetimos los pasos 3 a 6 mientras que <code>low</code> sea menor igual que <code>high</code>. </li> <li><code>x = 4</code> se ha encontrado.</li> </ol> <p>Al m\u00e9todo se le pasa el <code>array</code>, la <code>clave</code>, y las posiciones <code>low</code> y <code>high</code>.</p> <ul> <li>Big-O para la b\u00fasqueda binaria es O(log N) en el peor de los casos y O(1) en el mejor caso.</li> </ul>"},{"location":"ud4/7twodimensionarray/","title":"Arrays multidimensionales","text":"<p>Un array bidimensional o matriz, es un array cuyos componentes son ellos mismos arrays, y es necesario o \u00fatil para ciertos tipos de problemas. Por ejemplo, imagina una clase de 7 estudiantes que tienen un examen cada semana durante 5 semanas. El profesor registra las calificaciones en una tabla. Una celda particular de la tabla se designa por n\u00famero de estudiante y n\u00famero de semana.</p> <p>En Java, una tabla se puede implementar como una matriz 2D. Cada celda de la matriz es una variable que puede contener un valor y funciona como cualquier variable. Al igual que con los arrays unidimensionales, todas las celdas de una matriz 2D son del mismo tipo. El tipo puede ser un tipo primitivo o un tipo de referencia de objeto.</p> <p>Importante: cada celda de la matriz se especifica con un n\u00famero de fila y columna, en ese orden.</p> <p><code>matriz[fila][col]</code></p> <p>Al igual que con los arrays unidimensionales, los \u00edndices comienzan en cero.</p> <p></p> <p>Para acceder a la posici\u00f3n 0,2 lo har\u00edamos con <code>matriz[0][2]</code> y esto devuelve el entero 4.</p> <p>Al igual que con una matriz 1D o un arrar, un \u00edndice de matriz puede ser un literal entero, una variable de tipo entero, un m\u00e9todo que se eval\u00faa como un n\u00famero entero o una expresi\u00f3n aritm\u00e9tica que involucra todas estas cosas:</p> <pre><code>matriz[3][j] = 34;\n\nsuma = matriz[i][j] + suma[i][j + 1];\n\nvalue = matriz[2][someFunction()];\n\nmatriz[1][0] = matriz[i + 3][algunaFunci\u00f3n() - 2];\n</code></pre>"},{"location":"ud4/7twodimensionarray/#declaracion-de-un-array-2d-o-matriz-2d","title":"Declaraci\u00f3n de un array 2D o matriz 2D","text":"<p>Recordamos que al igual que los arrays unidimensionales, las matrices bidimensionales son objetos. Para declara un array bidimensional se puede crear una lista. La lista debe contener las filas cada una separada por una coma; y cada fila es una lista de valores.</p> <p>Ejemplo:</p> <pre><code>int[][] myArray = { {8,1,2,2,9}, {1,9,4,0,3}, {0,3,0,0,7} };\n\n//tambi\u00e9n se puede hacer as\u00ed\nint[][] matriz = new int[5][7];//inicializa todo a 0s\n</code></pre> <p>Cada fila de una matriz 2D puede tener un n\u00famero diferente de celdas.</p> <p>Si un programa intenta acceder a una celda que no existe, se lanzar\u00e1 una excepci\u00f3n (que generalmente detendr\u00e1 su programa). Hacer una asignaci\u00f3n a una celda que no existe es un error.</p>"},{"location":"ud4/7twodimensionarray/#longitud-de-una-matriz-2d","title":"Longitud de una matriz 2D","text":"<p>La longitud de una matriz 2D es el n\u00famero de filas que tiene. Se puede adivinar que \"longitud\" podr\u00eda definirse como un par de n\u00fameros (filas, columnas). Pero el n\u00famero de columnas puede variar de una fila a otra, por lo que esto no funcionar\u00e1. Sin embargo, el n\u00famero de filas no cambia, por lo que funciona como una longitud.</p> <p>Cada fila de una matriz 2D puede tener un n\u00famero diferente de celdas (columnas), por lo que cada fila tiene su propia longitud.</p>"},{"location":"ud4/7twodimensionarray/#entender-mejor-los-arrays-o-matrices-2d","title":"Entender mejor los arrays o matrices 2D","text":"<p>Un array bidimensional se implementa como un array unidimensionales. La declaracion</p> <p><code>int [][] myArray;</code> // 1.</p> <p></p> <p>declara una variable llamada <code>myArray</code> que en el futuro puede hacer referencia a un objeto de matriz. En este punto, no se ha dicho nada sobre el n\u00famero de filas o columnas.</p> <p>Para crear una matriz de 3 filas, har\u00edamos:</p> <p><code>myArray = new int [3][];</code> // 2.</p> <p></p> <p>Ahora <code>myArray</code> hace referencia a un objeto de matriz. El objeto de matriz tiene 3 celdas. Cada celda puede hacer referencia (en el futuro) a una matriz de int, un objeto int []. Sin embargo, ninguna de las celdas se refiere todav\u00eda a un objeto. Se inicializan a nulo.</p> <p>Una forma de crear la fila 0 es esta:</p> <p><code>myArray[0] = new int [3];</code> // 3.</p> <p></p> <p>Esto crea un objeto array 1D y coloca su referencia en la celda 0 de myArray. Las celdas del array 1D se inicializan a 0.</p> <p>Una matriz o array 1D construida previamente se puede asignar a una fila:</p> <pre><code>int[] x = {0, 2};\nint[] y = {0, 1, 2, 3, 4};\n\nmyArray [1] = x;\nmyArray [2] = y; // 4.\n</code></pre> <p></p> <p>No es necesario que las filas tengan el mismo n\u00famero de celdas.</p> <p>Las declaraciones anteriores construyen la matriz 2D paso a paso.</p>"},{"location":"ud4/7twodimensionarray/#como-se-podrian-reemplazar-las-celdas-individuales-de-cada-fila-dentro-de-una-matriz","title":"\u00bfC\u00f3mo se podr\u00edan reemplazar las celdas individuales de cada fila dentro de una matriz?","text":"<p>Si quisieras reemplazar la fila uno del ejemplo anterior con la siguiente sentencia:</p> <p><code>myArray [0] = {1, 9, 4};</code> No funcionar\u00e1.</p> <p>Una lista de inicializadores entre llaves { } solo se puede usar para inicializar una matriz, no para asignarle valores despu\u00e9s de que ya se ha creado y existe.</p> <p>Si has pensado en hacer algo as\u00ed:</p> <pre><code>int[] x = {1, 9, 4}; // declarar e iniciar x\nmyArray [0] = x; // asignar a myArray\n</code></pre> <p>Esto si funcionar\u00eda, pero no har\u00edamos exactamente lo que se pidi\u00f3 en la pregunta. Es decir, de esta forma reemplazar\u00edamos la antigua fila 0 con una nueva fila. Lo que hacemos es construir un nuevo objeto de matriz 1D (un array) que contiene los valores deseados en sus celdas y luego asigna ese objeto a la fila 0 de <code>myArray</code>. La fila 0 anterior ahora es basura.</p> <p>Lo correcto ser\u00eda recorrer la fila 0 y reemplazar el valor de cada celda.</p> <p></p>"},{"location":"ud5/1herencia/","title":"Herencia","text":"<p>Cuando tenemos una clase con una serie de caracter\u00edsticas  y nuestro programa se actualiza o amplia, tal vez se necesita de una clase con unas caracter\u00edsticas similares, como por ejemplo, Ordenador, posee un ram, cpu, tama\u00f1o de disco, etc.</p> <p>Si ahora queremos a\u00f1adir la clase Tablet Android en nuestro sistema, como posee todas esas caracter\u00edsticas de ordenador adem\u00e1s de algunas espec\u00edficas, copiar\u00edamos todo lo que hay en ordenador y agregar\u00edamos lo que fuera espec\u00edfico para Tablet. Lo mismo tendr\u00edamos que realizar si a\u00f1adi\u00e9ramos P\u00f3rtatil Mac. Como te habr\u00e1s dado cuenta, este proceso genera mucho c\u00f3digo repetido. Y arreglar un error en \u00e9l puede ser tambi\u00e9n complicado. Para ello utilizamos la herencia.</p> <p>\u00bfC\u00f3mo se relacionan las clases entre s\u00ed? En Java, y en cualquier otro lenguaje orientado a objetos, las clases se organizan en una jerarqu\u00eda de clases. Una jerarqu\u00eda de clases es como un \u00e1rbol al rev\u00e9s. En lo m\u00e1s alto de la jerarqu\u00eda se encuentra la clase m\u00e1s general, en Java, la clase <code>Object</code>. Las clases debajo de <code>Object</code> en la jerarqu\u00eda se conocen como sus subclases. Dado que todos los objetos que usamos en nuestros programas pertenecen a una clase u otra, esto es como decir que todos los objetos son <code>Object</code>.</p> <p></p> <p>En Java, todas las clases heredan de la clase <code>java.lang.Object</code>. La Figura muestra el concepto de jerarqu\u00eda de clases. Observa que la clase <code>Object</code> se encuentra en la parte superior de la jerarqu\u00eda. Es la clase m\u00e1s generalizada. Tiene caracter\u00edsticas que son comunes a todos los objetos Java. A medida que desciende en la jerarqu\u00eda, las clases se vuelven cada vez m\u00e1s espec\u00edficas. Un rect\u00e1ngulo es un objeto, pero contiene atributos (largo y ancho) que son comunes a todos los rect\u00e1ngulos, pero no a otros objetos de la jerarqu\u00eda. Por ejemplo, un objeto <code>Vehicle</code> no tiene necesariamente una longitud y una anchura.</p> <p>Tambi\u00e9n est\u00e1 la clase <code>Square</code> en la jerarqu\u00eda. Un <code>Square</code> (cuadrado) es un tipo especial de rect\u00e1ngulo, es decir, uno cuyo largo es igual a su ancho.</p> <p>Usando la terminolog\u00eda asociada con este tipo de jerarqu\u00eda, decimos que la clase <code>Rectangle</code> es una subclase de la clase <code>Object</code>. La clase <code>Square</code> es una subclase de <code>Rectangle</code> y <code>Object</code>. Se dice que las clases que se encuentran por encima de una clase dada en la jerarqu\u00eda son sus superclases.</p> <p>Por lo tanto, la clase <code>Rectangle</code> y tambi\u00e9n <code>Object</code> es una superclase de la clase <code>Square</code>.</p> <p>En general, decimos que una subclase extiende una superclase, lo que significa que agrega elementos adicionales (atributos y / o m\u00e9todos) a los contenidos en sus superclases. Como el caso de la clase <code>Square</code> que agrega la caracter\u00edstica de que su largo y ancho son siempre iguales.</p> <p>Hay tres conjuntos de terminolog\u00eda para describir las relaciones de herencia:</p> <ul> <li>padre / hijo</li> <li>clase base / clase derivada</li> <li>superclase / subclase</li> </ul> <p></p> <p>El concepto importante asociado con una jerarqu\u00eda de clases es la noci\u00f3n de herencia de clases, mediante la cual una subclase hereda elementos (atributos y / o m\u00e9todos, excepto el constructor) de sus superclases.</p> <p>Nota</p> <p>Los atributos y m\u00e9todos declarados como <code>private</code> se dice que no se heredan porque su visibilidad es privada y no se puede acceder desde la clase hija, pero si son heredados.</p> <p>Un t\u00e9rmino muy usado en herencia es reutilizaci\u00f3n. Como el propio nombre dice, reutilizar el c\u00f3digo repetido en los programas. Es un mecanismo para reutilizar el c\u00f3digo existente cuando creamos clases heredadas.</p> <p>Para ilustrar c\u00f3mo funciona la herencia pensemos en un ajedrez. Hay varios tipos diferentes de piezas de ajedrez. Hay peones, caballeros, reinas y reyes. Un par de atributos que todas las piezas de ajedrez tienen en com\u00fan es su posici\u00f3n de fila y columna en el tablero de ajedrez. Debido a que todas las piezas de ajedrez tienen estos atributos en com\u00fan, habr\u00e1 una clase en la jerarqu\u00eda superior llamada <code>PiezaAjedrez</code> con estos atributos que ser\u00e1n heredados por todas las subclases de <code>PiezaAjedrez</code>.</p> <p>Una de las acciones que todas las piezas de ajedrez tienen en com\u00fan es que pueden moverse a una casilla determinada del tablero de ajedrez. Pero los diferentes tipos de piezas de ajedrez tienen diferentes formas de moverse. Por ejemplo, un alfil solo puede moverse a lo largo de diagonales en el tablero de ajedrez, mientras que una torre solo puede moverse a lo largo de una fila o columna en el tablero de ajedrez. Entonces, claramente, no podemos describir un m\u00e9todo <code>moveTo()</code> que funcione para todas las piezas de ajedrez. Es por eso que colocamos el m\u00e9todo <code>moveTo()</code> en todas las subclases de <code>PiezaAjedrez</code>. La clase <code>PiezaAjedrez</code> tambi\u00e9n tiene un m\u00e9todo <code>moveTo()</code>, pero tenga en cuenta que su nombre est\u00e1 en cursiva. Esto indica que no se puede definir completamente a ese nivel.</p> <p>En el ajedrez, el rey tiene ciertos atributos y acciones especiales. Por tanto, s\u00f3lo el rey puede ser puesto bajo control. Esto significa que el rey est\u00e1 siendo atacado y en peligro de ser capturado, poniendo fin al juego. Del mismo modo, solo el rey tiene la capacidad de enrocar. Este es un movimiento especial que un rey puede realizar junto con una de sus torres bajo ciertas condiciones. Por lo tanto, la clase <code>Rey</code> tiene ciertas caracter\u00edsticas particulares.</p> <p></p> <p>En los diagramas, la flecha apunta del hijo al padre y muestra la relaci\u00f3n \"es-un\". La flecha apunta a la clase principal de la clase secundaria. La imagen se puede leer como \"un rey es una pieza de ajedrez\".</p> <p>Como vemos, una jerarqu\u00eda de clases representa una especializaci\u00f3n de clases a medida que avanza de arriba hacia abajo. La clase m\u00e1s general, <code>PiezaAjedrez</code>, est\u00e1 en la parte superior de la jerarqu\u00eda. Sus atributos y m\u00e9todos se transmiten (heredan) sus subclases. Sin embargo, adem\u00e1s de los atributos y m\u00e9todos que heredan de sus superclases, las subclases definen sus propios atributos y m\u00e9todos especiales. Cada una de las subclases, Pe\u00f3n, Alfil, etc., representa alg\u00fan tipo de especializaci\u00f3n de la superclase.</p>"},{"location":"ud5/1herencia/#herencia-simple","title":"Herencia simple","text":"<p>En Java, (a diferencia de los humanos) los hijos heredan caracter\u00edsticas de un solo padre. A esto se le llama herencia simple. Aunque algunos lenguajes de programaci\u00f3n permiten que una clase hija herede de m\u00e1s de una clase padre. A esto se le llama herencia m\u00faltiple. Con la herencia m\u00faltiple, a veces es dif\u00edcil saber qu\u00e9 padre contribuy\u00f3 con qu\u00e9 caracter\u00edsticas al hijo. Java evita estos problemas mediante el uso de herencia simple.</p> <p>Una clase padre puede tener m\u00faltiples hijos.</p> <p>La herencia es entre clases, no entre objetos.</p>"},{"location":"ud5/1herencia/#sintaxis-herencia-en-java-extends","title":"Sintaxis herencia en Java - extends","text":"<p>La sintaxis para heredar de una superclase es:</p> <pre><code>public class Child extends Parent {\n// los nuevos miembros y constructores de la clase hija van aqu\u00ed\n}\n</code></pre> <p>Los miembros (variables y m\u00e9todos) de la clase padre se incluyen autom\u00e1ticamente en el hijo por herencia. Si se quieren agregar miembros adicionales en la clase hija se hace en su definici\u00f3n de clase.</p> <p>Las clases declaradas como <code>final</code> no pueden ser extendidas.</p>"},{"location":"ud5/1herencia/#ejemplo-clase-animal","title":"Ejemplo clase Animal","text":"<p>Vamos a crear una clase base <code>Animal</code> que tendr\u00e1 una serie de caracter\u00edsticas comunes para todos los animales como puede ser, nombre, peso, tama\u00f1o, etc.</p> <pre><code>public class Animal {\n\nprivate String name;\nprivate int size;\nprivate int weight;\n\npublic Animal(String name, int size, int weight) {\nthis.name = name;\nthis.size = size;\nthis.weight = weight;\n}\n\n//getters y setters\n}\n</code></pre> <p>Ahora queremos crear un tipo de animal <code>Dog</code> que contendr\u00e1 todas las caracter\u00edsticas (atributos y m\u00e9todos) de la clase <code>Animal</code>:</p> <pre><code>public class Dog extends Animal {\n\n}\n</code></pre> <p>Cuando creamos una subclase, necesitamos llamar al constructor de la superclase para inicializarla, ya que hereda de ella. As\u00ed que tendremos que crear el constructor en la clase <code>Dog</code> que llame dentro al constructor de la superclase (<code>Animal</code>):</p> <pre><code>public class Dog extends Animal {\n\npublic Dog(String name, int size, int weight) {\nsuper(name, size, weight);\n}\n}\n</code></pre> <p>Al crear una clase hija <code>Dog</code> que hereda de la clase padre <code>Animal</code>, lo que estamos haciendo es heredar todo su comportamiento (atributos y m\u00e9todos) y adem\u00e1s nos permite a\u00f1adir atributos espec\u00edficos y \u00fanicos para esa clase hija que son particulares de los perros y no comunes o aplicables a todos los animales.</p>"},{"location":"ud5/1herencia/#super-keyword","title":"Super keyword","text":"<p>La palabra reservada <code>super</code> se utiliza para llamar al constructor de la clase de la que estamos heredando, es decir, llamar a la clase padre o superclase. En nuestro caso, para invocar al constructor de la superclase <code>Animal</code>. Esto nos permite inicializar la clase <code>Animal</code>, ya que <code>Dog</code> es una clase derivada que se basa en ella.</p> <p>La primera l\u00ednea dentro del constructor de la clase hija debe ser la llamada al constructor padre con <code>super()</code>. Si no se especifica expl\u00edcitamente entonces el compilador Java llama por defecto a <code>super();</code>, es decir, al constructor por defecto (sin argumentos) de la clase padre. Si el padre no tiene un constructor sin argumentos, entonces provoca un error.</p> <p>Note</p> <p>Si se proporciona un constructor con par\u00e1metros en una clase, el compilador de Java no crear\u00e1 autom\u00e1ticamente el constructor sin par\u00e1metros.</p> <p>En la clase hija vamos a crear algunos campos espec\u00edficos para los perros como ojos, piernas, etc. Porque recuerda que no todos los animales tienen piernas u ojos pero si todos los perros.</p> <pre><code>public class Dog extends Animal {\n\nprivate int eyes;\nprivate int legs;\nprivate int tail;\n\npublic Dog(String name, int size, int weight) {\nsuper(name, size, weight);\n}\n}\n</code></pre> <p>Adem\u00e1s de los campos que se necesitan para crear un objeto <code>Animal</code>, tambi\u00e9n hay que inicializar los campos propios de la clase <code>Dog</code> en el constructor:</p> <pre><code>public class Dog extends Animal {\n\nprivate int eyes;\nprivate int legs;\nprivate int tail;\n\npublic Dog(String name, int size, int weight, int eyes, int legs, int tail) {\nsuper(name, size, weight);\nthis.eyes = eyes;\nthis.legs = legs;\nthis.tail = tail;\n}\n}\n</code></pre> <p>En la clase base, vamos a a\u00f1adir comportamiento, que ser\u00e1 com\u00fan para todos los animales, comer y moverse:</p> <pre><code>public class Animal {\n\nprivate String name;\nprivate int size;\nprivate int weight;\n\npublic Animal(String name, int size, int weight) {\nthis.name = name;\nthis.size = size;\nthis.weight = weight;\n}\n\npublic void eat() {\n//c\u00f3digo\n}\n\npublic void move() {\n//c\u00f3digo\n}\n}\n</code></pre> <p>Al hacer esto, y crearlos como <code>public</code> (<code>protected</code> tambi\u00e9n servir\u00eda), significa que ahora est\u00e1n disponibles en la clase <code>Dog</code> autom\u00e1ticamente. Es decir, el m\u00e9todo <code>eat</code> y <code>move</code> se hereda a la clase <code>Dog</code>.</p>"},{"location":"ud5/1herencia/#probar-funcionamiento","title":"Probar funcionamiento","text":"<p>Vamos a probar c\u00f3mo funciona la herencia, para ello creamos un clase <code>Main</code> con un m\u00e9todo <code>main</code>.</p> <pre><code>public static void main(String[] args) {\nAnimal animal = new Animal(\"\", 0, 1);\n\nDog dog = new Dog(\"Maxi\", 2, 5, 2, 4, 1);\n\n}\n</code></pre> <p>Vemos que crear un animal no tiene mucho sentido, puesto que no sabemos mucho sobre \u00e9l. Cuando creamos un perro, podemos ser m\u00e1s espec\u00edficos en nuestra definici\u00f3n y dar valores relativos solo para perros. Adem\u00e1s, desde perro tenemos acceso a los m\u00e9todos definidos en la clase padre (<code>Animal</code>) como p\u00fablicos o protected. Por ejemplo, <code>dog.eat()</code> invocar\u00e1 al m\u00e9todo comer que se encuentra en la clase padre, ya que la clase <code>Dog</code> no tiene ning\u00fan m\u00e9todo <code>eat</code>.</p>"},{"location":"ud5/1herencia/#sobreescribir-metodos-de-la-clase-padre-en-los-hijos","title":"Sobreescribir m\u00e9todos de la clase padre en los hijos","text":"<p>La herencia nos aporta la opci\u00f3n de la sobreescritura de m\u00e9todos. Es decir, redefinir los m\u00e9todos de una clase padre en las clases hijas.</p> <p>Por ejemplo, en la clase <code>Dog</code> podemos sobreescribir el m\u00e9todo <code>eat()</code> con una funcionalidad m\u00e1s espec\u00edfica.</p> <p>El IntelliJ nos ofrece un atajo para sobreescritura de m\u00e9todos. Bot\u00f3n derecho --&gt; Generate...</p> <p></p> <p></p> <p>IntelliJ nos muestra todos los m\u00e9todos que est\u00e1n en la clase <code>Animal</code> y podemos sobreescribir:</p> <p></p> <p>Si seleccionamos el m\u00e9todo <code>eat()</code>, tenemos:</p> <pre><code>public class Dog extends Animal {\n\nprivate int eyes;\nprivate int legs;\nprivate int tail;\n\npublic Dog(String name, int size, int weight, int eyes, int legs, int tail) {\nsuper(name, size, weight);\nthis.eyes = eyes;\nthis.legs = legs;\nthis.tail = tail;\n}\n\n@Override\npublic void eat() {\nsuper.eat();//C\u00f3digo que se crea autom\u00e1ticamente y llama al m\u00e9todo eat de la clase padre\n}\n}\n</code></pre> <p>Ahora la clase hija <code>Dog</code> tiene su propio m\u00e9todo <code>eat()</code> con c\u00f3digo espec\u00edfico para esta clase.</p> <pre><code>public class Dog extends Animal {\n\nprivate int eyes;\nprivate int legs;\nprivate int tail;\n\npublic Dog(String name, int years, int weight, int eyes, int legs, int tail) {\nsuper(name, years, weight);\nthis.eyes = eyes;\nthis.legs = legs;\nthis.tail = tail;\n}\n\n//M\u00e9todo privado solo de la clase Dog\nprivate void chew() {\n\n}\n\n@Override\npublic void eat() {\nSystem.out.println(\"Dog eat\");\nchew();\nsuper.eat();\n}\n}\n</code></pre> <p>En t\u00e9rminos de sobreescritura, debemos de llevar cuidado con el m\u00e9todo que se invoca:</p> <pre><code>public class Dog extends Animal {\n\nprivate int eyes;\nprivate int legs;\nprivate int tail;\n\npublic Dog(String name, int years, int weight, int eyes, int legs, int tail) {\nsuper(name, years, weight);\nthis.eyes = eyes;\nthis.legs = legs;\nthis.tail = tail;\n}\n\n//M\u00e9todo privado solo de la clase Dog\nprivate void chew() {\n\n}\n\n@Override\npublic void eat() {\nSystem.out.println(\"Dog eat\");\nchew();\nsuper.eat();\n}\n\npublic void walk() {\nmove();\n}\n\n}\n</code></pre> <p>Si no sobreescribimos el m\u00e9todo <code>move()</code> en la clase <code>Dog</code>, cuando lo invocamos dentro del m\u00e9todo <code>walk()</code> se llamar\u00eda al m\u00e9todo de la clase <code>Animal</code>.</p> <p>Warning</p> <p>Los m\u00e9todos est\u00e1ticos se heredan pero no se pueden sobreescribir.</p>"},{"location":"ud5/1thisvssuper/","title":"This vs Super","text":"<ul> <li> <p>La palabra reservada super se usa para acceder a los miembros (atributos y m\u00e9todos) de la clase padre.</p> </li> <li> <p>La palabra reservada this se utiliza para acceder a los miembros (atributos y m\u00e9todos) de la clase actual en la que se usa.</p> </li> </ul> <p>Las dos palabras pueden usarse en cualquier lugar excepto en bloques de c\u00f3digo est\u00e1tico.</p>"},{"location":"ud5/1thisvssuper/#this","title":"This","text":"<p><code>this</code> es generalmente usada en constructores y en los m\u00e9todos setters, y opcionalmente en los getters ya que no tenemos par\u00e1metro de entrada con el mismo nombre:</p> <pre><code>public class Coche {\n\nprivate int ruedas;\n\npublic Coche(int ruedas) {\nthis.ruedas = ruedas;\n}\n\npublic void setRuedas(int ruedas) {\nthis.ruedas = ruedas;\n}\n\npublic int getRuedas() {\nreturn ruedas;\n}\n}\n</code></pre>"},{"location":"ud5/1thisvssuper/#super","title":"Super","text":"<p><code>super</code> es generalmente usada en sobreescritura de m\u00e9todos al usar herencia. Es decir, se utiliza para llamar desde las clases hijas al m\u00e9todo con el mismo nombre en la clase padre.</p> <pre><code>    @Override\npublic void eat() {\nSystem.out.println(\"Dog eat\");\nchew();\nsuper.eat();\n}\n</code></pre> <p>Sin la palabra reservada <code>super</code>, se producir\u00eda una llamada recursiva al mismo m\u00e9todo de forma infinita.</p>"},{"location":"ud5/1thisvssuper/#this_1","title":"this()","text":"<p>Usamos <code>this()</code> en forma de m\u00e9todo dentro del cuerpo de un constructor cuando queremos invocar a otro constructor sobrecargado dentro de la misma clase. <code>this()</code> solo puede usarse en un constructor; y debe de ser la primera sentencia que aparece en el constructor.</p>"},{"location":"ud5/1thisvssuper/#super_1","title":"super()","text":"<p>Usamos <code>super()</code> en forma de m\u00e9todo dentro del cuerpo de un constructor cuando queremos invocar a un constructor de la clase padre. <code>super()</code> solo puede usarse en un constructor; y debe de ser la primera sentencia que aparece en el constructor.</p> <p>Recordemos que el compilador de Java agrega de forma autom\u00e1tica la sentencia <code>super()</code> en el constructor de la clase hija si nosotros no lo a\u00f1adimos.</p> <p>Note</p> <p>Un constructor puede tener las sentencias <code>this()</code> o <code>super()</code> pero nunca ambas.</p> <p></p> <p>En el siguiente ejemplo, usamos las dos sentencias:</p> <pre><code>class Transporte {\n\nprivate int puertas;\nprivate int precio;\n\npublic Transporte(int puertas, int precio) {\nthis.puertas = puertas;\nthis.precio = precio;\n}\n}\n\npublic class Coche extends Transporte {\n\nprivate String modelo;\nprivate String marca;\n\npublic Coche(String modelo, String marca) {\nthis(0,0,modelo,marca);\n}\n\npublic Coche(int puertas, int precio, String modelo, String marca) {\nsuper(puertas, precio);\nthis.modelo = modelo;\nthis.marca = marca;\n}\n}\n</code></pre>"},{"location":"ud5/2composicion/","title":"Composici\u00f3n","text":"<p>La composici\u00f3n es otro componente de la programaci\u00f3n orientada a objetos y es muy utilizada.</p> <p>Es el mecanismo en el cual una clase se construye a partir de otros objetos de igual o distinto tipo, pudi\u00e9ndolos combinar para obtener la funcionalidad deseada. En la composici\u00f3n la nueva clase, mantiene una relaci\u00f3n \u201cUsa/Tiene un\u201d, con los objetos que son parte de la clase.</p> <p>Vamos a ver un ejemplo de la clase <code>Car</code> que extiende <code>Vehicle</code>:</p> <pre><code>public class Vehicle {\n\nprivate String name;\n}\n\npublic class Car extends Vehicle {\n\nprivate int doors;\nprivate int seats;\n\npublic Car(int doors, int seats) {\nthis.doors = doors;\nthis.seats = seats;\n}\n}\n</code></pre> <p>Estas dos clases tienen una relaci\u00f3n de herencia, el significado es que un coche es un veh\u00edculo.</p> <p>Pero la composici\u00f3n es diferente a la herencia tambi\u00e9n es un tipo de relaci\u00f3n. Por ejemplo, pensemos en un ordenador. Un ordenador se compone de una CPU, pantalla, rat\u00f3n y teclado. Pero una pantalla no es un ordenador, un rat\u00f3n no es un ordenador. Decimos que un ordenador tiene una pantalla, un ordenador tiene un teclado, etc. Eso es la composici\u00f3n, un todo que se construye con partes.</p> <p>Vamos a ver como se implementa esto:</p> <pre><code>public class Procesador {\n\nprivate String modelo;\nprivate int ramSlots;\nprivate int cardSlots;\n\npublic Procesador(String modelo, int ramSlots, int cardSlots) {\nthis.modelo = modelo;\nthis.ramSlots = ramSlots;\nthis.cardSlots = cardSlots;\n}\n\npublic void presionarBotonEncendido() {\nSystem.out.println(\"Iniciando el pc\");\n}\n\npublic void cargarPrograma(String nombre) {\nSystem.out.println(nombre);\n}\n\npublic String getModelo() {\nreturn modelo;\n}\n\npublic void setModelo(String modelo) {\nthis.modelo = modelo;\n}\n\npublic int getRamSlots() {\nreturn ramSlots;\n}\n\npublic void setRamSlots(int ramSlots) {\nthis.ramSlots = ramSlots;\n}\n\npublic int getCardSlots() {\nreturn cardSlots;\n}\n\npublic void setCardSlots(int cardSlots) {\nthis.cardSlots = cardSlots;\n}\n}\n\npublic class Monitor {\n\nprivate String modelo;\nprivate String resolucion;\nprivate int tam;\n\npublic Monitor(String modelo, String resolucion, int tam) {\nthis.modelo = modelo;\nthis.resolucion = resolucion;\nthis.tam = tam;\n}\n\npublic void dibujarPixel(int x, int y) {\nSystem.out.println(\"Pixel en \" + x + y);\n}\n\npublic String getModelo() {\nreturn modelo;\n}\n\npublic void setModelo(String modelo) {\nthis.modelo = modelo;\n}\n\npublic String getResolucion() {\nreturn resolucion;\n}\n\npublic void setResolucion(String resolucion) {\nthis.resolucion = resolucion;\n}\n\npublic int getTam() {\nreturn tam;\n}\n\npublic void setTam(int tam) {\nthis.tam = tam;\n}\n}\n\npublic class Teclado {\n\nprivate String color;\nprivate int teclas;\n\npublic Teclado(String color, int teclas) {\nthis.color = color;\nthis.teclas = teclas;\n}\n\npublic void pushKey(char key) {\nSystem.out.println(\"Se ha presionado la tecla \" + key);\n}\n\npublic String getColor() {\nreturn color;\n}\n\npublic void setColor(String color) {\nthis.color = color;\n}\n\npublic int getTeclas() {\nreturn teclas;\n}\n\npublic void setTeclas(int teclas) {\nthis.teclas = teclas;\n}\n}\n</code></pre> <p>Hemos creado las clases <code>Monitor</code>, <code>Teclado</code> y <code>Procesador</code>. Ahora vamos a crear una clase <code>Ordenador</code> que se compondr\u00e1n de las otras tres clases de la forma:</p> <pre><code>public class Ordenador {\n\nprivate Procesador procesador;\nprivate Teclado teclado;\nprivate Monitor monitor;\n\npublic Ordenador(Procesador procesador, Teclado teclado, Monitor monitor) {\nthis.procesador = procesador;\nthis.teclado = teclado;\nthis.monitor = monitor;\n}\n\npublic Procesador getProcesador() {\nreturn procesador;\n}\n\npublic void setProcesador(Procesador procesador) {\nthis.procesador = procesador;\n}\n\npublic Teclado getTeclado() {\nreturn teclado;\n}\n\npublic void setTeclado(Teclado teclado) {\nthis.teclado = teclado;\n}\n\npublic Monitor getMonitor() {\nreturn monitor;\n}\n\npublic void setMonitor(Monitor monitor) {\nthis.monitor = monitor;\n}\n}\n</code></pre> <p>Ya hemos implementado nuestras clases que componen un <code>Ordenador</code>. Ahora vamos a ver como utilizarlas:</p> <pre><code>public class Main {\n\npublic static void main(String[] args) {\nProcesador procesador = new Procesador(\"Intel\", 2, 3);\nMonitor monitor = new Monitor(\"Philips\", \"1024x900\", 24);\nTeclado teclado = new Teclado(\"Negror\",90);\n\nOrdenador ordenador = new Ordenador(procesador, teclado, monitor);\n}\n}\n</code></pre> <p>Se ha creado un objeto de la clase <code>Ordenador</code> a partir de las otras clases. En herencia ten\u00edamos acceso a los atributos de la clase padre, pero ahora con composici\u00f3n para acceder a los m\u00e9todos o atributos de las partes a partir de <code>Ordenador</code> lo haremos usando los m\u00e9todos getters que tenemos en la clase y nos permite acceder a <code>Teclado</code>, <code>Monitor</code> y <code>Procesador</code>.</p> <pre><code>    public static void main(String[] args) {\nProcesador procesador = new Procesador(\"Intel\", 2, 3);\nMonitor monitor = new Monitor(\"Philips\", \"1024x900\", 24);\nTeclado teclado = new Teclado(\"Negror\",90);\n\nOrdenador ordenador = new Ordenador(procesador, teclado, monitor);\nordenador.getMonitor().dibujarPixel(34, 56);\nordenador.getProcesador().cargarPrograma(\"Demo\");\nordenador.getTeclado().pushKey('X');\n}\n</code></pre>"},{"location":"ud5/2composicion/#ocultar-funcionalidad-de-los-objetos-parte","title":"Ocultar funcionalidad de los objetos parte","text":"<p>Otro escenario viable es el cual nos permita ocultar la funcionalidad, y no le permitamos al programa acceder directamente a los objetos que componen el todo. Para ello, lo primero que haremos ser\u00e1 modificar la visibilidad de los getters y ponerlos <code>private</code>, de manera que no se pueda acceder desde fuera a <code>Teclado</code>, <code>Monitor</code> o <code>Procesador</code> pero si podamos acceder internamente.</p> <pre><code>public class Ordenador {\n\nprivate Procesador procesador;\nprivate Teclado teclado;\nprivate Monitor monitor;\n\npublic Ordenador(Procesador procesador, Teclado teclado, Monitor monitor) {\nthis.procesador = procesador;\nthis.teclado = teclado;\nthis.monitor = monitor;\n}\n\nprivate Procesador getProcesador() {\nreturn procesador;\n}\n\nprivate Teclado getTeclado() {\nreturn teclado;\n}\n\nprivate Monitor getMonitor() {\nreturn monitor;\n}\n}\n</code></pre> <p>Una vez oculta la informaci\u00f3n veamos como podemos acceder a ella en el main. Creamos un m\u00e9todo en la clase <code>Ordenador</code> que acceder\u00e1 a las distintas partes.</p> <pre><code>public class Ordenador {\n\nprivate Procesador procesador;\nprivate Teclado teclado;\nprivate Monitor monitor;\n\npublic Ordenador(Procesador procesador, Teclado teclado, Monitor monitor) {\nthis.procesador = procesador;\nthis.teclado = teclado;\nthis.monitor = monitor;\n}\n\npublic void encender() {\ngetProcesador().presionarBotonEncendido();\ndibujarLogo();\n}\n\nprivate void dibujarLogo() {\nmonitor.dibujarPixel(12, 23);\n}\n\nprivate Procesador getProcesador() {\nreturn procesador;\n}\n\nprivate Teclado getTeclado() {\nreturn teclado;\n}\n\nprivate Monitor getMonitor() {\nreturn monitor;\n}\n}\n</code></pre> <p>En el <code>main</code> accederemos a este m\u00e9todo:</p> <pre><code>    public static void main(String[] args) {\nProcesador procesador = new Procesador(\"Intel\", 2, 3);\nMonitor monitor = new Monitor(\"Philips\", \"1024x900\", 24);\nTeclado teclado = new Teclado(\"Negror\",90);\n\nOrdenador ordenador = new Ordenador(procesador, teclado, monitor);\nordenador.encender();\n}\n</code></pre>"},{"location":"ud5/3encapsulacion/","title":"Encapsulaci\u00f3n","text":"<p>El mecanismo que permite restringir el acceso a componentes en los objetos, es decir, ofrece protecci\u00f3n a los miembros de la clase de cualquier acceso externo no autorizado es la encapsulaci\u00f3n. No estamos hablando de seguridad, hablamos m\u00e1s bien, de restringir el acceso desde fuera al funcionamiento interno de una clase, es decir, ocultar el trabajo interno que se realiza en una clase.</p> <p>Veamos un ejemplo de una clase que no usa encapsulaci\u00f3n y as\u00ed nos permitir\u00e1 entender mejor porqu\u00e9 la encapsulaci\u00f3n en algo positivo. Luego veremos c\u00f3mo se har\u00eda con encapsulaci\u00f3n.</p>"},{"location":"ud5/3encapsulacion/#ejemplo-de-programa-sin-encapsulacion","title":"Ejemplo de programa SIN encapsulaci\u00f3n","text":""},{"location":"ud5/3encapsulacion/#acceso-a-la-clase-y-modificacion-de-funcionalidad","title":"Acceso a la clase y modificacion de funcionalidad","text":"<p>Primero creamos una clase <code>Player</code> con los siguiente campos:</p> <pre><code>public class Player {\n\npublic String name;\npublic int health;\npublic String weapon;\n\npublic void applyDamage(int damage) {\nthis.health -= damage;\nif (this.health &lt;= 0 ) {\nSystem.out.println(\"Player died\");\n}\n}\n\npublic int getActualHealth() {\nreturn health;\n}\n}\n</code></pre> <p>Ahora implementamos el <code>main</code> en otra clase:</p> <pre><code>public class Main {\n\npublic static void main(String[] args) {\nPlayer player = new Player();\nplayer.name = \"Patricia\";\nplayer.health = 50;\nplayer.weapon = \"flamethrower\";\n\nint damage = 30;\nplayer.applyDamage(damage);\nSystem.out.println(\"The actual health is \" + player.getActualHealth());\n\ndamage = 10;\nplayer.health = 100;\nplayer.applyDamage(damage);\nSystem.out.println(\"The actual health is \" + player.getActualHealth());\n}\n}\n</code></pre> <p>Observamos que podemos inicializar directamente los campos del objeto <code>Player</code> a trav\u00e9s de clase externa porque hemos establecido la visibilidad como <code>public</code>. Adem\u00e1s, vemos que podemos causar da\u00f1o al jugador, pero seguidamente podemos darle m\u00e1s vida puesto que tenemos control sobre los atributos del jugador. Por lo que, al poder acceder a esos campos directamente potencialmente estamos abriendo la aplicaci\u00f3n y permitiendo cambiar el comportamiento. Ya que nosotros no queremos que se le pueda dar vida. Solo aplicar da\u00f1o.</p>"},{"location":"ud5/3encapsulacion/#consecuencias-de-cambios-internos-de-la-clase","title":"Consecuencias de cambios internos de la clase","text":"<p>Imaginar que la aplicaci\u00f3n evoluciona y queremos modificar un atributo de la clase <code>Player</code>, por ejemplo, ya no queremos el nombre, ahora vamos a tener en cuenta el <code>nickname</code> del jugador.</p> <p></p> <p>Al hacer este cambio, el m\u00e9todo <code>main</code> que acced\u00eda a este campo, genera un error. Lo que significa que cualquier campo que hagamos en la clase de <code>Player</code> afectar\u00e1 a cualquier clase que lo haya usado. Sabiendo que, es un cambio interno de la clase y en teor\u00eda no deber\u00eda afectar a ninguna otra clase, porque hemos decidido que es se entiende mejor si el atributo se llama <code>nickname</code> que si se llama <code>name</code>.</p>"},{"location":"ud5/3encapsulacion/#garantizar-la-clase-se-crea-con-los-valores-correctos","title":"Garantizar la clase se crea con los valores correctos","text":"<p>Como no hemos definido un constructor, puede ser que la clase externa que usa <code>Player</code> no defina las variables de forma v\u00e1lida. Por tanto, no podemos garantizar que el uso del objeto jugador sera correcto.</p> <p>Imagina que al crear un objeto de la clase <code>Player</code> nos olvidamos de darle valor al campo de <code>health</code>:</p> <p></p> <p>Al intentar aplicar da\u00f1o no se aplicar\u00e1 de forma correcta. Por tanto, es conveniente definir un constructor para garantizar que el objeto se construye de forma correcta y adem\u00e1s si queremos agregar alg\u00fan tipo de validaci\u00f3n tambi\u00e9n podr\u00edamos realizarla en el constructor.</p>"},{"location":"ud5/3encapsulacion/#ejemplo-de-programa-con-encapsulacion","title":"Ejemplo de programa CON encapsulaci\u00f3n","text":"<p>Vamos a ver cu\u00e1l es la forma correcta realizar el ejemplo anterior usando encapsulaci\u00f3n.</p> <pre><code>public class PlayerOk {\n\nprivate String name;\nprivate int health = 100;\nprivate String weapon;\n\npublic PlayerOk(String name, int health, String weapon) {\nthis.name = name;\nif (health &gt; 0 &amp;&amp; health &lt;= 100) {\nthis.health = health;\n}\nthis.weapon = weapon;\n}\n\npublic void applyDamage(int damage) {\nthis.health -= damage;\nif (this.health &lt;= 0 ) {\nSystem.out.println(\"Player died\");\n}\n}\n\npublic int getActualHealth() {\nreturn health;\n}\n}\n</code></pre> <pre><code>public class Main {\n\npublic static void main(String[] args) {\nPlayerOk playerOk = new PlayerOk(\"Patri\", 50, \"flamethrower\");\nPlayerOk playerOk2 = new PlayerOk(\"Manu\", 150, \"sword\");\n}\n}\n</code></pre>"},{"location":"ud5/4polimorfismo/","title":"Polimorfismo","text":"<p>El Polimorfismo es uno de los 4 pilares de la programaci\u00f3n orientada a objetos (POO) junto con la Abstracci\u00f3n, Encapsulaci\u00f3n y Herencia. Para entender que es el polimorfismo es muy importante que teng\u00e1is bastante claro el concepto de la Herencia.</p> <p>Polimorfismo significa \"que tiene muchas formas\", es la capacidad que tienen los objetos de una clase en ofrecer respuesta distinta e independiente en funci\u00f3n de los par\u00e1metros (diferentes implementaciones) utilizados durante su invocaci\u00f3n.</p> <p>Veamos un ejemplo para entender de forma m\u00e1s clara c\u00f3mo funciona el polimorfismo.</p> <p>Crearemos unas clases que heredan de la clase padre <code>Pelicula</code>:</p> <pre><code>class Pelicula {\nprivate String titulo;\n\npublic Pelicula(String titulo) {\nthis.titulo = titulo;\n}\n\npublic String trama() {\nreturn \"No hay trama\";\n}\n}\n\nclass Spiderman extends Pelicula {\npublic Spiderman() {\nsuper(\"Spiderman\");\n}\n\n@Override\npublic String trama() {\nreturn \"Un hombre que le muerde una ara\u00f1a y adquiere sus poderes.\";\n}\n}\n\nclass Batman extends Pelicula {\npublic Batman() {\nsuper(\"Batman\");\n}\n\n@Override\npublic String trama() {\nreturn \"Un hombre que le muerde un murci\u00e9lago y adquiere sus poderes.\";\n}\n}\n\nclass Zombieland extends Pelicula {\npublic Zombieland() {\nsuper(\"Zombieland\");\n}\n\n@Override\npublic String trama() {\nreturn \"Un pu\u00f1ado de humanos convertidos en zombies tratan de hacerse con el mundo\";\n}\n}\n\nclass StarWars extends Pelicula {\npublic StarWars() {\nsuper(\"StarWars\");\n}\n\n@Override\npublic String trama() {\nreturn \"Las fuerzas imperiales tratan de hacerse con control del mundo\";\n}\n}\n\nclass PeliRandom extends Pelicula {\npublic PeliRandom() {\nsuper(\"PeliRandom\");\n}\n}\n</code></pre> <p>Ahora vamos a crear un m\u00e9todo est\u00e1tico que nos va a devolver un objeto de tipo <code>Pelicula</code> en la clase <code>Main</code>, es decir, nos devolver\u00e1 una pel\u00edcula de manera aleatoria:</p> <pre><code>    public static Pelicula peliculaAleatoria() {\nint numero = (int) (Math.random()*5) + 1; //genera un n\u00famero aleatorio entre 1 - 5\nSystem.out.println(numero);\nswitch (numero) {\ncase 1:\nreturn new Spiderman();\ncase 2:\nreturn new Batman();\ncase 3:\nreturn new Zombieland();\ncase 4:\nreturn new StarWars();\ncase 5:\nreturn new PeliRandom();\n}\nreturn null;\n}\n</code></pre> <p>Gracias a la herencia, podemos devolver un tipo de la clase padre <code>Pelicula</code> aunque en realidad hayamos creado un objeto de una clase hija.</p> <p>Ahora vamos a ver el polimorfismo, para ello vamos a crear un bucle en el main de la siguiente forma:</p> <pre><code>    public static void main(String[] args) {\nfor (int i = 0; i &lt; 10; i ++) {\nPelicula pelicula = peliculaAleatoria();\nSystem.out.println(\"Pelicula \" + i + \" \" + pelicula.getTitulo() + \" \\n\" + pelicula.trama());\n}\n}\n</code></pre> <p>Gracias al polimorfismo tenemos la capacidad de llamar al m\u00e9todo <code>trama</code> con el mismo tipo de objeto, en este caso de tipo <code>Pelicula</code> y obtener diferentes resultados, ya que Java autom\u00e1ticamente ve qu\u00e9 tipo de hijo es e imprime el correspondiente m\u00e9todo <code>trama</code>. Para el caso de que no se haya sobreescrito el m\u00e9todo llamar\u00e1 al de la clase padre Es decir, dependiendo del tipo de objeto invocado se realizan acciones diferentes, teniendo en cuenta, que todas las clases heredan de <code>Pelicula</code> eso es el polimorfismo.</p>"},{"location":"ud5/4polimorfismo/#importante","title":"Importante","text":"<p>Una variable puede contener una referencia a un objeto cuya clase es descendiente de la clase de la variable. Ejemplo:</p> <pre><code>    //La variable a es una referencia a un objeto Perro que es descendiente de Animal. \nAnimal a = new Perro();\n</code></pre> <p>Un descendiente de una clase es un hijo de esa clase, o un hijo de un hijo de esa clase, y as\u00ed sucesivamente. Los hermanos no son descendientes entre s\u00ed.</p> <p>NO podemos asignar un objeto de referencia de padre a una variable de clase hijo (Perro p = new Animal()). Si queremos convertir un padre en hijo, la variable tiene que ser creada de tipo hijo. Si queremos convertir un hijo en padre tendremos que hacer un Upcasting, y al rev\u00e9s tendr\u00edamos un Downcasting:</p> <p></p> <p>Ejemplo</p> <pre><code>    //NO SE PUEDE HACER\nPerro p = new Animal(); //no compila\nPerro p = (Perro) new Animal(); // compila pero da error de ejecuci\u00f3n\n\n//DOWNCASTING, convertir padre en hijo\nAnimal a = new Perro();\nPerro pe = (Perro)a;\n\n//UPCASTING, convertir hijo en padre\nAnimal a = (Animal) new Perro();\n</code></pre>"},{"location":"ud5/5interfaces/","title":"\u2695\ufe0fInterfaces","text":""},{"location":"ud5/5interfaces/#definicion","title":"\u2747\ufe0f Definici\u00f3n","text":"<p>Una interfaz es una clase que define m\u00e9todos pero no los implementa. La idea es proporcionar un comportamiento com\u00fan que pueda ser utilizado por varias clases que implemente una interfaz. No se pueden instanciar.</p> <p>Una interfaz es una lista de constantes y signaturas de m\u00e9todos. Los m\u00e9todos no est\u00e1n implementados en la interfaz (no hay cuerpo de m\u00e9todo).</p>"},{"location":"ud5/5interfaces/#por-que-se-utilizan-las-interfaces","title":"\u2747\ufe0f \u00bfPor qu\u00e9 se utilizan las interfaces?","text":"<p>Hay principalmente tres razones para usar la interfaz.</p> <ul> <li>Para lograr la abstracci\u00f3n.</li> <li>Dan algunas ventajas de herencia m\u00faltiple, sin las desventajas de la herencia.</li> <li>Para obtener un mayor desacoplamiento del c\u00f3digo.</li> </ul> <p>Las interfaces son muy usadas, de hecho, muchas de las librer\u00edas de Java hacen un uso extensivo de las interfaces.</p> <p>Sabemos que Java tiene herencia \u00fanica, es decir, una clase hija hereda solo de una clase padre. Esto, por lo general, es suficiente para codificar nuestras aplicaciones. Aunque a veces ser\u00eda conveniente la herencia m\u00faltiple, donde una clase hija pudiera heredar caracter\u00edsticas de varias clases padres. Pero esto puede llegar a ser confuso. \u00bfQu\u00e9 sucede cuando dos padres tienen diferentes versiones del mismo m\u00e9todo?</p> <p>Una interfaz describe aspectos de una clase distintos de los que hereda de su padre. Una interfaz es un conjunto de requisitos que la clase debe implementar.</p>"},{"location":"ud5/5interfaces/#interfaz-vs-herencia","title":"\u2747\ufe0f Interfaz vs Herencia","text":"<p>Una clase puede extender de una clase padre para heredar los m\u00e9todos y las variables de instancia de ese padre. </p> <p>Una clase tambi\u00e9n puede implementar una interfaz al incluir m\u00e9todos y constantes adicionales. Sin embargo, los m\u00e9todos en la interfaz deben escribirse expl\u00edcitamente como parte de la definici\u00f3n de la clase. La interfaz es una lista de requisitos que debe incluir la definici\u00f3n de clase (a trav\u00e9s de c\u00f3digo expl\u00edcito, no a trav\u00e9s de herencia).</p> <p>Por ejemplo, una clase <code>Coche</code> podr\u00eda extender de la clase <code>Vehiculo</code>. La herencia le da todos los m\u00e9todos y variables de instancia. Pero si <code>Coche</code> tambi\u00e9n implementa la interfaz <code>Impuestos</code>, entonces su definici\u00f3n debe contener c\u00f3digo para TODOS los m\u00e9todos enumerados en <code>Impuestos</code>.</p> <p>En Java las interfaces tambi\u00e9n representan una relaci\u00f3n ES-UN.</p> <p>Una clase extiende de un solo padre, pero puede implementar varias interfaces.</p>"},{"location":"ud5/5interfaces/#como-crear-una-interfaz","title":"\u2747\ufe0f C\u00f3mo crear una interfaz","text":"<p>Para crear una interfaz en IntelliJ, haremos lo siguiente:</p> <ol> <li>Bot\u00f3n derecho en el paquete de nuestra aplicaci\u00f3n --&gt; New ---&gt; Java class y seleccionamos Interface.</li> </ol> <p></p> <p></p> <p>En Java, los nombres de las interfaces, por lo general, deber\u00edan ser adjetivos o nombres que describen el concepto abstracto que representa la interfaz. La primera letra de cada palabra separada en may\u00fascula. En algunos casos, las interfaces tambi\u00e9n pueden ser sustantivos cuando presentan una familia de clases, p. <code>List</code> o <code>Map</code>.</p> <p></p> <p>Una vez creada la interfaz definiremos los m\u00e9todos que desarrollar\u00e1n las clases que implementen esta interfaz teniendo en cuenta que, el compilador de Java agrega las palabras clave:</p> <ul> <li><code>public abstract</code> cuando se define un m\u00e9todo, por lo que se puede omitir en los encabezados de los m\u00e9todos. </li> <li><code>public static final</code> en el caso de las constantes.</li> </ul> <p></p> <p>Warning</p> <p>Los m\u00e9todos abstractos NO pueden ser PRIVATE ni PROTECTED.</p> <p>Se estructura de forma que primero se sit\u00faan las constantes y luego los m\u00e9todos.</p> <p>Si ponemos <code>public</code> IntelliJ nos avisa:</p> <p></p> <p></p>"},{"location":"ud5/5interfaces/#relaciones-entre-interfaces-y-clases","title":"\u2747\ufe0f Relaciones entre interfaces y clases","text":"<p>Tenemos tres tipos de relaciones:</p> <ul> <li><code>classB</code> extends <code>classA</code>: una clase B hereda de una clase A.</li> <li><code>class</code> implements <code>interface1</code>, <code>interface2</code>, ...: una clase puede implementar una o varias interfaces, para ello usaremos la palabra reservada implements.</li> <li><code>interfaceB</code> extends <code>interfaceA</code>, <code>interfaceC</code>, ...: una interfaz B puede heredar los m\u00e9todos de una o varias interfaces. Una interfaz NO PUEDE heredar de una clase.</li> </ul> <p>Tambi\u00e9n podemos combinar algunas relaciones:</p> <ul> <li><code>classB</code> extends <code>classA</code> implements <code>interface1</code>, <code>interface2</code>, ...:  una clase B hereda de una clase A y tambi\u00e9n implementa los m\u00e9todos definidos en las interfaces. (Simulaci\u00f3n de la herencia m\u00faltiple)</li> </ul>"},{"location":"ud5/5interfaces/#ejemplo-de-codigo","title":"\u2747\ufe0f Ejemplo de c\u00f3digo","text":"<p>Por ejemplo, vamos a crear la clase TelefonoMovil:</p> <p></p> <p>Observamos que IntelliJ nos genera un error, ya que debemos definir o implementar los m\u00e9todos que hab\u00edamos declarado en la interfaz. Si hacemos click en el error, IntelliJ nos ofrece crearlos:</p> <p></p> <p></p> <p>IntelliJ nos ha creado TODOS los m\u00e9todos que hab\u00edamos definido en la interfaz, como vemos con la anotaci\u00f3n <code>@Override</code>, ya que los est\u00e1 sobreescribiendo puesto que estaban declarados en la interfaz.</p> <p>Note</p> <p>TODOS los m\u00e9todos definidos en la interfaz se han de implementar en la clase, no podr\u00edamos implementar solo algunos.</p> <p>Veamos como probar el c\u00f3digo en nuestra clase <code>Main</code>:</p> <pre><code>public class MainTelefono {\n\npublic static void main(String[] args) {\nImpuesto impuesto = new TelefonoMovil(123456789);\nimpuesto.imprimirImpuesto();\n}\n}\n</code></pre> <p>Warning</p> <p>Las interfaces NO PUEDEN INSTANCIARSE, es decir, no podemos crear objetos de interfaces. Hay que usar una clase que haya implementado la funcionalidad definida por la interfaz.</p>"},{"location":"ud5/5interfaces/#novedades","title":"\u2747\ufe0f Novedades","text":"<p>Desde Java 8 podemos incluir en una interfaz:</p> <ul> <li> <p>m\u00e9todos con cuerpo o implementaci\u00f3n: se denominan default methods. Estos m\u00e9todos se heredan como cualquier m\u00e9todo ordinario m\u00e1s y se pueden sobreescribir en la clase que implementa esa interfaz o sobreescribir en la interfaz que hereda de esa interfaz.</p> </li> <li> <p>m\u00e9todos est\u00e1ticos con cuerpo o implementaci\u00f3n. Estos m\u00e9todos no pueden ser sobreescritos o cambiar en ninguna clase que implemente la interfaz. Aunque si se heredan.</p> </li> </ul> Impuesto.java<pre><code>public interface Impuesto {\n\n//constantes\ndouble TASA_DE_IMPUESTO = 0.06;\n\n//m\u00e9todos abstractos\ndouble calcularImpuestoAnual();\n\nvoid imprimirImpuesto();\n\n//default methods\ndefault void imprimirTasa() {\nSystem.out.println(\"La tasa de impuesto es \" + TASA_DE_IMPUESTO);\n}\n\n//m\u00e9todos est\u00e1ticos\nstatic double tax(int precio) {\nreturn TASA_DE_IMPUESTO * precio;\n}\n}\n</code></pre>"},{"location":"ud5/5interfaces/#por-que-el-uso-de-default-o-static-methods-en-el-interior-de-una-interfaz","title":"\u269c\ufe0f \u00bfPor qu\u00e9 el uso de default o static methods en el interior de una interfaz?","text":"<p>Imagina que creamos una interfaz en el proyecto. Pasado un tiempo, un gran n\u00famero de clases implementan esa interfaz.</p> <p>Si ahora a\u00f1adimos un nuevo m\u00e9todo a esta interfaz, desencadena en que, todas las clases que implementen esa interfaz se ver\u00e1n afectadas con errores, hasta que implementen o le den cuerpo a ese nuevo m\u00e9todo. Aunque no es una tarea complicada puede llegar a ser tediosa, o que no sepamos todav\u00eda como implementarlo en todas las clases.</p> <p>Para solventar esto, Java introdujo los default methods y m\u00e9todos est\u00e1ticos.</p> <ul> <li>Desde Java 9, podemos tener m\u00e9todos privados en una interfaz.</li> </ul> <p>Los m\u00e9todos privados se pueden implementar est\u00e1ticos o no. </p> <p>\u00bfCu\u00e1les son las ventajas de tener m\u00e9todos privados?</p> <p>Las interfaces pueden usar m\u00e9todos privados para ocultar detalles sobre la implementaci\u00f3n de las clases que implementan la interfaz. Como resultado, uno de los principales beneficios de tenerlos en las interfaces es la encapsulaci\u00f3n.</p> Impuesto.java<pre><code>public interface Impuesto {\n\n//constantes\ndouble TASA_DE_IMPUESTO = 0.06;\n\n//m\u00e9todos abstractos\ndouble calcularImpuestoAnual();\n\nvoid imprimirImpuesto();\n\n//default methods\ndefault void imprimirTasa() {\nSystem.out.println(\"La tasa de impuesto es \" + TASA_DE_IMPUESTO);\n}\n\ndefault void aumentarTasa() {\nduplicarTasa();\n}\n\n//m\u00e9todos privados de instancia\nprivate double duplicarTasa() {\nreturn TASA_DE_IMPUESTO * 2;\n}\n\n//m\u00e9todos est\u00e1ticos\nstatic double tax(int precio) {\nmostrarPrecio(precio);\nreturn TASA_DE_IMPUESTO * precio;\n}\n\n//m\u00e9todos privados est\u00e1ticos\nprivate static void mostrarPrecio(int precio) {\nSystem.out.println(\"El precio es \" + precio);\n}\n\n}\n</code></pre>"},{"location":"ud5/6abstraccion/","title":"Abstracci\u00f3n","text":"<p>La abstracci\u00f3n es un proceso de ocultar los detalles de implementaci\u00f3n y mostrar solo la funcionalidad al usuario.</p> <p>De otra manera, muestra solo las cosas esenciales para el usuario y oculta los detalles internos.</p> <p>Una clase abstracta es una clase que no se puede instanciar pero que puede ser el padre de otras clases. Esto es \u00fatil, por ejemplo, cuando tenemos un concepto abstracto o amplio como Veh\u00edculo o Animal pero en realidad los objetos reales ser\u00edan tipos espec\u00edficos como Coche, Avi\u00f3n, Perro, etc.</p> <p>Aunque no se puede instanciar, una clase abstracta define m\u00e9todos y variables que heredan las clases hijas.</p>"},{"location":"ud5/6abstraccion/#como-crear-una-clase-abstracta","title":"C\u00f3mo crear una clase abstracta","text":"<p>Para crear una clase abstracta en IntelliJ, haremos lo siguiente:</p> <ol> <li>Bot\u00f3n derecho en el paquete de nuestra aplicaci\u00f3n --&gt; New ---&gt; Java class y a\u00f1adimos la palabra reservada <code>abstract</code>:</li> </ol> <p></p>"},{"location":"ud5/6abstraccion/#metodos-abstractos","title":"M\u00e9todos abstractos","text":"<p>Las clases abstractas pueden opcionalmente contener m\u00e9todos abstractos. Tambi\u00e9n pueden contener m\u00e9todos no abstractos, que ser\u00e1n heredados por los hijos.</p> <p>Un m\u00e9todo abstracto no tiene cuerpo. (No tiene c\u00f3digo). Solo se escribe la signatura del m\u00e9todo con la palabra reservada abstract.</p> <p>Vamos a crear una clase abstracta <code>Animal</code>:</p> <p></p> <p>Si ahora creamos una clase hija que herede de <code>Animal</code> obtendremos un error:</p> <p></p> <p>Esto es debido a que una clase hija no abstracta hereda el m\u00e9todo o los m\u00e9todos abstractos del padre y debe desarrollarlos como m\u00e9todos no abstractos, es decir, con c\u00f3digo. Si no lo hace debe declararse como abstracta.</p> <p>Un hijo abstracto de un padre abstracto no tiene que definir m\u00e9todos no abstractos para los m\u00e9todos abstractas que hereda. Esto significa que puede haber varios pasos entre una clase base abstracta y una clase secundaria que no es completamente abstracta.</p> <p></p> <p></p> <p>No todo lo definido en una clase abstracta debe ser abstracto. Sin embargo, si una clase contiene incluso un m\u00e9todo abstracto, entonces la clase en s\u00ed debe declararse abstracta.</p> <p>Si a\u00f1adimos otra clase hija <code>Ave</code> que hereda de <code>Animal</code> y le agregamos un m\u00e9todo abstracto. El IntelliJ nos muestra un error.</p> <p></p> <p>Tenemos que crear la clase como abstracta, ya que contiene un m\u00e9todo abstracto.</p> <p>Una vez creada la clase <code>Ave</code> como abstracta podr\u00edamos heredar de ella y crear clases hijas que implementar\u00e1n el m\u00e9todo abstracto volar:</p> <p></p> <p>Las clases abstractas se utilizan para organizar programas. Agrupar las clases es importante para mantener un programa organizado y comprensible.</p> <p>La ventaja de usar una clase abstracta es que puede agrupar varias clases relacionadas como hermanas.</p> <p>Aunque no se puedan instanciar las clases abstractas tambi\u00e9n poseen constructores. La mayor\u00eda de las veces se utilizan cuando quieres realizar alguna inicializaci\u00f3n de los campos de la clase abstracta antes de la instanciaci\u00f3n de una clase hija.</p> <p>Warning</p> <p>Cuando se invoca un m\u00e9todo, es la clase del objeto (no de la variable) la que determina qu\u00e9 m\u00e9todo se ejecuta.</p>"},{"location":"ud5/6abstraccion/#interfaces-vs-clases-abstractas","title":"Interfaces vs Clases abstractas","text":"<ul> <li>Las clases abstractas pueden tener variables de instancia (atributos) que se heredan, al contrario que las interfaces, que no permiten definir variables solo constantes est\u00e1ticas.</li> <li>Ni las interfaces ni las clases abstractas se puede instanciar.</li> <li>Las interfaces no pueden tener constructores y las clases abstractas si.</li> <li>Todos los m\u00e9todos definidos en una interfaz son por defecto p\u00fablicos y abstractos, mientras que, en un clase abstracta podemos tener m\u00e9todos con diferentes visibilidades (<code>public</code>, <code>private</code> o <code>protected</code>) y abstractos o con cuerpo.</li> <li>Si implementas una interfaz debes sobreescribir todos sus m\u00e9todos, si heredas de una clase abstractas solo est\u00e1s obligado a sobreescribir los m\u00e9todos abstractos.</li> </ul>"},{"location":"ud5/7exceptions/","title":"Excepciones","text":"<p>Una excepci\u00f3n es un evento que ocurre durante la ejecuci\u00f3n de una aplicaci\u00f3n e interrumpe el flujo normal de las instrucciones del programa.</p> <p></p> <p>Class Exception y class Error extienden Throwable. Un m\u00e9todo Java puede \"lanzar\" un objeto de clase Throwable.</p> <p>Las excepciones son diferentes de los errores porque se pueden escribir programas para recuperarse de excepciones, pero no se pueden escribir programas para recuperarse de errores.</p> <p>Las excepciones pueden ser detectadas por una parte del programa que intenta recuperarse del problema.</p> <p>En Java, hay dos tipos de excepciones:</p> <ul> <li>Checked exceptions (Excepciones verificadas).</li> <li>Unchecked exceptions (Excepciones no verificadas).</li> </ul>"},{"location":"ud5/7exceptions/#checked-exceptions","title":"Checked exceptions","text":"<p>Estas son las excepciones que se comprueban en tiempo de compilaci\u00f3n, es decir, un m\u00e9todo debe hacer algo al respecto sino el programa no compila. Si alg\u00fan c\u00f3digo dentro de un m\u00e9todo arroja una excepci\u00f3n verificada, entonces el m\u00e9todo puede:</p> <ol> <li>manejar la excepci\u00f3n en un bloque <code>try-catch{}</code>, o</li> <li><code>throws</code> (lanzar) la excepci\u00f3n al que invoca el m\u00e9todo.</li> </ol> <pre><code>public void leerFichero(String[] a) throws IOException {\n//c\u00f3digo java\n}\n</code></pre> <p>En el ejemplo, <code>IOException</code> es una checked exception. Este m\u00e9todo lanza una IOException cuando hay un problema de lectura.</p> <p>La palabra reservada <code>throws</code> dice que este m\u00e9todo no captura la excepci\u00f3n <code>IOException</code> con un <code>catch</code>, sino que cuando ocurra una, se lanzar\u00e1 a la persona que llama el m\u00e9todo <code>leerFichero</code>.</p> <p>Si hici\u00e9ramos esto en un m\u00e9todo <code>main</code>, como por ejemplo:</p> <pre><code>public static void main(String[] args) throws IOException {\n//c\u00f3digo java\n\n}\n</code></pre> <p>La excepci\u00f3n se lanzar\u00e1 al Java runtime system. El sistema de tiempo de ejecuci\u00f3n de Java detecta las excepciones que se le han lanzado e imprime un mensaje y un seguimiento de la pila utilizando los datos de la excepci\u00f3n.</p>"},{"location":"ud5/7exceptions/#unchecked-exceptions","title":"Unchecked exceptions","text":"<p>Ocurren en tiempo de compilaci\u00f3n, es decir, no se verifican por el compilador. En Java, las excepciones en las clases RunTimeException y Error y sus subclases son unchecked exceptions todo lo dem\u00e1s es es checked.</p> <p>Depende de los programadores especificar o detectar las excepciones unchecked. Por ejemplo, imagina que tenemos el siguiente programa Java se compila sin erorres:</p> <pre><code>public static void main(String[] args) {\nint x = 0;\nint y = 10;\nint z = y / x;\n}\n</code></pre> <p>El compilador nos deja compilar la aplicaci\u00f3n porque <code>ArithmeticException</code> es una excepci\u00f3n no verificada, pero al ejecutar el programa se lanza la excepci\u00f3n, por tanto, nosotros tendremos que darnos cuenta y controlar este tipo de excepciones.</p>"},{"location":"ud5/7exceptions/#diferencias-entre-checked-y-unchecked-exceptions","title":"Diferencias entre checked y unchecked exceptions","text":"<ul> <li>Una checked exception se detecta en tiempo de compilaci\u00f3n, mientras que una unchecked exception en tiempo de ejecuci\u00f3n.</li> <li>Una checked exception debe manejarse o bien con volvi\u00e9ndola a lanzar con un <code>throw</code> o con un bloque <code>try catch</code>, mientras que una unchecked exception no requiere ser manejada.</li> <li>Una unchecked exception es un error de programaci\u00f3n y es fatal, mientras que una checked exception es una condici\u00f3n de excepci\u00f3n dentro de la l\u00f3gica de su c\u00f3digo y se puede recuperar o volver a intentar.</li> </ul>"},{"location":"ud5/7exceptions/#throwable","title":"Throwable","text":"<p><code>Throwable</code> es la superclase de todas las excepciones y errores. Se podria capturar en un bloque <code>try-catch</code>, \u00a1pero nunca se debe hacer!, ya que, no solo capturar\u00e1 todas las excepciones; sino que tambi\u00e9n har\u00e1 lo mismo con todos los errores que genere la aplicacion.</p> <p>La JVM arroja errores para indicar problemas graves que no est\u00e1n destinados a ser manejados por una aplicaci\u00f3n.</p> <p>Ejemplos t\u00edpicos de eso son <code>OutOfMemoryError</code> o <code>StackOverflowError</code>. Ambos son causados por situaciones que est\u00e1n fuera del control de la aplicaci\u00f3n y no se pueden manejar.</p> <p>Por lo tanto, es mejor que NUNCA captures un Throwable.</p>"},{"location":"ud5/7exceptions/#excecpciones-personalizadas","title":"Excecpciones personalizadas","text":"<p>Aunque las excepciones de Java cubren casi todas las excepciones generales que est\u00e1n obligadas a ocurrir en la programaci\u00f3n. Sin embargo, a veces necesitamos complementar estas excepciones est\u00e1ndar con las nuestras.</p> <p>Estas son las principales razones para introducir excepciones personalizadas:</p> <ul> <li>A\u00f1adir excepciones que son espec\u00edficas de la l\u00f3gica de nuestra aplicaci\u00f3n o empresa. \u00c9stas ayudan a los usuarios de la aplicaci\u00f3n o a los desarrolladores a comprender cu\u00e1l es el problema exacto.</li> <li>Para capturar y proporcionar un tratamiento espec\u00edfico a un subconjunto de excepciones de Java existentes.</li> <li>A\u00f1adir nuevos m\u00e9todos o atributos que no son parte de las excepciones est\u00e1ndar.</li> </ul>"},{"location":"ud5/7exceptions/#buenas-practicas-para-definir-excepciones-personalizadas","title":"Buenas pr\u00e1cticas para definir excepciones personalizadas","text":""},{"location":"ud5/7exceptions/#haz-que-tenga-sentido","title":"Haz que tenga sentido","text":"<p>Proporciona informaci\u00f3n o funcionalidad que no forma parte de las excepciones est\u00e1ndar de Java.</p> <p>Esa es la esencia de la primera y m\u00e1s importante recomendaci\u00f3n. De lo contrario, su excepci\u00f3n no brinda ning\u00fan beneficio en comparaci\u00f3n con la gran cantidad de excepciones que ya proporciona el JDK.</p> <p>Si no puede proporcionar ning\u00fan beneficio, es mejor que use una de las excepciones est\u00e1ndar, como UnsupportedOperationException o IllegalArgumentException. Todos los desarrolladores de Java ya conocen estas excepciones. Eso hace que su c\u00f3digo y API sean m\u00e1s f\u00e1ciles de entender.</p>"},{"location":"ud5/7exceptions/#sigue-la-convencion-de-nomenclatura-estandar","title":"Sigue la convenci\u00f3n de nomenclatura est\u00e1ndar","text":"<p>Cuando obsevamos las clases de excepci\u00f3n proporcionadas por el JDK, r\u00e1pidamente nos damos cuenta que todos sus nombres terminan con <code>Exception</code>. Esta convenci\u00f3n de nomenclatura general se utiliza en todo el sistema de Java. Y su excepci\u00f3n personalizada tambi\u00e9n deber\u00eda seguirlo, por ejemplo, <code>ImpresoraException</code>.</p>"},{"location":"ud5/7exceptions/#anade-javadoc-a-tu-clase-de-excepcion-personalizada","title":"A\u00f1ade Javadoc a tu clase de excepci\u00f3n personalizada","text":"<p>Las API no documentadas son muy dif\u00edciles de usar.</p> <p>Las clases de excepci\u00f3n pueden no ser la parte m\u00e1s obvia de tu API, pero siguen siendo parte de ella. Tan pronto como uno de sus m\u00e9todos orientados al cliente arroja una excepci\u00f3n, la clase de excepci\u00f3n se convierte en parte de la API. Eso implica que requiere documentaci\u00f3n y un buen Javadoc.</p> <p>El Javadoc debe describir el significado general de la excepci\u00f3n y las situaciones en las que podr\u00eda ocurrir. El objetivo es ayudar a otros desarrolladores a comprender su API y evitar escenarios de error comunes.</p>"},{"location":"ud5/7exceptions/#proporciona-un-constructor","title":"Proporciona un constructor","text":"<p>Normalmente, nuestro c\u00f3digo detectar\u00e1 una excepci\u00f3n est\u00e1ndar antes de lanzar nuestra excepci\u00f3n personalizada. Esto, no debe ocultarse ya que la excepci\u00f3n capturada generalmente contendr\u00e1 informaci\u00f3n esencial que necesitaremos para analizar el incidente.</p> <p>En el siguiente ejemplo, <code>NumberFormatException</code> proporciona informaci\u00f3n detallada sobre el error. Perder\u00e1 esta informaci\u00f3n si no la configura como la causa de <code>MyException</code>.</p> <pre><code>public void methodA(String entrada) throws MyException {\ntry {\n// c\u00f3digo\n} catch (NumberFormatException e) {\nthrow new MyException(\"Mensaje que describe el error.\", e, ErrorCode.INVALID_ENTRY);\n}\n}\n</code></pre> <p><code>Exception</code> y <code>RuntimeException</code> proporcionan constructores que aceptan un <code>Throwable</code> que describe la causa de la excepci\u00f3n. Por tanato, nuestra excepci\u00f3n deber\u00eda hacer lo mismo. Debemos implementar al menos un constructor que obtenga el Throwable causante como par\u00e1metro y lo establezca en la superclase.</p>"},{"location":"ud5/7exceptions/#pasos-para-implementar-una-excepcion-personalizada","title":"Pasos para implementar una excepci\u00f3n personalizada","text":"<ol> <li>Debemos extender de la clase <code>java.lang.Exception</code>.</li> <li>Se debe proporcionar un constructor que establezca la excepci\u00f3n causante y brinde un beneficio en comparaci\u00f3n con las excepciones est\u00e1ndar disponibles.</li> </ol> <p>Ejemplo:</p> <p></p> <p></p> <p><code>MyException</code> usa un enum personalizado para almacenar un c\u00f3digo de error que identifica el problema de nuestra aplicaci\u00f3n. Los clientes pueden usar el c\u00f3digo de error para mostrar mensajes de error localizados o decirle al usuario que incluya este c\u00f3digo en un ticket de soporte.</p> <p>Para usar <code>MyException</code> en nuestra aplicaci\u00f3n o programa necesitaremos especificarlo como parte de la signatura de un m\u00e9todo o simplemente capturarla con un bloque <code>try-catch</code>.</p> <p></p> <p>Note</p> <p>Si queremos crear una excepci\u00f3n personalizada de tipo unchecked exception realizaremos el mismo procedimiento con la diferencia de que tendremos que extender de la clase <code>java.lang.RuntimeException</code>.</p>"},{"location":"ud6/1list/","title":"Estructuras de datos","text":"<p>La estructura de datos es una forma de almacenar y organizar datos de manera eficiente, de modo que las operaciones requeridas en ellos se puedan realizar de manera eficiente con respecto al tiempo y la memoria. Simplemente, la estructura de datos se utiliza para reducir la complejidad (principalmente la complejidad del tiempo) del c\u00f3digo.</p> <p>Las estructuras de datos pueden ser de dos tipos:</p> <ol> <li>Estructura de datos est\u00e1tica</li> <li>Estructura de datos din\u00e1mica</li> </ol>"},{"location":"ud6/1list/#estructuras-de-datos-estaticos","title":"Estructuras de datos est\u00e1ticos","text":"<p>En la estructura de datos est\u00e1tica, el tama\u00f1o de la estructura es fijo. El contenido de la estructura de datos se puede modificar pero sin cambiar el espacio de memoria que se le asigna. Un ejemplo de estas estructuras son los arrays que vimos en la unidad 4.</p> <p>Aunque los arrays son muy \u00fatiles como hemos estudiado, si queremos redimensionar un array, es decir, cambiar su tama\u00f1o una vez lo hemos creado y preservar los valores que se encuentran en \u00e9l la \u00fanica forma de hacerlo ser\u00eda creando un nuevo array y copiar los elementos a este nuevo array. Hacer esto cada vez que queremos redimensionar el tama\u00f1o de un array es muy tedioso y no es nada productivo.</p>"},{"location":"ud6/1list/#estructuras-de-datos-dinamicas","title":"Estructuras de datos din\u00e1micas","text":"<p>En la estructura de datos din\u00e1mica, el tama\u00f1o de la estructura no es fijo y puede modificarse durante las operaciones realizadas en \u00e9l. Las estructuras de datos din\u00e1micas est\u00e1n dise\u00f1adas para facilitar el cambio en tiempo de ejecuci\u00f3n.</p> <p>Documentaci\u00f3n oficial Collections Java</p>"},{"location":"ud6/1list/#list","title":"List","text":"<p>Una lista se puede ver como un array ya que es una secuencia de elementos o colecci\u00f3n ordenada que te permite tener elementos en posiciones consecutivas.</p> <p>En Java <code>List</code> es una interfaz Java.util.List que exitende de <code>Collection</code>. Siempre conserva el orden de los elementos. Los elementos contenidos en una lista se pueden insertar, acceder, iterar y eliminar de acuerdo con el orden en que aparecen internamente en la lista. El orden de los elementos es la raz\u00f3n por la cual esta estructura de datos se llama <code>List</code>. Cada elemento en una lista de Java tiene un \u00edndice, al igual que ocurr\u00eda con los arrays.</p> <p>La interfaz de lista se implementa mediante las clases <code>ArrayList</code>, <code>LinkedList</code>, <code>Vector</code> y <code>Stack</code>. Es decir, dado que <code>List</code> es una interfaz, no se puede crear una instancia directamente. Sin embargo, uno puede crear objetos de aquellas clases que han implementado esta interfaz e instanciarlos. Por ejemplo:</p> <pre><code>List a = new ArrayList();\nList b = new LinkedList();\nList c = new Vector(); List d = new Stack(); </code></pre> <p>De estas implementaciones, <code>ArrayList</code> es la m\u00e1s utilizada.</p>"},{"location":"ud6/1list/#arraylist","title":"ArrayList","text":"<p>La primera clase de la que vamos a hablar es <code>ArrayList</code>. Un <code>ArrayList</code> como su nombre indica basa su implementaci\u00f3n de una lista en un array. Es un array din\u00e1mico en tama\u00f1o (es decir, de tama\u00f1o variable), pudiendo agrandarse el n\u00famero de elementos o disminuirse de forma autom\u00e1tica. Implementa todos los m\u00e9todos de la interfaz List y permite incluir elementos null.</p> <p>Un <code>ArrayList</code> no permite almacenar tipos de datos primitivos, solo puede almacenar objetos. Al contrario que un array que permit\u00eda almacenar ambos. Sin embargo, desde Java 5, las primitivas se convierten autom\u00e1ticamente en objetos, gracias a los Wrappers.</p> <p><code>ArrayList</code> forma parte de <code>Collection</code> en Java. Por lo tanto, a diferencia de los arrays que para acceder a los elementos se hac\u00eda usando [], en <code>ArrayList</code> tenemos un  conjunto de m\u00e9todos para acceder a los elementos y modificarlos.</p>"},{"location":"ud6/1list/#crear-un-arraylist","title":"Crear un <code>ArrayList</code>","text":"<p>Para crear un <code>ArrayList</code> en IntelliJ escribimos:</p> <p></p> <p>Si nos fijamos nos aparece una <code>&lt;E&gt;</code>, esto quiere decir que cuando creamos un <code>ArrayList</code> no le estamos diciendo el tipo como hac\u00edamos con los arrays: <code>int[] array;</code>. Por tanto, para crear un <code>ArrayList</code> que almacena objetos necesitamos decirle qu\u00e9 tipo de datos vamos a almacenar en nuestra lista.</p> <p></p> <p>En el ejemplo hemos creado una lista que contendr\u00e1 elementos de tipo <code>String</code>. Y si nos fijamos no le hemos especificado ning\u00fan tama\u00f1o como hac\u00edamos en los arrays puesto que Java maneja el tama\u00f1o por nosotros autom\u00e1ticamente.</p>"},{"location":"ud6/1list/#anadir-item-al-arraylist","title":"A\u00f1adir \u00edtem al <code>ArrayList</code>","text":"<p>Para agregar un \u00edtem o elemento a la lista utilizaremos los m\u00e9todos que nos provee la interfaz <code>List</code>:</p> <p></p> <p>El m\u00e9todo <code>add</code> agrega autom\u00e1ticamente el elemento en la lista. <code>ArrayList</code> es el que tiene toda la funcionalidad sobre d\u00f3nde guardarlo (posici\u00f3n) y cantidad de espacio para asignar. Eso es abstracto para nosotros y no tenemos que preocuparnos por ello.</p>"},{"location":"ud6/1list/#imprimir-los-elementos-del-arraylist","title":"Imprimir los elementos del <code>ArrayList</code>","text":""},{"location":"ud6/1list/#modificar-un-item-en-una-posicion-del-arraylist","title":"Modificar un \u00edtem en una posici\u00f3n del <code>ArrayList</code>","text":""},{"location":"ud6/1list/#eliminar-un-item-de-un-arraylist","title":"Eliminar un \u00edtem de un <code>ArrayList</code>","text":"<p>El m\u00e9todo remove elimina el elemento de la lista y deja la lista ordenada, es decir, si tuvi\u00e9ramos una lista con los siguientes productos: [\"Leche\", \"Tomate\", \"Lechuga\", \"Carne\"] y elimin\u00e1ramos el producto <code>Tomate</code>, la lista quedar\u00eda: [\"Leche\", \"Lechuga\", \"Carne\"], los \u00edtem se mover\u00edan de posiciones. Todo eso lo hace Java autom\u00e1ticamente por nosotros.</p>"},{"location":"ud6/1list/#copiar-todo-el-contenido-del-un-arraylist-a-otro","title":"Copiar todo el contenido del un <code>ArrayList</code> a otro","text":"<p>Se puede hacer de varias formas:</p> <pre><code>//Forma 1\nArrayList&lt;String&gt; newArray = new ArrayList&lt;String&gt;();\nnewArray.addAll(productosList);\n\n//Forma 2\nArrayList&lt;String&gt; newArray2 = new ArrayList&lt;String&gt;(productosList);\n\n//Forma 3 - Copiar un ArrayList a un array\nString[] myArray = new String[productosList.size()];\nmyArray = productosList.toArray(myArray);\n</code></pre>"},{"location":"ud6/1list/#buscar-un-item-en-el-arraylist","title":"Buscar un \u00edtem en el <code>ArrayList</code>","text":""},{"location":"ud6/1list/#comprobar-si-existe-un-item-en-el-arraylist","title":"Comprobar si existe un \u00edtem en el <code>ArrayList</code>","text":"<pre><code>public class ProductList {\n\nprivate ArrayList&lt;String&gt; productosList = new ArrayList&lt;String&gt;();\n\npublic void addProduct(String item) {\nproductosList.add(item);\n}\n\npublic void printProductList() {\nSystem.out.println(\"Tenemos \"  + productosList.size() + \" elementos en el arrayList\");\nfor(int i = 0; i &lt; productosList.size(); i++) {\nSystem.out.println(productosList.get(i));\n}\n}\n\npublic void modifyProductItem(int index, String newItem) {\nproductosList.set(index, newItem);\n}\n\npublic void removeProductItem(int index) {\nString item = productosList.get(index);\nproductosList.remove(item);\n}\n\npublic boolean existsItem(String searchItem) {\nreturn productosList.contains(searchItem);\n}\n\npublic String findItem(String searchItem) {\nint index = productosList.indexOf(searchItem);\nif (index &gt;= 0) {\nreturn productosList.get(index);\n}\nreturn null;\n}\n}\n</code></pre>"},{"location":"ud6/1list/#main","title":"Main","text":"<p>Vamos a crear una clase principal <code>Main</code> con un m\u00e9todo <code>main</code>que imprimir\u00e1 un men\u00fa de opciones relacionadas con la lista de productos y realizar\u00e1 sus respectivas acciones.</p> <pre><code>public class MainList {\n\nprivate static Scanner scanner = new Scanner(System.in);\nprivate static ProductList productList = new ProductList();\n\npublic static void imprimirMenu() {\nSystem.out.println(\"0 - Para imprimir menu\");\nSystem.out.println(\"1 - Para imprimir productos\");\nSystem.out.println(\"2 - Para a\u00f1adir\");\nSystem.out.println(\"3 - Para modificar\");\nSystem.out.println(\"4 - Para eliminar\");\nSystem.out.println(\"5 - Para salir\");\n}\n\npublic static void addItem() {\nSystem.out.println(\"Inserta el producto: \");\nproductList.addProduct(scanner.nextLine());\n}\n\npublic static void modifyItem() {\nSystem.out.println(\"Inserta n\u00famero de posici\u00f3n: \");\nint index = scanner.nextInt();\nscanner.nextLine();\nSystem.out.println(\"Escribe el nuevo producto:\");\nString newItem = scanner.nextLine();\nproductList.modifyProductItem(index, newItem);\n}\n\npublic static void removeItem() {\nSystem.out.println(\"Inserta n\u00famero de posici\u00f3n: \");\nint index = scanner.nextInt();\nscanner.nextLine();\nproductList.removeProductItem(index);\n}\n\npublic static void main(String[] args) {\nboolean continuar = true;\nint opcion = 0;\nimprimirMenu();\n\nwhile(continuar) {\nSystem.out.println(\"Elige una opci\u00f3n: \");\nopcion = scanner.nextInt();\nscanner.nextLine();\n\nswitch (opcion) {\ncase 0:\nimprimirMenu();\nbreak;\ncase 1:\nproductList.printProductList();\nbreak;\ncase 2:\naddItem();\nbreak;\ncase 3:\nmodifyItem();\nbreak;\ncase 4:\nremoveItem();\nbreak;\ncase 5:\ncontinuar = false;\nbreak;\n}\n}\n}\n}\n</code></pre>"},{"location":"ud6/1list/#buenas-practicas","title":"Buenas pr\u00e1cticas","text":"<p>Si nos fijamos, el m\u00e9todo para modificar un \u00edtem de la lista espera recibir un \u00edndice o posici\u00f3n donde se encuentra el elemento. Pero eso puede se peligroso, puesto que, sabemos que las posiciones empiezan por 0, pero a lo mejor el usuario no lo sabe y piensan que empiezan por 1. Por tanto, no sabemos a qu\u00e9 posici\u00f3n apunta realmente el \u00edndice que recibimos.</p> <p>Una buena pr\u00e1ctica es crear otro m\u00e9todo que se le pase el nombre, buscarlo y devolver la posici\u00f3n en la lista:</p> <pre><code>public void modifyProductItem(String newItem) {\nint index = findItem(newItem);\nif (index &gt;= 0) {\nmodifyProductItem(index, newItem);\n}\n}\n\nprivate void modifyProductItem(int index, String newItem) {\nproductosList.set(index, newItem);\n}\n\npublic int findItem(String searchItem) {\nreturn productosList.indexOf(searchItem);\n}\n</code></pre> <p>Ejercicio. Haz lo mismo con el m\u00e9todo de eliminar elemento.</p>"},{"location":"ud6/2linkedlist/","title":"<code>LinkedList</code>","text":"<p>Una <code>LinkedList</code> en Java es una implementaci\u00f3n de lista doblemente enlazada. Admite duplicados.</p> <p>Cada elemento de la lista almacena el enlace real al siguiente elemento de la lista as\u00ed como tambi\u00e9n el valor real que se desea almacenar.</p> <p><code>LinkedList</code> no es un array, sino una cola de dos extremos de elementos conectados entre s\u00ed. El primer elemento apunta al segundo, que apunta al tercero, y as\u00ed sucesivamente. Internamente, LinkedList se implementa utilizando la estructura de datos de lista doblemente enlazada. La principal diferencia entre una lista enlazada normal y una lista doblemente enlazada es que una lista doblemente enlazada contiene un puntero adicional, normalmente llamado puntero anterior, junto con el puntero siguiente y los datos que est\u00e1n en la lista enlazada individualmente.</p> <p></p> <p>ArrayList contiene un \u00fanico array para el almacenamiento de datos. LinkedList necesita una estructura de datos personalizada. Esta estructura de datos personalizada es conocida como Nodo. Es una peque\u00f1a clase interna que sirve como envoltorio para cada elemento.</p> <p>El primer puntero conocido como head, apunta al primer nodo y se actualiza cada vez que se inserta un nuevo nodo al principio. El puntero que apunta al \u00faltimo nodo es conocido como tail y tambi\u00e9n se actualiza cada vez que se agrega un nuevo elemento al final.</p>"},{"location":"ud6/2linkedlist/#crear-y-anadir-items-en-una-linkedlist","title":"Crear y a\u00f1adir \u00edtems en una <code>LinkedList</code>","text":"<pre><code>LinkedList&lt;String&gt; lugares = new LinkedList&lt;String&gt;();\nlugares.add(\"Roma\");\nlugares.add(\"Par\u00eds\");\nlugares.add(\"Amsterdam\");\nlugares.add(\"Toronto\");\nlugares.add(\"Miami\");\n</code></pre>"},{"location":"ud6/2linkedlist/#iterar-una-linkedlist","title":"Iterar una <code>LinkedList</code>","text":"<p>Para iterar una lista vamos a usar el concepto de iterador. Un iterador es una forma de acceder a cada uno de los elementos de una lista, arrayList, linkedlist, etc. Es el equivalente a un bucle for que hemos estado usando hasta ahora.</p> <pre><code>public static void printList(LinkedList&lt;String&gt; lugares) {\nIterator&lt;String&gt; it = lugares.iterator();\nwhile (it.hasNext()) {\nSystem.out.println(\"Nodo: \" + it.next());\n}\nSystem.out.println(\"-----\");\n}\n</code></pre> <p><code>i.next()</code>: primero devuelve el nodo actual y luego se mueve al siguiente elemento. Hasta que no usamos .next() no se sit\u00faa en el primer nodo. La primera l\u00ednea de c\u00f3digo solo es para montar y establecer el iterador.</p>"},{"location":"ud6/2linkedlist/#insertar-elementos-en-orden","title":"Insertar elementos en orden","text":"<p>Para insertar elementos en un orden espec\u00edfico se usa un <code>ListIterator</code> ya que proporcionar mayor flexibilidad y est\u00e1 creado para situaciones como esa. Te permite volver a los elementos anteriores.</p> <pre><code>private static boolean addInOrder(LinkedList&lt;String&gt; lugares, String newItem) {\nListIterator&lt;String&gt; it = lugares.listIterator();\nwhile (it.hasNext()) {\nint comparacion = it.next().compareTo(newItem);\nif (comparacion == 0) {\n//no queremos a\u00f1adir porque no queremos tener duplicados\nSystem.out.println(\"el lugar \" + newItem + \" ya est\u00e1 incluido\");\nreturn false;\n} else if (comparacion &gt; 0) { //newItem es m\u00e1s peque\u00f1o\nit.previous();\nit.add(newItem);\nreturn true;\n}\n}\nit.add(newItem);\nreturn true;\n}\n</code></pre>"},{"location":"ud6/2linkedlist/#ejemplo-de-clase-de-visitar-lugares","title":"Ejemplo de clase de Visitar Lugares","text":"<p>Utilizamos un list iterator para ir hacia adelante y hacia atr\u00e1s.</p> <pre><code>public static void visitarLugar(LinkedList&lt;String&gt; lugares) {\nScanner scanner = new Scanner(System.in);\nboolean continuar = true;\nListIterator&lt;String&gt; it = lugares.listIterator();\n\nif (lugares.isEmpty()) {\nSystem.out.println(\"No hay lugares visitados\");\nreturn;\n} else {\nSystem.out.println(\"Visitando \" + it.next());\nimprimirMenu();\n}\n\nboolean haciaAdelante = true;\nwhile(continuar) {\nint opcion = scanner.nextInt();\nscanner.nextLine();\nswitch (opcion) {\ncase 0:\nSystem.out.println(\"Se acabaron las vacaciones\");\ncontinuar = false;\nbreak;\ncase 1:\nif (!haciaAdelante) {\nif (it.hasNext())\nit.next();\nhaciaAdelante = true;\n}\nif (it.hasNext()) {\nSystem.out.println(\"Visitando \" + it.next());\n} else {\nSystem.out.println(\"Ya no hay m\u00e1s ciudades\");\nhaciaAdelante = false;\n}\nbreak;\ncase 2:\nif(haciaAdelante) {\nif (it.hasPrevious())\nit.previous();\nhaciaAdelante = false;\n}\nif (it.hasPrevious()) {\nSystem.out.println(\"Visitando \" + it.previous());\n} else {\nSystem.out.println(\"Primera ciudad\");\nhaciaAdelante = true;\n}\nbreak;\ncase 3:\nimprimirMenu();\nbreak;\n}\n}\n}\n\npublic static void imprimirMenu() {\nSystem.out.println(\"0 - Para salir\\n\" +\n\"1 - para ir a la siguiente ciudad\\n\" +\n\"2 - para ir a la ciudad anterior\\n\" +\n\"3 - imprimir el men\u00fa\");\n}\n</code></pre>"},{"location":"ud6/3innerclass/","title":"Clases anidadas (Nested classes)","text":"<p>En Java, al igual que los m\u00e9todos, las variables de una clase tambi\u00e9n pueden tener otra clase como miembro. Java permite escribir una clase dentro de otra. La clase escrita dentro se denomina clase anidada o clase interna, y la clase que contiene la clase interna se denomina clase externa.</p>"},{"location":"ud6/3innerclass/#sintaxis","title":"Sintaxis","text":"<p>La clase <code>Outer_Demo</code> es la clase externa y la clase <code>Inner_Demo</code> es la clase interna.</p> <pre><code>class Outer_Demo {\nclass Inner_Demo {\n}\n}\n</code></pre> <p>Las clases anidadas se dividen en dos tipos:</p> <ul> <li>Clases anidadas no est\u00e1ticas: son las llamadas clases internas (inner classes).</li> <li>Clases est\u00e1ticas anidadas.</li> </ul> <pre><code>class OuterClass {\n...\nclass InnerClass {\n...\n}\nstatic class StaticNestedClass {\n...\n}\n}\n</code></pre> <p></p> <p>Una clase anidada es un miembro de su clase envolvente. Las clases anidadas no est\u00e1ticas (clases internas) tienen acceso a otros miembros de la clase envolvente, incluso si se declaran como privadas. Las clases anidadas est\u00e1ticas no tienen acceso a otros miembros de la clase envolvente. Como miembro de <code>OuterClass</code>, una clase anidada se puede declarar <code>private</code>, <code>public</code>, <code>protected</code>.</p>"},{"location":"ud6/3innerclass/#por-que-usar-clases-anidadas","title":"\u00bfPor qu\u00e9 usar clases anidadas?","text":"<ol> <li> <p>Es una forma de agrupar l\u00f3gicamente las clases que solo se usan en un lugar: si una clase es \u00fatil solo para otra clase, entonces es l\u00f3gico incrustarla en esa clase y mantener las dos juntas. Anidar tales \"clases de ayuda\" hace que su paquete sea m\u00e1s optimizado.</p> </li> <li> <p>Aumenta la encapsulaci\u00f3n: sabemos que una clase no se puede declarar <code>private</code>, pero si tenemos la clase como miembro de otra clase, entonces la clase interna se puede hacer privada. Y esto tambi\u00e9n se usa para acceder a los miembros privados de una clase.</p> </li> <li> <p>Puede conducir a un c\u00f3digo m\u00e1s legible y mantenible: anidar clases peque\u00f1as dentro de clases de nivel superior coloca el c\u00f3digo m\u00e1s cerca de donde se usa.</p> </li> </ol>"},{"location":"ud6/3innerclass/#clase-interna-inner-class-no-estatica-clase-anidada","title":"Clase Interna (Inner Class) - No est\u00e1tica clase anidada","text":"<p>Al igual que con los m\u00e9todos y variables de instancia, una clase interna est\u00e1 asociada con una instancia de su clase envolvente y tiene acceso directo a los m\u00e9todos y campos de ese objeto. Adem\u00e1s, debido a que una clase interna est\u00e1 asociada con una instancia, no puede definir ning\u00fan miembro est\u00e1tico en s\u00ed misma.</p> <p>Las clases internas son de tres tipos dependiendo de c\u00f3mo y d\u00f3nde se definan:</p> <ol> <li>Clase  - Inner Class</li> <li>Clase interna de m\u00e9todo local - Method-local Inner Class</li> <li>Clase interna an\u00f3nima - Anonymous Inner Class</li> </ol>"},{"location":"ud6/3innerclass/#inner-class","title":"Inner class","text":"<p>Crear una clase interna es bastante simple. Solo hay que escribir una clase dentro de una clase. A diferencia de una clase, una clase interna puede ser privada y una vez que declaras privada una clase interna, no se puede acceder a ella desde un objeto fuera de la clase.</p> <p>Los objetos que son instancias de una clase interna existen dentro de una instancia de la clase externa.</p> <pre><code>class OuterClass {\n\nprivate int num = 32;\n\nclass InnerClass {\n\npublic int getNum() {\nreturn num;\n}\n\n}\n}\n\npublic class Main {\n\npublic static void main(String args[]) {\nOuterClass outer = new OuterClass();\n\nOuterClass.InnerClass inner = outer.new InnerClass();\nSystem.out.println(inner.getNum());\n}\n}\n</code></pre> <p>Una instancia de <code>InnerClass</code> solo puede existir dentro de una instancia de <code>OuterClass</code> y tiene acceso directo a los m\u00e9todos y campos de su instancia adjunta.</p> <p>Para instanciar una clase interna, primero debe instanciar la clase externa.</p>"},{"location":"ud6/3innerclass/#clase-interna-de-metodo-local","title":"Clase interna de m\u00e9todo local","text":"<p>En Java, podemos escribir una clase dentro de un m\u00e9todo y esta ser\u00e1 de tipo local. Al igual que las variables locales, el alcance de la clase interna est\u00e1 restringido dentro del m\u00e9todo.</p> <p>Una clase interna local de m\u00e9todo solo se puede instanciar dentro del m\u00e9todo donde se define la clase interna.</p> <pre><code>public class Outerclass {\n\nvoid my_Method() {\nint num = 23;\n\n// method-local inner class\nclass MethodInner_Demo {\npublic void print() {\nSystem.out.println(\"This is method inner class \"+num);\n}   } // end of inner class\n\n// Accessing the inner class\nMethodInner_Demo inner = new MethodInner_Demo();\ninner.print();\n}\n\npublic static void main(String args[]) {\nOuterclass outer = new Outerclass();\nouter.my_Method();\n}\n}\n</code></pre>"},{"location":"ud6/3innerclass/#clase-interna-anonima","title":"Clase interna an\u00f3nima","text":"<p>Una clase interna declarada sin un nombre de clase se conoce como clase interna an\u00f3nima. En el caso de clases internas an\u00f3nimas, las declaramos y las instanciamos al mismo tiempo. Por lo general, se utilizan siempre que necesite anular el m\u00e9todo de una interfaz o clase abstracta.</p> <p>Las clases an\u00f3nimas permiten hacer el c\u00f3digo m\u00e1s conciso. Permiten declarar e instanciar una clase al mismo tiempo. Son como clases locales excepto que no tienen nombre. Se usa si se necesita usar una clase local solo una vez.</p>"},{"location":"ud6/3innerclass/#ejemplo-1","title":"Ejemplo 1","text":"<pre><code>interface Greeting {\npublic void greet();\npublic void greetSomeone(String someone);\n}\n\nclass Main {\npublic static void main(String[] args) {\n//Anonymous class\nGreeting frenchGreeting = new Greeting() {\nString name = \"tout le monde\";\npublic void greet() {\ngreetSomeone(\"tout le monde\");\n}\npublic void greetSomeone(String someone) {\nname = someone;\nSystem.out.println(\"Salut \" + name);\n}\n};\n}\n}\n</code></pre>"},{"location":"ud6/3innerclass/#ejemplo-2","title":"Ejemplo 2","text":"<pre><code>abstract class AnonymousInner {\npublic abstract void mymethod();\n}\n\npublic class OuterClass {\n\npublic static void main(String args[]) {\n\nAnonymousInner inner = new AnonymousInner() {\npublic void mymethod() {\nSystem.out.println(\"This is an example of anonymous inner class\");\n}\n};\ninner.mymethod();\n}\n}\n</code></pre>"},{"location":"ud6/3innerclass/#clases-anidadas-estaticas","title":"Clases Anidadas Est\u00e1ticas","text":"<p>Una clase interna est\u00e1tica es una clase anidada que es un miembro est\u00e1tico de la clase externa. Se puede acceder a ella sin instanciar la clase externa, usando otros miembros est\u00e1ticos. Al igual que los miembros est\u00e1ticos, una clase anidada est\u00e1tica no tiene acceso a las variables de instancia ni a los m\u00e9todos de la clase externa.</p> <pre><code>class MyOuter {\nstatic class NestedDemo {\n}\n}\n</code></pre> <p>Crear una instancia de una clase anidada est\u00e1tica es un poco diferente de crear una instancia de una clase interna.</p> <pre><code>class Outer {\nprivate int x = 0;\n\nstatic class Inner {\nprivate int y = 9;\n\npublic int getY() {\nreturn y;\n}\n}\n}\npublic class StaticNestedClass {\npublic static void main(String[] args) {\nOuter.Inner inner = new Outer.Inner();\nSystem.out.println(inner.getY());\n}\n}\n</code></pre>"},{"location":"ud6/3innerclass/#ejemplo-combinado-clase-interna-y-clase-estatica-interna","title":"Ejemplo combinado Clase interna y clase est\u00e1tica interna","text":"<pre><code>class OuterClass {\n\nprivate String outerField = \"Outer field\";\nprivate static String staticOuterField = \"Static outer field\";\n\nclass InnerClass {\nvoid accessMembers() {\nSystem.out.println(outerField);\nSystem.out.println(staticOuterField);\n}\n}\n\nstatic class StaticNestedClass {\nvoid accessMembers(OuterClass outer) {\n// Compiler error: Cannot make a static reference to the non-static\n//     field outerField\n//System.out.println(outerField);\nSystem.out.println(outer.outerField);\nSystem.out.println(staticOuterField);\n}\n}\n\npublic static void main(String[] args) {\nSystem.out.println(\"Inner class:\");\nSystem.out.println(\"------------\");\nOuterClass outerObject = new OuterClass();\nOuterClass.InnerClass innerObject = outerObject.new InnerClass();\ninnerObject.accessMembers();\n\nSystem.out.println(\"\\nStatic nested class:\");\nSystem.out.println(\"--------------------\");\nStaticNestedClass staticNestedObject = new StaticNestedClass();\nstaticNestedObject.accessMembers(outerObject);\n}\n}\n</code></pre>"},{"location":"ud6/4map/","title":"Map","text":"<p>Aunque las estructura de datos <code>Map</code> no forma parte dentro de la jerarqu\u00eda de la interfaz <code>Collection</code>, se considera una interfaz de colecci\u00f3n principal de Java Collections Framework.</p> <p></p> <p>Un <code>Map</code> es un objeto que asigna claves a valores. Un mapa no puede contener claves duplicadas: cada clave puede asignarse a un valor como m\u00e1ximo. Sin embargo, los valores asignados a la clave pueden tener valores duplicados. La interfaz <code>Map</code> incluye m\u00e9todos para operaciones b\u00e1sicas (como put, get, remove, containsKey, containsValue, size, y empty) entre muchos otros.</p> <p></p> <p>La plataforma Java contiene tres implementaciones de <code>Map</code>: <code>HashMap</code>, <code>TreeMap</code> y <code>LinkedHashMap</code>.</p>"},{"location":"ud6/4map/#crear-un-mapa","title":"Crear un Mapa","text":"<p>Para crear un objeto <code>Map</code> podemos usar cualquiera de las implementaciones para esta interfaz (<code>HashMap</code>, <code>TreeMap</code> y <code>LinkedHashMap</code>), por ejemplo:</p> <pre><code>Map&lt;String, String&gt; idiomas = new HashMap&lt;&gt;();\n</code></pre>"},{"location":"ud6/4map/#anadir-claves-y-valores-en-un-mapa","title":"A\u00f1adir claves y valores en un mapa","text":"<p>Para a\u00f1adir un par de clave-valor al mapa usamos el m\u00e9todo <code>put</code>:</p> <pre><code>public class MainMap {\n\npublic static void main(String[] args) {\nMap&lt;String, String&gt; idiomas = new HashMap&lt;&gt;();\nidiomas.put(\"es\", \"Espa\u00f1ol\");\nidiomas.put(\"en\", \"English EEUU\");\nidiomas.put(\"ca\", \"English Canad\u00e1\");\nidiomas.put(\"de\", \"Aleman\");\nidiomas.put(\"fr\", \"Franc\u00e9s\");\nidiomas.put(\"it\", \"Italian\");\n}\n}\n</code></pre> <p>Las claves de los mapas son \u00fanicas, si intentamos a\u00f1adir un nuevo valor para una clave que ya existe, el valor es sobreescrito.</p> <p>Para saber si estamos agregando una nueva clave o solo modificando el valor, el m\u00e9todo <code>put</code> nos ayuda, ya que devuelve el valor anterior asociado con la clave, o <code>null</code> si no hubo asignaci\u00f3n para la clave antes.</p> <p>Ejemplo:</p> <pre><code>Map&lt;String, String&gt; idiomas = new HashMap&lt;&gt;();\n\nidiomas.put(\"es\", \"Espa\u00f1ol\");\nidiomas.put(\"en\", \"English EEUU\");\nidiomas.put(\"ca\", \"English Canad\u00e1\");\nidiomas.put(\"de\", \"Aleman\");\nidiomas.put(\"fr\", \"Franc\u00e9s\");\nSystem.out.println(idiomas.put(\"it\", \"Italian\")); //devuelve null\nSystem.out.println(idiomas.put(\"it\", \"Italiano\")); //devuelve el valor previo \"Italian\", lo que significa que se ha sobreescrito\n</code></pre>"},{"location":"ud6/4map/#obtener-el-valor-para-una-clave","title":"Obtener el valor para una clave","text":"<p>Para obtener el valor asociado a una clave usamos el m\u00e9todo <code>get</code>:</p> <pre><code>String valor = idiomas.get(\"it\");\n</code></pre>"},{"location":"ud6/4map/#comprobar-si-una-clave-o-valor-existe","title":"Comprobar si una clave o valor existe","text":"<pre><code>if (idiomas.containsKey(\"es\")) {\nSystem.out.println(\"La clave es ya existe\");\n}\n\nif (idiomas.containsValue(\"Espa\u00f1ol\")) {\nSystem.out.println(\"El idioma espa\u00f1ol ya existe\");\n}\n</code></pre>"},{"location":"ud6/4map/#imprimir-todos-los-valores-del-map","title":"Imprimir todos los valores del <code>Map</code>","text":"<p>Lo haremos de la siguiente forma:</p> <pre><code>for(String key: idiomas.keySet()) {\nSystem.out.println(key + \" \" + idiomas.get(key));\n}\n</code></pre> <p>Al imprimir vemos que las claves no aparecen en ning\u00fan orden, ni en el que las hemos introducido ni en orden alfab\u00e9tico. Los elementos del <code>HashMap</code> no est\u00e1n ordenados.</p>"},{"location":"ud6/4map/#imprimir-cada-una-de-las-entradas-del-mapa","title":"Imprimir cada una de las entradas del mapa","text":"<p>Si queremos recorrer las entradas del mapa usaremos:</p> <pre><code>for (Map.Entry&lt;String, String&gt; entradaMapa: idiomas.entrySet()) {\nSystem.out.println(entradaMapa.getKey() + \" \" + entradaMapa.getValue());\n}\n</code></pre>"},{"location":"ud6/4map/#eliminar-una-entrada-clave-valor-de-un-map","title":"Eliminar una entrada clave-valor de un <code>Map</code>","text":"<p>Tenemos dos formas de eliminar:</p> <ol> <li>Eliminar desde una clave existente, o</li> <li>Eliminar un par clave-valor existente.</li> </ol> <pre><code>//Forma 1\nboolean eliminado = idiomas.remove(\"fr\");\n\n//Forma 2\nif (idiomas.remove(\"de\", \"Ingles\")) {\nSystem.out.println(\"de ha sido eliminado\");\n} else {\nSystem.out.println(\"No existe un par clave-valor con de-Ingles\");\n}\n</code></pre>"},{"location":"ud6/4map/#reemplazar-el-valor-de-una-clave","title":"Reemplazar el valor de una clave","text":"<pre><code>idiomas.replace(\"es\", \"Spain\");\nidiomas.replace(\"en\", \"English\", \"English EEUU\");//Reemplazo el antiguo valor por el nuevo, pero antes me aseguro que el antiguo valor sea ese dato antes de cambiarlo\n</code></pre>"},{"location":"ud6/4map/#hashmap","title":"<code>HashMap</code>","text":"<p><code>HashMap</code> es una estructura de datos que implementa la <code>Map&lt;Key,Value&gt;</code> interfaz y se basa en el principio de hash.</p> <p>Una funci\u00f3n hash es una funci\u00f3n que convierte datos de entrada de cualquier tama\u00f1o (generalmente grande) en datos de tama\u00f1o fijo, generalmente compactos. El resultado de esta funci\u00f3n de trabajo se llama c\u00f3digo hash.</p> <p>Cada objeto Java tiene un c\u00f3digo hash. Suele ser un n\u00famero y se calcula utilizando el m\u00e9todo hashCode de la clase Object.</p>"},{"location":"ud6/5set/","title":"Set (Conjunto)","text":"<p>La interfaz <code>Set</code> est\u00e1 contenida en el paquete java.util y extiende de la interfaz Collection, es una colecci\u00f3n desordenada de objetos en los que no se pueden almacenar valores duplicados. Esta interfaz contiene los m\u00e9todos heredados de la interfaz Collection y agrega una funci\u00f3n que restringe la inserci\u00f3n de elementos duplicados.</p> <p></p> <p>La interfaz <code>Set</code> define los m\u00e9todos b\u00e1sicos de a\u00f1adir, eliminar, comprobar tama\u00f1o, si est\u00e1 vac\u00edo, tambi\u00e9n podemos verificar si un elemento existe en el conjunto (Set). Pero no hay forma de obtener un elemento del conjunto. Es decir, podemos comprobar que algo existe y podemos iterar sobre los elementos del conjunto, pero no es posible obtener, por ejemplo, el elemento 3 del conjunto.</p> <p>Dado que <code>Set</code> es una interfaz, debe instanciar una implementaci\u00f3n concreta de la interfaz para poder usarla. Puede elegir entre las siguientes implementaciones de Set en la API de colecciones de Java:</p> <ul> <li>java.util.EnumSet</li> <li>java.util.HashSet</li> <li>java.util.LinkedHashSet</li> <li>java.util.TreeSet</li> </ul> <p>Una de las mejores implementaciones (con mejor rendimiento) de la interfaz <code>Set</code> es la clase <code>HashSet</code>, que utiliza tablas hashes para almacenar los elementos. Es muy parecido a la clase <code>HashMap</code> que hemos utilizado anteriormente.</p>"},{"location":"ud6/5set/#crear-un-set","title":"Crear un Set","text":"<p>Puedo crearme <code>Set</code> gen\u00e9rico sin especificar el tipo:</p> <pre><code>        Set setA = new HashSet();\nSet setB = new LinkedHashSet();\nSet setC = new TreeSet();\n</code></pre> <pre><code>Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();\n</code></pre>"},{"location":"ud6/5set/#anadir-elementos-en-un-set","title":"A\u00f1adir elementos en un Set","text":"<pre><code>Set&lt;String&gt; setA = new HashSet&lt;&gt;();\n\nsetA.add(\"element 1\");\nsetA.add(\"element 2\");\nsetA.add(\"element 3\");\n</code></pre>"},{"location":"ud6/5set/#recorrer-los-elementos-de-un-set","title":"Recorrer los elementos de un Set","text":"<p>Hay dos formas de iterar los elementos de un Java Set:</p> <ul> <li>Utilizando un <code>Iterator</code> obtenido de la interfaz <code>Set</code>.</li> <li>Usando un bucle for-each.</li> </ul> <p>Al iterar los elementos en el <code>Set</code>, el orden de los elementos depende de la implementaci\u00f3n que utilicemos para crear el <code>Set</code>.</p>"},{"location":"ud6/5set/#con-iterator","title":"Con Iterator","text":"<pre><code>Set&lt;String&gt; setA = new HashSet&lt;&gt;();\n\nsetA.add(\"element 1\");\nsetA.add(\"element 2\");\nsetA.add(\"element 3\");\n\nIterator&lt;String&gt; iterator = set.iterator();\n\nwhile(iterator.hasNext(){\nString element = iterator.next();\n}\n</code></pre>"},{"location":"ud6/5set/#con-bucle-for-each","title":"Con bucle for-each","text":"<pre><code>Set&lt;Integer&gt; set = new HashSet();\n\nfor(Integer num: set) {\nSystem.out.println(num);\n}\n</code></pre> <p>Si me he creado un set gen\u00e9rico, tengo que hacer un cast del objeto:</p> <pre><code>Set set = new HashSet();\n\nfor(Object object : set) {\nString element = (String) object;\n}\n</code></pre>"},{"location":"ud6/5set/#eliminar-elemento-de-un-set","title":"Eliminar elemento de un Set","text":"<pre><code>set.remove(\"object-to-remove\");\n</code></pre> <p>No hay forma de eliminar un objeto basado en el \u00edndice en un <code>Set</code>, ya que el orden de los elementos depende de la implementaci\u00f3n.</p>"},{"location":"ud6/5set/#eliminar-todos-los-elementos-de-un-set","title":"Eliminar todos los elementos de un Set","text":"<p>Para eliminar todos los elementos usamos el m\u00e9todo <code>clear()</code>:</p> <pre><code>set.clear();\n</code></pre>"},{"location":"ud6/5set/#tamano-de-un-set","title":"Tama\u00f1o de un Set","text":"<p>Para verificar el tama\u00f1o de un <code>Set</code> en Java se usa el m\u00e9todo size(). El tama\u00f1o de un Conjunto es el n\u00famero de elementos contenidos en el Conjunto.</p> <pre><code>Set&lt;String&gt; set = new HashSet&lt;&gt;();\n\nset.add(\"123\");\nset.add(\"456\");\nset.add(\"789\");\n\nint size = set.size();//el tama\u00f1o ser\u00e1 3\n</code></pre>"},{"location":"ud6/5set/#comprobar-si-esta-vacio","title":"Comprobar si est\u00e1 vac\u00edo","text":"<pre><code>Set&lt;String&gt; set = new HashSet&lt;&gt;();\n\nboolean isEmpty = set.isEmpty();\n</code></pre>"},{"location":"ud6/5set/#verificar-si-contiene-un-elemento","title":"Verificar si contiene un elemento","text":"<p>Para determinar si un conjunto contiene el elemento, se llama al m\u00e9todo <code>contains</code>, que internamente iterar\u00e1 sobre todos sus elementos y comparar\u00e1 cada elemento con el objeto pasado como par\u00e1metro. La comparaci\u00f3n utiliza el m\u00e9todo de <code>equals</code> de Java del elemento para verificar si el elemento es igual al par\u00e1metro.</p> <pre><code>Set&lt;String&gt; set = new HashSet&lt;&gt;();\n\nset.add(\"123\");\nset.add(\"456\");\n\nboolean contains123 = set.contains(\"123\");//devuelve true\n</code></pre> <p>Dado que es posible agregar valores nulos a un conjunto, tambi\u00e9n es posible verificar si el conjunto contiene un valor nulo. As\u00ed es como verifica si un conjunto contiene un valor nulo:</p> <pre><code>Set&lt;String&gt; set = new HashSet&lt;&gt;();\nset.add(null);\nboolean containsElement = set.contains(null);\n</code></pre>"},{"location":"ud6/5set/#convertir-set-en-list","title":"Convertir Set en List","text":"<p>Puede convertir los elementos de un <code>Set</code> en una <code>List</code> llamamos al m\u00e9todo addAll(), pasando el conjunto como par\u00e1metro.</p> <pre><code>Set&lt;String&gt; set = new HashSet&lt;&gt;();\nset.add(\"123\");\nset.add(\"456\");\n\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.addAll(set);\n</code></pre>"},{"location":"ud6/5set/#necesidad-de-sobreescribir-o-anular-metodo-equals-y-hashcode","title":"Necesidad de sobreescribir o anular m\u00e9todo <code>equals()</code> y <code>hashCode()</code>","text":"<p><code>HashMap</code> y <code>HashSet</code> usan el valor del c\u00f3digo hash de un objeto para averiguar c\u00f3mo se almacenar\u00eda el objeto en la colecci\u00f3n y, posteriormente, el c\u00f3digo hash se usa para ayudar a localizar el objeto en la colecci\u00f3n. La recuperaci\u00f3n de hash implica:</p> <ul> <li>Primero, encontrar el correcto lugar donde est\u00e1 almacenado usando hashCode().</li> <li>Segundo, buscar el elemento correcto usando equals().</li> </ul>"},{"location":"ud6/5set/#ejemplo","title":"Ejemplo","text":"<p>Cuando llamamos <code>map.put(g1, \u201cMARKETING\u201d);</code> generar\u00e1 un hash en alguna ubicaci\u00f3n y cuando llamemos a <code>map.put(g2, \"IT\");</code> generar\u00e1 el mismo valor hash (igual que g1) y reemplazar\u00e1 el primer valor por el segundo valor porque al iterar sobre la estructura encuentra que k.equals(g2) es verdadero, significa que la clave de b\u00fasqueda ya existe. Entonces, reemplaza el valor anterior de esa clave por un valor nuevo.</p> <p>Cuando Java compara dos objetos en estructuras de tipo hash (HashMap, HashSet etc) primero invoca al m\u00e9todo hashcode y luego el equals. Si los m\u00e9todos hashcode de cada objeto devuelven diferente hash no seguir\u00e1 comparando y considerar\u00e1 a los objetos distintos. En el caso en el que ambos objetos compartan el mismo hashcode Java invocar\u00e1 al m\u00e9todo equals() y revisar\u00e1 a detalle si se cumple la igualdad. De esta forma las b\u00fasquedas quedan simplificadas en estructuras hash.</p> <pre><code>class Persona {\n\nprivate String name;\nprivate int id;\n\nPersona(String name, int id) {\nthis.name = name;\nthis.id = id;\n}\n\n@Override\npublic boolean equals(Object o) {\nif (this == o) return true;\nif (o == null || getClass() != o.getClass()) return false;\nPersona persona = (Persona) o;\nreturn id == persona.id &amp;&amp; Objects.equals(nombre, persona.nombre);\n}\n\n@Override\npublic int hashCode() {\nreturn Objects.hash(nombre, id);\n}\n}\n\n\npublic static void main(String[] args) {\nPersona p1 = new Persona(\"Patricia\", 1);\nPersona p2 = new Persona(\"Patricia\", 1);\n\nSet&lt;Persona&gt; conjunto = new HashSet&lt;Persona&gt;();\nconjunto.add(p1);\nconjunto.add(p2);\n\nSystem.out.println(conjunto.contains(p1));\n}\n</code></pre>"},{"location":"ud6/5set/#operaciones-con-set","title":"Operaciones con <code>Set</code>","text":"<p>Dado que <code>Set</code> representa un conjunto, podemos realizar todas las operaciones matem\u00e1ticas b\u00e1sicas como intersecci\u00f3n, uni\u00f3n y diferencia.</p> <p>Supongamos que tenemos dos conjuntos, es decir, conjunto1 = [22, 45, 33, 66, 55, 34, 77] y conjunto2 = [33, 2, 83, 45, 3, 12, 55]. Podemos realizar la siguiente operaci\u00f3n en el Set:</p> <p></p> <ul> <li>Intersecci\u00f3n: La operaci\u00f3n de intersecci\u00f3n devuelve todos aquellos elementos que est\u00e1n presentes en ambos conjuntos. La intersecci\u00f3n de set1 y set2 ser\u00e1 [33, 45, 55].</li> <li>Uni\u00f3n: la operaci\u00f3n de uni\u00f3n devuelve todos los elementos de set1 y set2 en un solo conjunto, y ese conjunto puede ser set1 o set2. La uni\u00f3n de set1 y set2 ser\u00e1 [2, 3, 12, 22, 33, 34, 45, 55, 66, 77, 83].</li> <li>Diferencia: La operaci\u00f3n de diferencia elimina los valores del conjunto que est\u00e1n presentes en otro conjunto. La diferencia de set1 y set2 ser\u00e1 [66, 34, 22, 77].</li> </ul> <p>En <code>Set</code>, el m\u00e9todo <code>addAll()</code> se usa para realizar la uni\u00f3n, el m\u00e9todo de <code>retainAll()</code> se usa para realizar la intersecci\u00f3n y el m\u00e9todo <code>removeAll()</code> se usa para realizar la diferencia.</p>"},{"location":"ud6/6ordercollections/","title":"Colecciones ordenadas","text":"<p>Vamos a estudiar una variante del <code>HashMap</code> y <code>HashSet</code>, el <code>LinkedHashMap</code> y <code>LinkedHashSet</code>.</p> <p>Tambi\u00e9n est\u00e1n las versiones ordenadas del <code>HashMap</code> y el <code>HashSet</code> que son <code>TreeMap</code> y <code>TreeSet</code>.</p> <p>Como las operaciones entre <code>Map</code> y <code>Set</code> son muy similares nos centraremos en los mapas.</p>"},{"location":"ud6/6ordercollections/#linkedhashmap","title":"<code>LinkedHashMap</code>","text":"<p>La clase <code>LinkedHashMap</code> es como <code>HashMap</code> con una caracter\u00edstica adicional de mantener el orden de elementos insertados en ella.</p> <p><code>HashMap</code> proporciona la ventaja de una r\u00e1pida inserci\u00f3n, b\u00fasqueda y borrado, pero NO mantiene el orden en el que se insertan los elementos. Con <code>LinkedHashMap</code> se puede acceder a los elementos en su orden de inserci\u00f3n.</p>"},{"location":"ud6/6ordercollections/#caracteristicas","title":"Caracter\u00edsticas","text":"<ul> <li>Un LinkedHashMap contiene valores basados en la clave.Implementa la interfaz del mapa y extiende la clase HashMap.</li> <li>Contiene solo elementos \u00fanicos.</li> <li>Solo puede tener una clave nula pero varios valores nulos.</li> <li>Es lo mismo que <code>HashMap</code> con una caracter\u00edstica adicional que mantiene el orden de inserci\u00f3n.</li> </ul> <p>Los datos se almacenan en forma de nodos. La implementaci\u00f3n de <code>LinkedHashMap</code> es muy similar a una lista doblemente enlazada. Por lo tanto, cada nodo del LinkedHashMap est\u00e1 representado como:</p> <p></p> <ul> <li>Hash: Todas las claves (keys) de entrada se convierten en un hash, que es una forma m\u00e1s corta de la clave para que la b\u00fasqueda y la inserci\u00f3n sean m\u00e1s r\u00e1pidas.</li> <li>Key: Dado que esta clase extiende <code>HashMap</code>, los datos se almacenan en forma de par clave-valor. Este par\u00e1metro es la clave de los datos.</li> <li>Value: Para cada clave, hay un valor asociado con \u00e9l.</li> <li>After: Dado que LinkedHashMap almacena la orden de inserci\u00f3n, contiene la direcci\u00f3n al siguiente nodo de la lista.</li> <li>Before: Este par\u00e1metro contiene la direcci\u00f3n al nodo anterior de la lista.</li> </ul>"},{"location":"ud6/6ordercollections/#treemap","title":"<code>TreeMap</code>","text":"<p>Java TreeMap es una estructura de datos que implementa la interfaz <code>Map&lt;Key,Value&gt;</code>, se basa en un \u00e1rbol binario y ordena por clave.</p> <p><code>TreeMap</code> es una implementaci\u00f3n de Map que mantiene sus entradas ordenadas seg\u00fan el orden natural de sus claves. Para n\u00fameros significa orden ascendente, para cadenas, orden alfab\u00e9tico. Sin embargo, es posible utilizar un comparador si necesita cambiar la l\u00f3gica.</p> <p><code>HashMap</code> le permite almacenar una clave nula y varios valores nulos. <code>TreeMap</code> ordena los elementos en orden natural y no permite claves nulas porque el m\u00e9todo <code>compareTo()</code> arroja <code>NullPointerException</code> si se compara con nulo.</p>"},{"location":"ud6/7final/","title":"Keyword Final","text":"<p>Generalmente, usamos la palabra reservada <code>final</code> para definir valores constantes. Pero en realidad, los campos o atributos finales no son constantes porque pueden modificarse. Pero SOLO una vez y cualquier modificaci\u00f3n debe realizarse antes de que finalice el constructor de la clase.</p> <p>Ejemplo: Podemos asignarle final a un campo de la clase y declararlo por primera vez en el constructor.</p> <pre><code>public class TestFinal {\n\nprivate final int numero;\n\npublic TestFinal(int n) {\nnumero = n;\n}\n}\n</code></pre> <pre><code>public class TestFinal {\n\nprivate final int numero = 0;\n\npublic TestFinal() {\n}\n}\n</code></pre> <p>Ambos c\u00f3digos hacen lo mismo.</p> <p>Cuando declaramos un atributo como final, IntelliJ es listo y no nos deja implementar el m\u00e9todo setter de ese atributo.</p> <p>Cuando queremos crear una variable constante de la que ya conocemos su valor, normalmente usamos <code>static final</code> y la nombramos en may\u00fasculas. Pero una variable final que cambia para cada instancia de la clase, no se nombra en may\u00fasculas.</p>"},{"location":"ud6/7final/#final-en-la-definicion-de-clase","title":"Final en la definici\u00f3n de clase","text":"<p>Si a\u00f1adimos la palabra <code>final</code> al crear una clase, lo que hacemos es NO permitir que se pueda extender de esa clase. Es decir, no puede tener hijos que hereden de ella.</p> <p>Ejemplo:</p> <pre><code>public final class Coche {\n\n}\n</code></pre>"},{"location":"ud6/7final/#final-en-la-definicion-de-metodos","title":"Final en la definici\u00f3n de m\u00e9todos","text":"<p>A veces queremos, heredar de una clase, pero no queremos que se puedan sobreescribir o anular todos los m\u00e9todos de la clase padre en los hijos porque a lo mejor son m\u00e9todos que tienen una cierta funcionalidad que no cambia. Es decir, queremos prevenir que modifiquen su comportamiento. Para realizar esto declaramos los m\u00e9todos como final.</p> <p>Los \u00fanicos m\u00e9todos que no pueden declararse como final son los constructores, ya que no se heredan.</p> <pre><code>class Perro {\n\n@Override\npublic void mover() {\n\n}\n\n}\npublic class Animal {\n\npublic final void comer() {\n//este m\u00e9todo no puede sobreescribirse en los hijos\n}\n\npublic void mover() {\n//este m\u00e9todo se puede sobreescribir\n}\n}\n</code></pre>"},{"location":"ud6/7final/#bloque-estaticos","title":"Bloque est\u00e1ticos","text":"<p>El bloque est\u00e1tico se usa para inicializar las variables est\u00e1ticas. Este bloque se ejecuta cuando la clase se carga en la memoria. Una clase puede tener varios bloques est\u00e1ticos, que se ejecutar\u00e1n en la misma secuencia en la que se escribieron en el programa. Se ejecutan antes que los constructores.</p> <p>Los bloques est\u00e1ticos de inicializaci\u00f3n son equivalentes a los constructores. Los constructores como bien sabemos son constructores de instancias de la clase, como no son est\u00e1ticos, se ejecutan cada vez que se crea una nueva instancia de la clase.</p> <p>Como hemos dicho, el equivalente a los constructores en su versi\u00f3n est\u00e1tica, son los bloques est\u00e1ticos de inicializaci\u00f3n, la diferencia es que el bloque est\u00e1tico SOLO se ejecuta una vez cuando se carga la clase.</p> <p>Al igual que las variables finales pueden inicializarse en el constructor. Las variables est\u00e1ticas finales pueden hacerlo en los bloques est\u00e1ticos de inicializaci\u00f3n.</p> <pre><code>class Test {\n\nprivate static int num;\nprivate static final int x;\n\nstatic{\nnum = 68;\nx = 9;\n}\n\n}\n</code></pre>"},{"location":"ud6/8hashcode_equals/","title":"Necesidad de Java Equals y Hashcode","text":"<p>Los m\u00e9todos Java <code>equals()</code> y <code>hashCode()</code> est\u00e1n presentes en la clase <code>Object</code>. Como todas las clases heredan de la clase Object de forma autom\u00e1tica reciben una implementaci\u00f3n predeterminada de equals() y hashCode() sino se sobreescribe.</p> <p>El m\u00e9todo equals() sirve para comparar instancias de clases entre s\u00ed. Si usamos colecciones como las que hemos visto en el tema: ArrayList, LinkedList... muchos de sus m\u00e9todos (contains, remove, indexOf, etc.) llaman al m\u00e9todo equals internamente para encontrar el objeto. Es decir, van comparando el objeto con los que hay en la lista.</p> <p>A veces cuando creamos colecciones donde el tipo de dato es un Objeto definido por nosotros, como Persona, Coche, etc. Necesitamos de alg\u00fan m\u00e9todo que nos permita comparar objetos de este tipo.</p> <p>Los m\u00e9todos Java hashCode() y equals() se utilizan conjuntamente en implementaciones basadas en tablas Hash en Java para almacenar y recuperar datos.</p>"},{"location":"ud6/8hashcode_equals/#equals","title":"Equals","text":"<p>Lo heredamos autom\u00e1ticamente de Object de la siguiente forma:</p> <pre><code>//Dos objetos son iguales, si son el mismo objeto\npublic boolean equals(Object obj) {\nreturn (this == obj);\n}\n</code></pre> <p>En ocasiones, queremos cambiar la l\u00f3gica de la implementaci\u00f3n de <code>Object</code> por otra l\u00f3gica que nos diga si dos instancias de una clase son equivalentes a pesar de tratarse de distintos objetos. Por ejemplo, teniendo en cuenta los atributos de la clase que nosotros le indiquemos para ello.</p> <p>En el siguiente ejemplo tenemos la clase Client, en nuestra l\u00f3gica dos objetos de cliente son iguales si son del mismo tipo (Client) y comparten el mismo nombre.</p> Client.java<pre><code>public class Client {\n\nprivate String name;\nprivate int age;\n\n@Override\npublic boolean equals(Object o) {\nif (this == o) return true;\nif (o == null || getClass() != o.getClass()) return false;\nClient client = (Client) o;\nreturn Objects.equals(name, client.name);\n}\n}\n</code></pre>"},{"location":"ud6/8hashcode_equals/#contrato-equals-hashcode","title":"Contrato equals() - hashcode()","text":"<p>Cuando utilicemos estructuras de datos basadas en hash tables como HashMap, HashSet, LinkedHashMap, LinkedHashSet, Hashtable, ... necesitamos de un contrato equals - hashcode:</p> <p>Cuando sobreescribimos el m\u00e9todo equals() en nuestra clase para cambiar la l\u00f3gica que se hereda de la clase Object, tenemos que sobreescribir el m\u00e9todo hashCode() de manera que si dos instancias de nuestra clase son iguales seg\u00fan la nueva l\u00f3gica en equals(), el m\u00e9todo hashCode() deber\u00e1 retornar el mismo valor si lo llamo para dichas instancias.</p> <p>El m\u00e9todo <code>hashcode()</code> sirve para comparar objetos de una forma m\u00e1s r\u00e1pida en estructuras Hash ya que \u00fanicamente nos devuelve un n\u00famero entero. Cuando Java compara dos objetos en estructuras de tipo hash primero invoca al m\u00e9todo hashcode y luego el equals. Si los m\u00e9todos hashcode de cada objeto devuelven diferente hash no seguir\u00e1 comparando y considerar\u00e1 a los objetos distintos. En el caso en el que ambos objetos compartan el mismo hashcode Java invocar\u00e1 al m\u00e9todo equals() y revisar\u00e1 si se cumple la igualdad.</p>"},{"location":"ud6/8hashcode_equals/#ejemplo","title":"Ejemplo","text":"<p>Muchas veces se nos olvida que la invocaci\u00f3n a los m\u00e9todos equals y hashcode forma parte intr\u00ednseca del framework de colecciones. Por ejemplo si construimos dos objetos de tipo Client y los a\u00f1adimos a un HashSet, podemos comprobar que el cliente existe utilizando el m\u00e9todo contains dentro del conjunto.</p> Main.java<pre><code>public static void main(String[] args) {\nClient p1= new Client();\np1.setName(\"Patricia\");\n\nClient p2= new Client();\np2.setName(\"Chema\");\n\nClient p3= new Client();\np3.setName(\"Patricia\");\n\nHashSet&lt;Client&gt; conjunto = new HashSet&lt;&gt;();\nconjunto.add(p1);\nconjunto.add(p2);\nconjunto.add(p3);\nSystem.out.println(conjunto.contains(p1));//true\nSystem.out.println(conjunto.size());//2\n}\n</code></pre> <p>Esto nos devolver\u00e1 true ya que el HashSet contiene este elemento. Ahora bien si nosotros sobreescribimos de forma incorrecta el hashcode con el siguiente c\u00f3digo:</p> <pre><code>    @Override\npublic int hashCode() {\nreturn (int)(Math.random()*100);\n}\n\npublic static void main(String[] args) {\nClient p1= new Client();\np1.setName(\"Patricia\");\n\nClient p2= new Client();\np2.setName(\"Chema\");\n\nClient p3= new Client();\np3.setName(\"Patricia\");\n\nHashSet&lt;Client&gt; conjunto = new HashSet&lt;&gt;();\nconjunto.add(p1);\nconjunto.add(p2);\nconjunto.add(p3);\nSystem.out.println(conjunto.contains(p1));//false\nSystem.out.println(conjunto.size());//3\n}\n</code></pre> <p>Estaremos calculando al azar el hashcode y dos objetos iguales devolver\u00e1n hashcodes diferentes. El <code>HashSet</code> nos devolver\u00e1 false cuando invoquemos el m\u00e9todo contains aunque sabemos que el elemento existe en el conjunto. Y tambi\u00e9n agregar\u00e1 duplicado ya que no encuentra el elemento.</p>"},{"location":"ud7/1generics/","title":"\ud83e\udd84 Gen\u00e9ricos","text":"<p>Antes de Java 5 cuando introduc\u00edamos objetos en una colecci\u00f3n estos se guardaban como objetos de tipo <code>Object</code>, aprovechando el polimorfismo para poder introducir cualquier tipo de objeto en la colecci\u00f3n. Esto nos obligaba a hacer un casting al tipo original al obtener los elementos de la colecci\u00f3n.</p> <pre><code>public class Ejemplo {  public static void main(String[] args) {  List lista = new ArrayList();  lista.add(\"Hola mundo\");  String cadena = (String) lista.get(0);  System.out.println(cadena);  }  } </code></pre> <p>Esta forma de trabajar no solo nos ocasiona tener que escribir m\u00e1s c\u00f3digo innecesariamente, sino que es propenso a errores porque carecemos de un sistema de comprobaci\u00f3n de tipos. Si introdujeramos un objeto de tipo incorrecto el programa compilar\u00eda pero lanzar\u00eda una excepci\u00f3n en tiempo de ejecuci\u00f3n al intentar convertir el objeto en <code>String</code>:</p> <pre><code>public class Ejemplo {  public static void main(String[] args) {  List lista = new ArrayList();  lista.add(22);  String cadena = (String) lista.get(0);  System.out.println(cadena);  } } </code></pre> <p>Desde Java 5 contamos con una caracter\u00edstica llamada generics que puede solventar esta clase de problemas. Los generics son una mejora al sistema de tipos que nos permite programar abstray\u00e9ndonos de los tipos de datos.</p> <p>Gen\u00e9ricos significa tipos parametrizados. La idea es permitir que el tipo (<code>Integer</code>, <code>String</code>, etc., y tipos definidos por el usuario) sea un par\u00e1metro para m\u00e9todos, clases e interfaces. Utilizando Generics, es posible crear clases que trabajen con diferentes tipos de datos. Una entidad como clase, interfaz o m\u00e9todo que opera en un tipo parametrizado es una entidad gen\u00e9rica.</p> <p>Gracias a los generics podemos especificar el tipo de objeto que introduciremos en la colecci\u00f3n, de forma que el compilador conozca el tipo de objeto que vamos a utilizar, evit\u00e1ndonos as\u00ed el casting. Adem\u00e1s, gracias a esta informaci\u00f3n, el compilador podr\u00e1 comprobar el tipo de los objetos que introducimos, y lanzar un error en tiempo de compilaci\u00f3n si se intenta introducir un objeto de un tipo incompatible, en lugar de que se produzca una excepci\u00f3n en tiempo de ejecuci\u00f3n.</p> <p>Para utilizar generics con nuestras colecciones tan solo tenemos que indicar el tipo entre el operador Diamond &lt;&gt; a la hora de crearla. A estas clases a las que podemos pasar un tipo como \u00abpar\u00e1metro\u00bb se les llama clases parametrizadas, clases gen\u00e9ricas o simplemente gen\u00e9ricas (generics).</p> <pre><code>public class Ejemplo {  public static void main(String[] args) {  List&lt;String&gt; lista = new ArrayList&lt;String&gt;();  lista.add(\"Hola mundo\");  String cadena = lista.get(0);  System.out.println(cadena);  }  } </code></pre> <p>El c\u00f3digo anterior no compilar\u00eda, si intent\u00e1ramos insertar en la lista un n\u00famero <code>lista.add(14);</code>, nos dar\u00eda un error de compilaci\u00f3n de tipos.</p> <p>Note</p> <p>Algo a tener en cuenta es que el tipo par\u00e1metro debe ser una clase; no podemos utilizar tipos primitivos.</p>"},{"location":"ud7/1generics/#clases-genericas","title":"\ud83e\udd84 Clases gen\u00e9ricas","text":"<p>Al crear una clase que utiliza o contiene alg\u00fan atributo gen\u00e9rico, me obliga a a\u00f1adir este tipo de gen\u00e9rico en la definici\u00f3n de clase. Por convenci\u00f3n se suele utilizar una sola letra may\u00fascula para el tipo gen\u00e9rico.</p> <p>Es decir, si mi clase tiene un atributo <code>T elemento</code> gen\u00e9rico que no s\u00e9 qu\u00e9 tipo de dato va a ser, entero, double, float.... le pongo una letra y con esto le digo que ese atributo es de tipo gen\u00e9rico, puede ser cualquier tipo de dato.</p> <pre><code>public class Box&lt;T&gt; {\n\nprivate T elemento;\n\npublic T get() { return elemento; }\npublic void set(T elemento) { this.elemento = elemento; }\n\n}\n</code></pre> <p>Seg\u00fan las convenciones los nombres de los par\u00e1metros de tipo usados com\u00fanmente son los siguientes:</p> <ul> <li>E: elemento de una colecci\u00f3n.</li> <li>K: clave.</li> <li>N: n\u00famero.</li> <li>T: tipo.</li> <li>V: valor.</li> <li>S, U, V etc: para segundos, terceros y cuartos tipos.</li> </ul> <p>En el momento de la instanciaci\u00f3n de un tipo gen\u00e9rico indicaremos el argumento para el tipo, en este caso Box contendr\u00e1 una referencia a un tipo Integer.</p> <pre><code>//Las dos formas son v\u00e1lidas:\nBox&lt;Integer&gt; integerBox1 = new Box&lt;Integer&gt;();\nBox&lt;Integer&gt; integerBox2 = new Box&lt;&gt;();\n\nBox&lt;String&gt; textoBox = new Box&lt;&gt;();\n</code></pre> <p>Estamos creando objetos de la clase <code>Box</code>, tanto de tipo Integer como String.</p> <p>A veces querremos limitar los tipos que pueden ser usados empleando lo que se denomina bounded type. Con \\&lt;T extends Number&gt; el tipo T debe extender la clase Number. Java permite m\u00faltiples l\u00edmites o bounded type: <code>&lt;T extends B1 &amp; B2 &amp; B3&gt;</code>. <code>Box</code> es una clase y <code>B1</code> y <code>B2</code> son interfaces. Primero siempre debe ir la clase y luego las interfaces. Recuerda que Java NO permite la herencia m\u00faltiple, por tanto, SOLO se puede extender de una clase, pero puede implementar varias interfaces en la declaraci\u00f3n del bounded type.</p>"},{"location":"ud7/1generics/#metodos-genericos","title":"\ud83e\udd84 M\u00e9todos gen\u00e9ricos","text":"<p>Al igual que ocurre con las clases, si me creo un m\u00e9todo gen\u00e9rico, es decir, que recibe tipos de datos gen\u00e9ricos \u00fanicos que no est\u00e1n definidos en la clase, tengo que especificar en la signatura del m\u00e9todo esos gen\u00e9ricos:</p> <p>Ejemplo</p> <pre><code>public static &lt;T, R&gt; void executeFunction(List&lt;T&gt; lista, Function&lt;T,R&gt; function) {\nfor(T t: lista) {\nSystem.out.println(function.apply(t));\n}\n}\n</code></pre>"},{"location":"ud7/2lambda/","title":"Expresiones lambda","text":"<p>Las expresiones lambda es una caracter\u00edstica importante que fue a\u00f1adida en Java 8. Es muy \u00fatil, ayuda a iterar, filtrar y extraer datos de la colecci\u00f3n.</p> <p>Una expresi\u00f3n lambda es un bloque corto de c\u00f3digo que toma par\u00e1metros y devuelve un valor. Las expresiones lambda son similares a los m\u00e9todos, pero no necesitan un nombre y se pueden implementar directamente en el cuerpo de un m\u00e9todo.</p> <p>La expresiones lambda de Java son tratadas como una funci\u00f3n, por lo que el compilador no crea un archivo .class.</p> <p>La expresi\u00f3n lambda proporciona la implementaci\u00f3n de una interfaz funcional. Una interfaz funcional es aquella que tiene UN SOLO m\u00e9todo abstracto. Las interfaces funcionales en Java incluyen la anotaci\u00f3n <code>@FunctionalInterface</code>.</p>"},{"location":"ud7/2lambda/#sintaxis","title":"Sintaxis","text":"<p>Dado que las expresiones lambda son efectivamente solo m\u00e9todos, las expresiones lambda pueden tomar par\u00e1metros como los m\u00e9todos.</p> <p>La expresi\u00f3n lambda de Java consta de tres componentes.</p> <ol> <li> <p>Par\u00e1metros - lista de argumentos: una expresi\u00f3n lambda puede tener cero o cualquier n\u00famero de argumentos.</p> </li> <li> <p>Token de flecha: se utiliza para vincular la lista de argumentos y el cuerpo de la expresi\u00f3n.</p> </li> <li> <p>Cuerpo: Contiene expresiones y declaraciones para la expresi\u00f3n lambda.</p> </li> </ol> <p>Las expresiones lambda se pueden almacenar en variables si el tipo de variable es una interfaz que tiene un solo m\u00e9todo. La expresi\u00f3n lambda debe tener la misma cantidad de par\u00e1metros y el mismo tipo de retorno que ese m\u00e9todo.</p>"},{"location":"ud7/2lambda/#cero-parametros","title":"Cero par\u00e1metros","text":"<p>Los par\u00e9ntesis no tienen contenido en el medio. Eso es para indicar que la expresi\u00f3n lambda no recibe par\u00e1metros.</p> <p>() -&gt; {body}</p> <pre><code>interface Saludo{  public String say();  }  public class Main {\n\npublic static void main(String[] args) {  Saludo s=()-&gt;{  return \"Hola\";  };  System.out.println(s.say());  }  }  </code></pre>"},{"location":"ud7/2lambda/#un-parametro","title":"Un par\u00e1metro","text":"<p>Cuando una expresi\u00f3n lambda recibe un solo par\u00e1metro, tambi\u00e9n se puede omitir los par\u00e9ntesis, de forma que quedar\u00eda as\u00ed:</p> <p>(p1) -&gt; {body}</p> <p>p1 -&gt; {body}</p> <pre><code>interface Saludo{  public String say(String nombre);  }\n\npublic class Main {\n\npublic static void main(String[] args) { //sin omitir par\u00e9ntesis \nSaludo s = (nombre)-&gt;{  return \"Hola \" + nombre;  };  System.out.println(s.say(\"Patri\"));\n\n\n// Omitir par\u00e9ntesis\nSaludo s2 = nombre -&gt;{  return \"Hola, \" + nombre;  };  System.out.println(s2.say(\"Patri\"));  }\n}  </code></pre>"},{"location":"ud7/2lambda/#multiples-parametros","title":"M\u00faltiples par\u00e1metros","text":"<p>Si el m\u00e9todo con el que coincide su expresi\u00f3n lambda de Java recibe varios par\u00e1metros, los par\u00e1metros deben enumerarse entre par\u00e9ntesis. As\u00ed es como se ve en c\u00f3digo Java:</p> <p>(p1, p2) -&gt; {body}</p> <pre><code>interface Sumable{  int add(int a,int b);  }  public class Main {  public static void main(String[] args) {  Sumable ad1=(a,b)-&gt;(a+b);  System.out.println(ad1.add(10,20));  // con tipo de datos  \nSumable ad2=(int a,int b)-&gt;(a+b);  System.out.println(ad2.add(100,200));  }  } </code></pre>"},{"location":"ud7/2lambda/#tipo-de-parametros","title":"Tipo de par\u00e1metros","text":"<p>En ocasiones, puede ser necesario especificar tipos de par\u00e1metros para una expresi\u00f3n lambda si el compilador no puede inferir los tipos de par\u00e1metros del m\u00e9todo de interfaz funcional con el que coincide la lambda.</p> <pre><code>(Coche coche) -&gt; System.out.println(\"El coche es: \" + coche.getName());\n</code></pre>"},{"location":"ud7/2lambda/#cuerpo-de-las-expresiones-lambda","title":"Cuerpo de las expresiones lambda","text":"<p>El cuerpo de una expresi\u00f3n lambda y, por lo tanto, el cuerpo de la funci\u00f3n/m\u00e9todo que representa, se especifica a la derecha de -&gt; en la declaraci\u00f3n lambda.</p> <p>Si la expresi\u00f3n lambda consta de varias l\u00edneas, se puede encerrar el cuerpo de la funci\u00f3n lambda dentro de los corchetes { }.</p> <pre><code> (oldValue, newValue) -&gt; {\nSystem.out.println(\"Old value: \" + oldValue);\nSystem.out.println(\"New value: \" + newValue);\n}\n</code></pre>"},{"location":"ud7/2lambda/#devolver-un-valor-en-las-expresiones-lambda","title":"Devolver un valor en las expresiones lambda","text":"<p>Al igual que con los m\u00e9todos puedes devolver un valor, en las expresiones lambda tambi\u00e9n. Se hace agregando una declaraci\u00f3n de retorno al cuerpo de la funci\u00f3n lambda.</p> <pre><code>interface Saludo{  public String say(String name);  }\n\npublic class Main {\npublic static void main(String[] args) {  // Lambda expression with single parameter.  \nSaludo s1 = (name)-&gt;{  return \"Hello, \" + name;  };\nSystem.out.println(s1.say(\"Patri\"));  }\n}\n</code></pre> <p>En las expresiones lambda, si solo hay una sentencia, puede o no usar la palabra <code>return</code>. Pero si la expresi\u00f3n lambda tiene varias sentencias se debe poner la palabra <code>return</code>.</p> <pre><code>interface Sumable{  int add(int a,int b);  }\npublic class Main {  public static void main(String[] args) {  // Lambda expression sin palabra clave return\nSumable ad1 = (a,b)-&gt;(a + b);  System.out.println(ad1.add(10,20));  // Lambda expression con la palabra clave return\nSumable ad2 = (a,b)-&gt;{  return (a + b);   };  System.out.println(ad2.add(100,200));  }  } </code></pre> <p>El compilador sabe que la expresi\u00f3n <code>a + b</code> es el valor de retorno de la expresi\u00f3n lambda (de ah\u00ed el nombre de expresiones lambda, ya que las expresiones devuelven un valor de alg\u00fan tipo).</p>"},{"location":"ud7/2lambda/#bucle-for-each","title":"Bucle for-each","text":"<pre><code>public static void main(String[] args) {  List&lt;String&gt; list = new ArrayList&lt;String&gt;();  list.add(\"java\");\nlist.add(\"lambda\");\nlist.add(\"test\");  list.forEach(  (n)-&gt;System.out.println(n)  );  }\n</code></pre>"},{"location":"ud7/2lambda/#escenario-sin-expresiones-lambda","title":"Escenario sin expresiones lambda","text":"<pre><code>interface Saludo { public void saludar();  }  public class LambdaExpressionExample {  public static void main(String[] args) {  String nombre = \"Patri\";\n\n//sin expresiones lambda, Saludo se implementa usando clases an\u00f3nimas\nSaludo s = new Saludo(){  public void saludar(){System.out.println(\"Hola \" + nombre);}  };  s.saludar();  }  }  </code></pre>"},{"location":"ud7/2lambda/#escenario-con-expresiones-lambda","title":"Escenario con expresiones lambda","text":"<pre><code>@FunctionalInterface  //Esto es opcional\ninterface Saludo {  public void saludar();  }  public class LambdaExpressionExample2 {  public static void main(String[] args) {  String nombre = \"Patri\";\n\n//con expresiones lambda\nSaludo s2 = ()-&gt; {\nSystem.out.println(\"Hola \" + nombre);  };\ns2.saludar();  }  }  </code></pre>"},{"location":"ud7/2lambda/#crear-una-expresion-lambda-a-partir-de-un-metodo","title":"Crear una expresi\u00f3n lambda a partir de un m\u00e9todo","text":"<p>Para definir una expresi\u00f3n lambda de un m\u00e9todo que no est\u00e1 definido en ninguna interfaz funcional, tenemos que utilizar la clase <code>Function</code>. A la clase Function se le especifican dos tipos de par\u00e1metros entre <code>&lt;&gt;</code>, el primero es el par\u00e1metro de entrada de la funci\u00f3n, y el segundo es el par\u00e1metro de salida que devuelve la funci\u00f3n o m\u00e9todo.</p> <pre><code>    {\nint total = 0;\nfor (int i = 0; i &lt; texto.length(); i++) {\ntotal+=texto.charAt(i);\n}\nreturn total;\n};\n\n//Queremos crear una expresi\u00f3n lambda que realice lo que est\u00e1 entre { }\n\nFunction&lt;String, Integer&gt; funcionLambda = (s) -&gt; {\nint total = 0;\nfor (int i = 0; i &lt; texto.length(); i++) {\ntotal+=texto.charAt(i);\n}\nreturn total;\n};\n</code></pre> <p>Para ejecutar el c\u00f3digo en el interior de la expresi\u00f3n lambda, utilizaremos el m\u00e9todo <code>apply</code>:</p> <pre><code>System.out.println(funcionLambda.apply(\"Programaci\u00f3n\"));\n</code></pre>"},{"location":"ud7/3predicates/","title":"Predicate","text":"<p>Predicate es una interfaz funcional que se encuentra en el paquete <code>java.util.function</code>. Mejora la capacidad de administraci\u00f3n del c\u00f3digo, ayuda a realizar pruebas unitarias por separado.</p> <p>Se utiliza en expresiones lambda para comprobar si una condici\u00f3n dada es verdadera o falsa.</p> <p>En lugar de pasar un booleano con valor true or false,  pasas una referencia de tipo Predicate para determinar de manera din\u00e1mica si una condici\u00f3n dada es verdadera, o falsa.</p> <p>Esta es la estructura de la interfaz <code>Predicate</code>:</p> <pre><code>@FunctionalInterface\npublic interface Predicate&lt;T&gt; {\n\nboolean test(T t);\n}\n</code></pre> <p>Como vemos la interfaz <code>Predicate</code> utiliza los gen\u00e9ricos para poder decirle que tipo concreto vamos a utilizar.</p> <p>Ejemplo:</p> <pre><code>public class EjemploPredicate {\npublic static void main(String[] args) {\nPredicate&lt;String&gt; checker = a -&gt; a.startsWith(\"M\");\nSystem.out.println(checker.test(\"Miguel\"));\n}\n}\n</code></pre> <p>Hemos creado un objeto <code>Predicate</code> de tipo <code>String</code>. Le damos cuerpo al m\u00e9todo <code>test</code> con una expresi\u00f3n lambda que se le pasa un argumento y devuelve un booleano.</p>"},{"location":"ud7/3predicates/#metodos-predicate","title":"M\u00e9todos Predicate","text":"<p>La interfaz <code>Predicate</code> contiene algunos m\u00e9todos como:</p> <ul> <li><code>isEqual(Object targetRef)</code>: Devuelve un predicado que prueba si dos argumentos son iguales.</li> <li><code>and(Predicate other)</code>: Devuelve un predicado compuesto que representa un AND l\u00f3gico de este predicado y otro.</li> <li><code>or(Predicate other)</code>: Devuelve un predicado compuesto que representa un OR l\u00f3gico de este predicado y otro.</li> <li><code>negate()</code>: Devuelve un predicado que representa la negaci\u00f3n l\u00f3gica de este predicado.</li> </ul> <p>Ejemplo:</p> <pre><code>    Predicate&lt;Integer&gt; greaterThan10 = i -&gt; i &gt; 10;\nPredicate&lt;Integer&gt; lessThan20 = i -&gt; i &lt; 20;\nSystem.out.println(greaterThan10.and(lessThan20).test(15));\n\nPredicate&lt;Integer&gt; greaterThanTen = (i) -&gt; i &gt; 10;\nPredicate&lt;Integer&gt; lowerThanTwenty = (i) -&gt; i &lt; 20;\nboolean resul = greaterThanTen.and(lowerThanTwenty).test(15);//true\nboolean resul2 = greaterThanTen.and(lowerThanTwenty).negate().test(15);//false\n\nPredicate&lt;String&gt; i  = Predicate.isEqual(\"asdf\");\nSystem.out.println(i.test(\"java\"));//false\n</code></pre> <p>Note</p> <p>Debido al uso extendido de <code>Predicate</code> se han a\u00f1adido las interfaces funcionales <code>IntPredicate</code> cuando queremos trabajar con predicados de tipo entero, <code>DoublePredicate</code> y <code>LongPredicate</code>. Tambi\u00e9n tenemos la interfaz <code>BiPredicate</code> que es un caso especial de <code>Predicate</code> y recibe dos par\u00e1metros en vez de uno.</p> <pre><code>    IntPredicate predicate = (x) -&gt; {\nif (x == 12345) {\nreturn true;\n}\nreturn false;\n};\n\nSystem.out.println(predicate.test(12345));\n\nIntPredicate intPredicate1 = predicate.negate();\nSystem.out.println(intPredicate1.test(12345));\n\nBiPredicate&lt;String, Integer&gt; filtroLongitud = (x, y) -&gt; {\nreturn x.length() == y;\n};\n\nboolean result = filter.test(\"java\", 10);\nSystem.out.println(result); // false\n</code></pre>"},{"location":"ud7/3predicates/#supplier","title":"Supplier","text":"<p><code>Supplier</code> es otra interfaz funcional dentro del paquete <code>java.util.function</code> que nos provee del m\u00e9todo abstracto <code>**get**</code>, sin argumentos que devuelve un tipo de dato.</p> <pre><code>@FunctionalInterface\npublic interface Supplier&lt;T&gt; {\n\nT get();\n}\n</code></pre> <p>Esta interfaz tambi\u00e9n se utiliza con expresiones lambda que no tienen par\u00e1metros pero devuelven un resultado:</p> <pre><code>    Random random = new Random();\nSupplier&lt;Integer&gt; su = () -&gt; random.nextInt();\n</code></pre> <p>Al igual que ocurr\u00eda en los predicados con los <code>Supplier</code> tambi\u00e9n disponemos de las clases <code>IntSupplier</code>, <code>DoubleSupplier</code>, <code>LongSupplier</code> y <code>BooleanSupplier</code>.</p>"},{"location":"ud7/3predicates/#consumer","title":"Consumer","text":"<p><code>Consumer</code> es otra interfaz funcional dentro del paquete <code>java.util.function</code> que provee un m\u00e9todo que recibe un solo par\u00e1metro de tipo gen\u00e9rico y no devuelve nada.</p> <pre><code>public interface Consumer&lt;T&gt; {\nvoid accept(T t);\n}\n</code></pre> <p>La expresi\u00f3n lambda asignada a un objeto de tipo <code>Consumer</code> se usa para definir su m\u00e9todo <code>**accept(T t)**</code> que eventualmente aplica la operaci\u00f3n dada en su argumento. Los <code>Consumer</code> son \u00fatiles cuando no necesitan devolver ning\u00fan valor, ya que se espera que operen a trav\u00e9s de efectos secundarios.</p> <p>Existen tambi\u00e9n las interfaces <code>IntConsumer</code>, <code>LongConsumer</code> y <code>DoubleConsumer</code>.</p> <pre><code>Consumer&lt;Integer&gt; numero = (x) -&gt; System.out.println(x);\nnumero.accept(5);\n</code></pre> <p><code>BiConsumer</code> es un caso especial de las expresiones <code>Consumer</code>, son aquellas que reciben dos valores como par\u00e1metro y no devuelven resultado.</p> <pre><code>@FunctionalInterface\npublic interface BiConsumer&lt;T, U&gt; {\nvoid accept(T t, U u);\n}\n</code></pre> <p>Ejemplo:</p> <pre><code>BiConsumer&lt;Integer, String&gt; biConsumer = (x, s) -&gt; System.out.println(x + s);\nbiConsumer.accept(3, \" puntos\");\n</code></pre>"},{"location":"ud7/4functions/","title":"Functions","text":"<p>En el apartado de Expresiones lambda vimos como crear expresiones lambda a partir de un m\u00e9todo definido por el programador. Esto se hac\u00eda utilizando la interfaz funcional <code>Function</code> que se encuentra del paquete <code>java.util.function</code>.</p> <pre><code>@FunctionalInterface\npublic interface Function&lt;T, R&gt; {\nR apply(T t);\n}\n</code></pre> <p><code>Function</code> recibe dos valores de distinto tipo cuando se crea el objeto, el m\u00e9todo recibe un par\u00e1metro de entrada que coincide con el primer tipo espec\u00edfico y devuelve un valor del tipo especificado del objeto que coincide con el segundo valor.</p> <pre><code>Function&lt;Integer, String&gt; function = num -&gt; {\nif(num % 3 == 0 &amp;&amp; num % 5 == 0){\nreturn num + \" divisible entre 3 y 5\";\n}else{\nreturn num + \" no es divisible entre 3 y 5\";\n}\n};\n\nSystem.out.println(function.apply(25));//devuelve un String\n</code></pre> <p>Si tenemos dos funciones y queremos usar el resultado de una para la siguiente funci\u00f3n podemos concatenarlas utilizando <code>andThen</code>.</p> <pre><code>Function&lt;Integer, Integer&gt; suma = x -&gt; x + 2;\nFunction&lt;Integer, Integer&gt; mul = x -&gt; x * 3;\nFunction co = suma.andThen(mul);\nSystem.out.println(co.apply(4)); //imprime 18 = (4 + 2) * 3\n</code></pre>"},{"location":"ud7/4functions/#unaryoperator","title":"UnaryOperator","text":"<p><code>UnaryOperator</code> es una interfaz funcional que extiende de <code>Function</code>.</p> <pre><code>@FunctionalInterface\npublic interface UnaryOperator&lt;T&gt; extends Function&lt;T, T&gt; {\nstatic &lt;T&gt; UnaryOperator&lt;T&gt; identity() {\nreturn t -&gt; t;\n}\n}\n</code></pre> <p><code>UnaryOperator</code> se crea con un tipo de dato, recibe un par\u00e1metro y devuelve un resultado del mismo tipo de su argumento.</p> <pre><code>UnaryOperator&lt;Integer&gt; func2 = x -&gt; x * 2;\nint resultado = func2.apply(2);\nSystem.out.println(resultado);//imprime 4\n</code></pre> <p>Existen tambi\u00e9n las interfaces derivadas <code>IntUnaryOperator</code>, <code>DoubleUnaryOperator</code>, etc.</p>"},{"location":"ud7/4functions/#resumen-de-las-interfaces-funcionales-dentro-de-javautilfunction","title":"Resumen de las interfaces funcionales dentro de java.util.function","text":""},{"location":"ud7/5references/","title":"Referencia a m\u00e9todos en expresiones lambda","text":"<p>Una referencia a m\u00e9todos o m\u00e9todos referenciados proporciona una forma de referirse a un m\u00e9todo sin ejecutarlo. Se relaciona con expresiones lambda porque tambi\u00e9n requiere un contexto de tipo de objetivo que consiste en una interfaz funcional compatible.</p> <p>En el caso de que todo lo que haga la expresi\u00f3n lambda sea llamar a otro m\u00e9todo con los par\u00e1metros pasados \u200b\u200ba la expresi\u00f3n lambda, la implementaci\u00f3n de Java lambda proporciona una forma m\u00e1s corta de expresar la llamada al m\u00e9todo, que es usando ::.</p> <p>Veamos un ejemplo:</p> <pre><code>public interface Impresora{\nvoid imprimir(String s);\n}\n</code></pre> <p>Si us\u00e1ramos lambda sin referencias a m\u00e9todos, lo har\u00edamos de la siguiente forma:</p> <pre><code>Impresora impresora = s -&gt; System.out.println(s);\n</code></pre> <p>Dado que todo lo que hace el cuerpo lambda es reenviar el par\u00e1metro String al m\u00e9todo System.out.println(), podemos reemplazar la declaraci\u00f3n lambda anterior con una referencia de m\u00e9todo utilizando ::. De forma que quedar\u00eda:</p> <pre><code>Impresora impresora = System.out::println;\n</code></pre> <pre><code>List&lt;String&gt; names = new ArrayList();\nnames.add(\"Andrea\");\nnames.add(\"Luisa\");\nnames.add(\"Diego\");\nnames.add(\"Pa\u00fal\");\nnames.add(\"Dario\");\nnames.forEach(System.out::println);\n</code></pre> <p>Observa los dos puntos dobles :: . Estos le indican al compilador de Java que se trata de una referencia de m\u00e9todo. El m\u00e9todo al que se hace referencia es lo que viene despu\u00e9s de los dos puntos dobles. Cualquier clase u objeto que posea el m\u00e9todo al que se hace referencia viene antes de los dos puntos dobles.</p> <p>Podemos hacer referencia a los siguientes tipos de m\u00e9todos:</p> <ul> <li>M\u00e9todo est\u00e1tico</li> <li>M\u00e9todo con par\u00e1metros de objeto</li> <li>M\u00e9todo de instancia</li> <li>Constructor</li> </ul>"},{"location":"ud7/5references/#referencias-a-metodos-estaticos","title":"Referencias a m\u00e9todos est\u00e1ticos","text":"<p>Los m\u00e9todos m\u00e1s f\u00e1ciles de referenciar son los m\u00e9todos est\u00e1ticos. Veamos un ejemplo:</p> <pre><code>public interface Finder {\nint find(String s1, String s2);\n}\n\npublic class MyClass{\npublic static int doFind(String s1, String s2){\nreturn s1.lastIndexOf(s2);\n}\n}\n</code></pre> <p>La referencia al m\u00e9todo est\u00e1tico <code>doFind</code> se har\u00eda con:</p> <pre><code>Finder finder = MyClass::doFind;\n</code></pre> <p>Dado que los par\u00e1metros de los m\u00e9todos <code>Finder.find()</code> y <code>MyClass.doFind()</code> coinciden, es posible crear una expresi\u00f3n lambda que implemente <code>Finder.find()</code> y haga referencia al m\u00e9todo <code>MyClass.doFind()</code>.</p>"},{"location":"ud7/5references/#referencia-a-metodos-con-parametro","title":"Referencia a m\u00e9todos con par\u00e1metro","text":"<p>Tambi\u00e9n puede hacer referencia a un m\u00e9todo con par\u00e1metros de objeto de la clase al m\u00e9todo que se llama.</p> <pre><code>public interface Finder {\nint find(MyClass mc, String s1, String s2);\n}\n\nclass MyClass {\npublic int check(String s1, String s2) {\nreturn s1.indexOf(s2);\n}\n}\n\n//dentro del main\n//Aunque es un m\u00e9todo de instancia, no est\u00e1tico\n//podemos llamarlo con la clase porque en la interfaz\n//est\u00e1 a\u00f1adido un par\u00e1metro de tipo MyClass\nFinder finder = MyClass::check;\n</code></pre> <p>Si quisi\u00e9ramos hacerlo con una expresi\u00f3n lambda sin usar referencia de m\u00e9todos que llama a String.indexOf() para buscar ser\u00eda:</p> <pre><code>Finder finder = (s1, s2) -&gt; s1.indexOf(s2);\n</code></pre> <p>Su equivalente utilizando referencia de m\u00e9todos con par\u00e1metro de objeto en la expresi\u00f3n lambda ser\u00eda:</p> <pre><code>Finder finder = String::indexOf;\nint numero = finder.find(\"Hola\", \"a\");\n</code></pre> <p>Observe c\u00f3mo la versi\u00f3n abreviada hace referencia a un solo m\u00e9todo. El compilador de Java intentar\u00e1 hacer coincidir el m\u00e9todo al que se hace referencia con el primer tipo de par\u00e1metro, utilizando el segundo tipo de par\u00e1metro como par\u00e1metro del m\u00e9todo al que se hace referencia.</p>"},{"location":"ud7/5references/#referencia-a-metodos-de-instancia","title":"Referencia a m\u00e9todos de instancia","text":"<p>En tercer lugar, tambi\u00e9n es posible hacer referencia a un m\u00e9todo de instancia desde una definici\u00f3n lambda.</p> <pre><code>public interface Deserializer {\nint deserialize(String v1);\n}\n</code></pre> <p>Esta interfaz representa un componente que es capaz de \"deserializar\" un String en un int.</p> <pre><code>public class StringConverter {\npublic int convertToInt(String v1){\nreturn Integer.valueOf(v1);\n}\n}\n</code></pre> <p>El m\u00e9todo <code>convertToInt()</code> tiene la misma signatura que el m\u00e9todo <code>deserialize()</code> del m\u00e9todo de la interfaz <code>Deserializer</code>. Por eso, podemos crear una instancia de StringConverter y hacer referencia a su m\u00e9todo convertToInt() desde una expresi\u00f3n lambda de Java.</p> <pre><code>StringConverter stringConverter = new StringConverter();\nDeserializador des = stringConverter::convertToInt;\n</code></pre> <p>La expresi\u00f3n lambda creada por la segunda de las dos l\u00edneas hace referencia al m\u00e9todo convertToInt de la instancia de StringConverter creada en la primera l\u00ednea.</p>"},{"location":"ud7/5references/#referencias-a-constructores","title":"Referencias a constructores","text":"<p>Finalmente, es posible hacer referencia a un constructor de una clase. Para ello, se escribe el nombre de la clase seguido de ::new:</p> <pre><code>-- Nomenclatura\nMiClase::new\n</code></pre> <pre><code>Supplier&lt;Usuario&gt; usu = Usuario::new;\n//Construye un objeto de tipo usuario que es devuelto por m\u00e9todo get();\nUsuario usuario = usu.get();\n</code></pre> <p>Veamos otro ejemplo utilizando <code>BiFunction</code>:</p> <pre><code>class Pruebas {\npublic static void main(String[] args) {\nBiFunction&lt;String, Integer, Usuario&gt; crearUsuario = Usuario::new;\nUsuario u = crearUsuario.apply(\"Patricia\", 12);\n}\n}\nclass Usuario {\nprivate String nombre;\nprivate int edad;\n\npublic Usuario(String nombre, int edad) {\nthis.nombre = nombre;\nthis.edad = edad;\n}\n}\n</code></pre>"},{"location":"ud7/6streams/","title":"Streams","text":"<p>Los Streams fueron introducidos en Java 8 para abrir la puerta a la programaci\u00f3n funcional al igual que con las expresiones lambda.</p> <p>La API <code>Stream</code> permite manipular las colecciones como nunca antes. Nos permite realizar operaciones sobre la colecci\u00f3n, como por ejemplo, buscar, filtrar, reordenar, etc.</p> <p>Con Streams podemos utilizar cualquier clase que implemente la interfaz <code>Collection</code> como si fuese un <code>Stream</code> con la ventaja que nos ofrecen las expresiones lambda.</p> <p>Con streams hay que tener el cuenta que la fuente o colecci\u00f3n que utilicemos no se puede modificar y no debe afectar al estado de la misma. Cada operaci\u00f3n dentro del stream debe verse como una operaci\u00f3n independiente que opera sobre el argumento (colecci\u00f3n).</p> <p>A trav\u00e9s del API Stream podemos trabajar sobre colecciones como si estuvi\u00e9ramos realizando sentencias SQL pero de una manera limpia y clara, evitando bucles y algoritmos que ralentizan los programas e incluso hacen que el c\u00f3digo se torne inmanejable.</p> <p>Cada operaci\u00f3n del stream debe verse como un paso independiente, es decir, no se puede usar variables intermedias.</p>"},{"location":"ud7/6streams/#partes-de-un-stream","title":"Partes de un Stream","text":"<p>De forma gen\u00e9rica existen 3 partes que componen un Stream:</p> <ol> <li>Un Stream funciona a partir de una lista o colecci\u00f3n, que tambi\u00e9n se la conoce como la fuente de donde obtienen informaci\u00f3n.</li> <li>Operaciones intermedias como por ejemplo el m\u00e9todo filter, que permite hacer una selecci\u00f3n a partir de un predicado.</li> <li>Operaciones terminales, como por ejemplo los m\u00e9todos max, min, forEach, findFirst etc.</li> </ol> <p></p> <p>La fuente proporciona los elementos a la tuber\u00eda.</p> <p>Las operaciones intermedias obtienen elementos uno por uno y los procesan. Todas las operaciones intermedias son perezosas (lazy) y, como resultado, ninguna operaci\u00f3n tendr\u00e1 ning\u00fan efecto hasta que la tuber\u00eda comience a funcionar.</p> <p>Las operaciones terminales significan el final del ciclo de vida del steam. Lo m\u00e1s importante para nuestro escenario es que inician el trabajo en la tuber\u00eda.</p>"},{"location":"ud7/6streams/#funciones-de-stream","title":"Funciones de Stream","text":""},{"location":"ud7/6streams/#operaciones-intermedias","title":"Operaciones intermedias","text":""},{"location":"ud7/6streams/#peek","title":"<code>Peek()</code>","text":"<p>El m\u00e9todo <code>peek</code> recibe como par\u00e1metro una expresi\u00f3n lambda de tipo <code>Consumer</code> para poder utilizar cada elemento del stream. Normalmente se utilizar para mostrar por consola el contenido del stream.</p> <p>Este m\u00e9todo existe principalmente para la depuraci\u00f3n del programa, donde se desea ver los elementos a medida que pasan por un punto determinado en el pipeline.</p> <p><code>peek()</code> tambi\u00e9n se utiliza cuando queremos alterar el estado interno de un elemento (aunque esto no es muy com\u00fan).</p> <pre><code>Stream.of(\"one\", \"two\", \"three\", \"four\")\n.filter(e -&gt; e.length() &gt; 3)\n.peek(e -&gt; System.out.println(\"Filtered value: \" + e))\n.map(String::toUpperCase)\n.peek(e -&gt; System.out.println(\"Mapped value: \" + e))\n.collect(Collectors.toList());\n</code></pre>"},{"location":"ud7/6streams/#filter","title":"<code>Filter()</code>","text":"<p>Como su nombre indica lo que hacemos es filtrar de todos los elementos del stream solo aquellos que cumplan una determinada condici\u00f3n. Recibe como par\u00e1metro una expresi\u00f3n lambda <code>Predicate</code> la cual debe devolver <code>true</code> solo en aquellos elementos que se quedar\u00e1n en el stream y <code>false</code> para aquellos elementos que se deben eliminar.</p>"},{"location":"ud7/6streams/#sorted","title":"<code>Sorted()</code>","text":"<p>Se utiliza para ordenar los elementos del stream. Recibe como par\u00e1metro una expresi\u00f3n lambda de tipo <code>Comparator</code> para que podamos indicar la l\u00f3gica de la ordenaci\u00f3n.</p>"},{"location":"ud7/6streams/#distinct","title":"<code>Distinct()</code>","text":"<p>Con <code>distinct</code> se seleccionan los elementos distintos dentro del stream eliminando los duplicados. Los elementos se comparan utilizando el m\u00e9todo equals().</p>"},{"location":"ud7/6streams/#map","title":"<code>Map()</code>","text":"<p>El m\u00e9todo <code>map</code> recibe como par\u00e1metro una expresi\u00f3n lambda de tipo <code>Function</code>, por lo que debemos especificar una funci\u00f3n que recibe como par\u00e1metro de entrada cada elemento del stream, y devuelve un objeto que puede ser un tipo de dato distinto o el mismo.</p> <p>La funci\u00f3n se aplica a cada uno de los elementos del stream para realizar alguna transformaci\u00f3n sobre cada elemento y devuelve otro Stream sobre el cual puedes seguir trabajando. Se utiliza para modificar el contenido del stream. <code>map()</code> devuelve un stream nuevo que consta de los resultados de aplicar la funci\u00f3n dada a los elementos del stream.</p> <pre><code>List&lt;Integer&gt; list = Arrays.asList(3, 6, 9, 12, 15);\n\n//Mostramos el nuevo stream devuelto por map\nlist.stream().map(number -&gt; number * 3).forEach(System.out::println);\n//[9 18 27 36 45]\n</code></pre>"},{"location":"ud7/6streams/#flatmap","title":"<code>FlatMap</code>","text":"<p>Cuando nos encontramos con estructuras m\u00e1s complejas, como por ejemplo una lista con otra lista, trabajar con <code>map()</code> no es suficiente, por ello, utilizamos <code>flatMap()</code> que lo que hace es \"aplanar\" listas anidadas y quedarnos con un stream plano.</p> <p>Es una funci\u00f3n que recibe una entrada y devuelve varias salidas para esa entrada. Esa es la diferencia con respecto a <code>map()</code> que recibe solo un par\u00e1metro de entrada y devuelve una salida.</p> <p><code>flatMap()</code> es una operaci\u00f3n intermedia y devuelve un nuevo Stream. Devuelve un Stream que consiste en los resultados de reemplazar cada elemento del stream dado con el contenido de un stream mapeado producido al aplicar la funci\u00f3n de mapeo provista a cada elemento. La funci\u00f3n de mapeo utilizada para la transformaci\u00f3n en <code>flatMap()</code> es una funci\u00f3n sin estado y solo devuelve una secuencia de nuevos valores.</p> <p>En el siguiente ejemplo el programa usa la operaci\u00f3n <code>flatMap()</code> para convertir una lista de una lista <code>List&lt;List&lt;Integer&gt;&gt;</code> a una lista <code>List&lt;Integer&gt;</code>.</p> <pre><code>List&lt;Integer&gt; list1 = Arrays.asList(1,2,3);\nList&lt;Integer&gt; list2 = Arrays.asList(4,5,6);\nList&lt;Integer&gt; list3 = Arrays.asList(7,8,9);\n\nList&lt;List&lt;Integer&gt;&gt; listOfLists = Arrays.asList(list1, list2, list3);\n\nList&lt;Integer&gt; listOfAllIntegers = listOfLists.stream()\n.flatMap(x -&gt; x.stream())\n.collect(Collectors.toList());\n\nSystem.out.println(listOfAllIntegers);\n//[1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre>"},{"location":"ud7/6streams/#operaciones-terminales","title":"Operaciones terminales","text":""},{"location":"ud7/6streams/#foreach","title":"<code>ForEach()</code>","text":"<p>Recorremos cada elemento del stream para realizar alguna acci\u00f3n con \u00e9l. Como bien sabemos recibe como par\u00e1metro una exprsi\u00f3n lambda de tipo <code>Consumer</code>.</p>"},{"location":"ud7/6streams/#collect","title":"<code>Collect()</code>","text":"<p>Es una operaci\u00f3n terminal, se utiliza para indicar el tipo de colecci\u00f3n en la que se devolver\u00e1 el resultado final de todas las operaciones realizadas en el stream.</p> <pre><code>List&lt;String&gt; lista = Arrays.asList(\"Texto1\", \"Texto2\");\nSet&lt;String&gt; set = lista.stream().collect(Collectors.toSet());\n</code></pre>"},{"location":"ud7/6streams/#findfirst","title":"<code>FindFirst()</code>","text":"<p>Se utiliza para devolver el primer elemento encontrado del stream. Se suele utilizar en combinaci\u00f3n con otras funciones cuando hay que seleccionar un \u00fanico valor del stream que cumpla determinadas condiciones.</p> <p><code>findFirst</code> devuelve un objeto de tipo <code>Optional</code> para poder indicar un valor por defecto en caso de que no se pueda devovler ning\u00fan elemento del stream.</p>"},{"location":"ud7/6streams/#toarray","title":"<code>ToArray()</code>","text":"<p>Con este m\u00e9todo se puede convertir cualquier tipo de <code>Collection</code> en un array de forma sencilla.</p>"},{"location":"ud7/6streams/#min","title":"<code>Min()</code>","text":"<p>Con <code>min</code> se obtiene el elemento del stream con el valor m\u00ednimo calculado a partir de una expresi\u00f3n lambda de tipo <code>Comparator</code> que indicamos como par\u00e1metro.</p> <p><code>min</code> devuelve un objeto de tipo <code>Optional</code> para poder indicar un valor por defecto en caso de que no se pueda devolver ning\u00fan elemento del stream.</p>"},{"location":"ud7/6streams/#max","title":"<code>Max()</code>","text":"<p>Con <code>max</code> se obtiene el elemento del stream con el valor m\u00e1ximo calculado a partir de una expresi\u00f3n lambda de tipo <code>Comparator</code> que indicamos como par\u00e1metro de la expresi\u00f3n.</p> <p><code>max</code> devuelve un objeto de tipo <code>Optional</code> para poder indicar un valor por defecto en caso de que no se pueda devolver ning\u00fan elemento del stream.</p>"},{"location":"ud7/7regularexpressions/","title":"Expresiones Regulares","text":"<p>Una expresi\u00f3n regular (regex) define un patr\u00f3n de b\u00fasqueda para cadenas. El patr\u00f3n de b\u00fasqueda puede ser cualquier cosa, desde un car\u00e1cter simple, una cadena fija o una expresi\u00f3n compleja que contenga caracteres especiales que describan el patr\u00f3n.</p> <p>Se puede usar una expresi\u00f3n regular para buscar, editar y manipular texto.</p> <p>La expresi\u00f3n regular se aplica en el texto de izquierda a derecha.</p> <p>Se usa ampliamente para definir la restricci\u00f3n en cadenas como contrase\u00f1a y validaci\u00f3n de correo electr\u00f3nico.</p> <p>Java Regex API proporciona 1 interfaz y 3 clases en el paquete java.util.regex:</p> <ul> <li>MatchResult interface</li> <li>Matcher class</li> <li>Pattern class</li> <li>PatternSyntaxException class</li> </ul>"},{"location":"ud7/7regularexpressions/#clases-de-caracteres-y-limites-de-coincidencia","title":"Clases de caracteres y l\u00edmites de coincidencia","text":"<p>La forma m\u00e1s simple de una expresi\u00f3n regular (regex) es una cadena, un literal, un String. Por ejemplo, \"Hola\" es una regex que coincide (matches) con la palabra \"Hola\".</p> <p>Si solo us\u00e1ramos literales como patr\u00f3n para buscar en un String, las regex no ser\u00edan muy interesantes. Por eso, se crearon las Character classes &amp; boundary matches.</p> <p>Los boundary matches o l\u00edmites de coincidencia son: ^ (al principio del String), $ (final del String), \\b (principio y final palabra).</p> <p>Una clase caracter es como un comod\u00edn y representa un conjunto o clase de caracteres.</p> Regex Descripci\u00f3n . Coincide con cualquier car\u00e1cter. ^pattern El s\u00edmbolo ^ indica al inicio del String. Encuentra la regex que coincide con el patr\u00f3n dado al comienzo del String. pattern$ El s\u00edmbolo $ indica el final del String. Encuentra la regex que coincide con el patr\u00f3n dado al final del String. [abc] Los corchetes representan un conjunto. El String debe coincidir con la/s letra/s dentro del corchete. [abc][12] El String debe coincidir con las letras a, b \u00f3 c, seguidas de 1 \u00f3 2. [^abc] El s\u00edmbolo ^ dentro de los corchetes indica negaci\u00f3n. El String debe coincidir con cualquier car\u00e1cter excepto a \u00f3 b \u00f3 c. [a-z1-9] Rango. Busca coincidir las letras min\u00fasculas de la a a la z (ambas incluidas) y los d\u00edgitos del 1 al 9 (ambos incluidos). a|b Encuentra en el String las ocurrencias de a \u00f3 b. ab Encuentra en el String todas las ocurrencias de 'a' seguido de una 'b'."},{"location":"ud7/7regularexpressions/#meta-caracteres","title":"Meta caracteres","text":"<p>Los siguientes metacaracteres tienen un significado predefinido y hacen que ciertos patrones comunes sean m\u00e1s f\u00e1ciles de usar. Por ejemplo, puede usar \\d como definici\u00f3n simplificada para [0..9].</p> Regex Descripci\u00f3n \\d Cualquier d\u00edgito. Equivale a [0-9]. \\D No d\u00edgito. Equivale a [^0-9]. \\s Espacio en blanco. Equivale a [ \\t\\n\\x0b\\r\\f] \\S No espacio en blanco. Equivale a [^\\s] \\w Una letra may\u00fascula o min\u00fascula, un d\u00edgito o el car\u00e1cter '_'. Equivale a  [a-zA-Z0-9_] \\W Equivale a [^\\w] \\S+ Varios caracteres que no son espacios en blanco \\b L\u00edmite de una palabra"},{"location":"ud7/7regularexpressions/#especificacion-de-modos-dentro-de-la-expresion-regular","title":"Especificaci\u00f3n de modos dentro de la expresi\u00f3n regular","text":"<p>Puede agregar los siguientes modificadores de modo al comienzo de la expresi\u00f3n regular. Para especificar m\u00faltiples modos, simplemente se juntan: (?ismx).</p> <ul> <li>(?i) hace que la expresi\u00f3n regular sea insensible a may\u00fasculas y min\u00fasculas.</li> <li>(?s) para \"modo de una sola l\u00ednea\" hace que el punto coincida con todos los caracteres, incluidos los saltos de l\u00ednea.</li> <li>(?m) para \"modo multil\u00ednea\" hace que el s\u00edmbolo de intercalaci\u00f3n y el d\u00f3lar coincidan al principio y al final de cada l\u00ednea en la cadena de asunto.</li> </ul>"},{"location":"ud7/7regularexpressions/#cuantificadores-regex","title":"Cuantificadores Regex","text":"<p>Los cuantificadores especifican el n\u00famero de ocurrencias de un car\u00e1cter.</p> <p>Un cuantificador define con qu\u00e9 frecuencia puede ocurrir un elemento. Los s\u00edmbolos ?, *, + y {} son calificadores.</p> Regex Descripci\u00f3n * Indica que ocurre 0 \u00f3 m\u00e1s veces. Equivale a {0,}. + Indica que ocurre 1 \u00f3 m\u00e1s veces. Equivale a {1,}. ? Indica que ocurre 0 \u00f3 1 veces. Equivale a {0,1}. {X} Indica que lo que va justo antes de las llaves {} se repite X n\u00famero de veces. {X, Y} Indica que lo que va justo antes de las llaves {} se repite m\u00ednimo X n\u00famero de veces y m\u00e1ximo Y. *? ? despu\u00e9s de un cuantificador lo convierte en un cuantificador perezoso (lazy). Intenta encontrar la coincidencia m\u00e1s peque\u00f1a. Esto hace que la expresi\u00f3n regular se detenga en la primera coincidencia. <p>En la documentaci\u00f3n de Oracle podemos ver todas las clases de caracteres que hay para construir una expresi\u00f3n regular.</p> <p>https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html</p>"},{"location":"ud7/7regularexpressions/#entrena-tus-regex","title":"Entrena tus Regex","text":"<p>https://regexcrossword.com/</p>"},{"location":"ud7/7regularexpressions/#java-regex-core-classes","title":"Java Regex Core Classes","text":"<p>La API de expresiones regulares de Java consta de dos clases principales. Estos son:</p> <p><code>Pattern</code> (java.util.regex.Pattern) <code>Matcher</code> (java.util.regex.Matcher)</p>"},{"location":"ud7/7regularexpressions/#clase-pattern","title":"Clase <code>Pattern</code>","text":"<p>La clase <code>Pattern</code> se utiliza para crear patrones (expresiones regulares). Un patr\u00f3n es una expresi\u00f3n regular precompilada en forma de objeto (como una instancia de patr\u00f3n), capaz de compararse con un texto.</p> <pre><code>String regex = \".*http://.*\";\n\nPattern pattern = Pattern.compile(regex);\n</code></pre>"},{"location":"ud7/7regularexpressions/#clase-matcher","title":"Clase <code>Matcher</code>","text":"<p>La clase <code>Matcher</code> se usa para hacer coincidir una expresi\u00f3n regular determinada (\u00f9na instancia de <code>Pattern</code>) con un texto varias veces. En otras palabras, buscar m\u00faltiples ocurrencias de la expresi\u00f3n regular en el texto. <code>Matcher</code> nos dir\u00e1 en qu\u00e9 parte del texto (\u00edndice de caracteres) encontr\u00f3 las ocurrencias. Puede obtener una instancia de Matcher a partir de una instancia de Pattern.</p> <p>Implementa la interfaz <code>MatchResult</code>.</p> <p>Algunos de los m\u00e9todos de la clase Matcher son:</p> <ul> <li>boolean matches(): prueba si la expresi\u00f3n regular coincide con el patr\u00f3n.</li> <li>booleano find(): encuentra la siguiente expresi\u00f3n que coincide con el patr\u00f3n.</li> <li>boolean find(int start): encuentra la siguiente expresi\u00f3n que coincide con el patr\u00f3n del n\u00famero de inicio dado.</li> <li>String group(): devuelve la subsecuencia coincidente.</li> <li>int start(): devuelve el \u00edndice inicial de la subsecuencia coincidente.</li> <li>int end(): devuelve el \u00edndice final de la subsecuencia coincidente.</li> <li>int groupCount(): devuelve el n\u00famero total de la subsecuencia coincidente.</li> </ul> <p>Ejemplo:</p> <pre><code>StringBuilder html = new StringBuilder(\"&lt;h1&gt;Head&lt;/h1&gt;\");\nhtml.append(\"&lt;h2&gt;Etiqueta h2 de encabezado&lt;/h2&gt;\");\nhtml.append(\"&lt;p&gt;Esto es un p\u00e1rrafo en html&lt;/p&gt;\");\nhtml.append(\"&lt;h2&gt;Resumen&lt;/h2&gt;\");\nhtml.append(\"&lt;p&gt;Fin del html&lt;/p&gt;\");\n\nPattern p = Pattern.compile(\"&lt;h2&gt;\");\nMatcher m = p.matcher(html);\nSystem.out.println(m.matches());\n</code></pre>"},{"location":"ud7/7regularexpressions/#reset","title":"reset()","text":"<p>El m\u00e9todo de la clase Matcher <code>reset()</code> restablece el estado de coincidencia internamente en el Matcher. En caso de que haya comenzado a hacer coincidir las ocurrencias en una cadena a trav\u00e9s del m\u00e9todo <code>find()</code>, el Matcher mantendr\u00e1 internamente un estado sobre qu\u00e9 tan lejos ha buscado a trav\u00e9s del texto de entrada. Al llamar a <code>reset()</code>, la coincidencia comenzar\u00e1 nuevamente desde el principio del texto.</p>"},{"location":"ud7/7regularexpressions/#group","title":"group()","text":"<p>Los grupos est\u00e1n marcados con par\u00e9ntesis en la expresi\u00f3n regular. Por ejemplo:</p> <p>(Hola)</p> <p>Esta expresi\u00f3n regular coincide con el texto Hola. Los par\u00e9ntesis no son parte del texto que se compara. Los par\u00e9ntesis marcan un grupo. Cuando se encuentra una coincidencia en un texto, puede obtener acceso a la parte de la expresi\u00f3n regular dentro del grupo.</p> <p>Para acceder a un grupo se utliza el m\u00e9todo <code>group(int groupNo)</code>. Una expresi\u00f3n regular puede tener m\u00e1s de un grupo. Por lo tanto, cada grupo est\u00e1 marcado con un conjunto separado de par\u00e9ntesis. Para obtener acceso al texto que coincidi\u00f3 con la subparte de la expresi\u00f3n en un grupo espec\u00edfico, se pasa el n\u00famero del grupo al m\u00e9todo <code>group(int groupNo)</code>.</p> <p>El grupo con el n\u00famero 0 es siempre la expresi\u00f3n regular completa. Para obtener acceso a un grupo marcado entre par\u00e9ntesis, debe comenzar con los n\u00fameros de grupo 1.</p> <p>Ejemplo:</p> <pre><code>String text    =\n\"John writes about this, and John writes about that,\" +\n\" and John writes about everything. \"\n;\n\nString patternString1 = \"(John)\";\n\nPattern pattern = Pattern.compile(patternString1);\nMatcher matcher = pattern.matcher(text);\n\nwhile(matcher.find()) {\nSystem.out.println(\"found: \" + matcher.group(1)); //el primer grupo de par\u00e9ntesis\n}\n</code></pre> <p>OUTPUT</p> <p>found: John</p> <p>found: John</p> <p>found: John</p>"},{"location":"ud7/7regularexpressions/#operadores-logicos","title":"Operadores l\u00f3gicos","text":"<p>La API de Java Regex admite un conjunto de operadores l\u00f3gicos que se pueden usar para combinar m\u00faltiples subpatrones dentro de una sola expresi\u00f3n regular.</p> <p>Los operadores l\u00f3gicos son: el operador and, el operador or y el operador not.</p> <p>El operador and es impl\u00edcito. Si dos caracteres (u otros subpatrones) se suceden en una expresi\u00f3n regular, eso significa que tanto el primer como el segundo subpatr\u00f3n coinciden en gran medida con la cadena de destino.</p> <p>El operador or es expl\u00edcito y est\u00e1 representado por el car\u00e1cter vertical |.</p> <p>El operador not es expl\u00edcito, est\u00e1 representado por el s\u00edmbolo !, brinda la posibilidad de excluir un patr\u00f3n. Con esto se puede decir que una cadena no debe ir seguida de otra cadena.</p> <p>La anticipaci\u00f3n negativa (negative look ahead) se define a trav\u00e9s de (?!patr\u00f3n), el operador ? delante del par\u00e9ntesis es parte de la sintaxis look ahead, que siempre comienzan con un par\u00e9ntesis y un signo de interrogaci\u00f3n. Esta operaci\u00f3n no consume ning\u00fan car\u00e1cter.</p>"},{"location":"ud7/7regularexpressions/#ejemplo-expresion-regular-telefono-movil","title":"Ejemplo expresi\u00f3n regular tel\u00e9fono m\u00f3vil","text":"<pre><code>//(+34) 655-555-555\nString regexTelefono = \"^([\\\\(]{1}[\\\\+]{1}34[\\\\)]{1}[ ]{1}[0-9]{3}[\\\\-]{1}[0-9]{3}[\\\\-]{1}[0-9]{3})$\";\n\nString t1 = \"123456789\";//no\nString t2 = \"(+35) 123456-789\";//no\nString t3 = \"(+34) 123-456-789\";//si\nString t4 = \"(+34)123-456-789\";//no\n\nSystem.out.println(t1.matches(regexTelefono));//false\nSystem.out.println(t2.matches(regexTelefono));//false\nSystem.out.println(t3.matches(regexTelefono));//true\nSystem.out.println(t4.matches(regexTelefono));//false\n</code></pre>"},{"location":"ud8/1javafx/","title":"JavaFX","text":"<p>JavaFX es una plataforma de aplicaciones de cliente de pr\u00f3xima generaci\u00f3n de c\u00f3digo abierto para sistemas integrados, m\u00f3viles y de escritorio construidos en Java. Es un esfuerzo de colaboraci\u00f3n de muchas personas y empresas con el objetivo de producir un conjunto de herramientas moderno, eficiente y con todas las funciones para desarrollar aplicaciones de clientes enriquecidos.</p> <p>En este tema nos centraremos en las aplicaciones de escritorio. JavaFX est\u00e1 disponible en Windows, Mac OS X y Linux.</p> <p>Dado que la biblioteca JavaFX est\u00e1 escrita como una API de Java, el c\u00f3digo de la aplicaci\u00f3n JavaFX puede hacer referencia a las API de cualquier biblioteca de Java. Por ejemplo, las aplicaciones JavaFX pueden usar bibliotecas API de Java para acceder a las capacidades del sistema nativo y conectarse a aplicaciones de middleware basadas en servidor.</p> <p>Es en esencia un conjunto de paquetes en Java y el sucesor de swing.</p> <p>Documentaci\u00f3n oficial para JavaFX JDK11</p> <p>API documentation</p>"},{"location":"ud8/1javafx/#crear-un-nuevo-proyecto-javafx","title":"Crear un nuevo proyecto JavaFX","text":"<p>En IntelliJ, seleccionamos File -&gt; New Project</p> <p></p> <p>Seleccionamos JavaFX, lo llamamos HolaMundo y le damos a crear. Para ejecutarlo nos ponemos en la clase principal y hacemos click en Run.</p> <p></p>"},{"location":"ud8/1javafx/#workflow-de-una-aplicacion-javafx","title":"Workflow de una aplicaci\u00f3n JavaFX","text":"<ol> <li> <p><code>Application</code> La clase de <code>Application</code> del paquete javafx.application es el punto de entrada de la aplicaci\u00f3n en JavaFX. Para crear una aplicaci\u00f3n JavaFX, se debe heredar esta clase e implementar su m\u00e9todo abstracto <code>start()</code>. La clase principal tiene el nombre del proyecto seguido de Application y extiende de la clase <code>Application</code>, que es la que gestiona el ciclo de vida de una aplicaci\u00f3n JavaFX.</p> </li> <li> <p><code>main</code> method Cuando ejecutamos la aplicaci\u00f3n JavaFX por primera vez, se lanza el m\u00e9todo <code>main</code> que contiene el m\u00e9todo <code>launch</code> que lanza la aplicaci\u00f3n JavaFX y no vuelve hasta que se cierra la aplicaci\u00f3n.</p> </li> <li> <p><code>init</code> method Cuando un aplicaci\u00f3n JavaFX es lanzada, el m\u00e9todo <code>init</code> se ejecuta primero. Este m\u00e9todo se encuentra en la clase <code>Application</code> y est\u00e1 vac\u00edo, por lo que podremos sobreescribirlo si queremos hacer algo con \u00e9l.</p> </li> <li> <p><code>start</code> method El m\u00e9todo <code>start</code> se ejecuta justo despu\u00e9s del m\u00e9todo <code>init</code>. <code>start</code> es un m\u00e9todo abstracto que heredamos de la clase <code>Application</code> por lo que siempre hay que sobreescribirlo y darle cuerpo.</p> </li> <li> <p><code>stop</code> method Cuando la aplicaci\u00f3n acaba porque los usuario cierran la ventana de la aplicaci\u00f3n se ejecuta el m\u00e9todo <code>stop</code>. Igual que pasa con el m\u00e9todo <code>init</code>, este m\u00e9todo se encuentra en la clase <code>Application</code> y est\u00e1 vac\u00edo tambi\u00e9n. Si no lo sobreescribimos no se har\u00e1 nada con \u00e9l.</p> </li> </ol>"},{"location":"ud8/1javafx/#estructura-de-una-aplicacion-javafx","title":"Estructura de una aplicaci\u00f3n JavaFX","text":"<p>En general, una aplicaci\u00f3n JavaFX tendr\u00e1 tres componentes principales, Stage, Scene y Node como se muestra en la siguiente figura:</p> <p></p>"},{"location":"ud8/2stage/","title":"JavaFX Stage","text":"<p>Uno de los s\u00edmiles que m\u00e1s se aproxima para entender estos conceptos es ver el stage como un escenario, teatro o cine, en el cual, se desarrollan escenas. Dicho de otro modo, stage es un espacio y una escena define que sucede en ese espacio. Visto as\u00ed, tenemos que un stage es el contenedor de nivel superior, que como m\u00ednimo consta de una escena, que a su vez es contenedora de otros elementos.</p> <p>Si nuestra programa es una aplicaci\u00f3n de escritorio, el stage ser\u00e1 la ventana, con su barra de t\u00edtulo, y botones de maximizar, minimizar o cerrar, en el caso que que se ejecutase en un navegador web como Chrome, nuestro stage esta embebido dentro del navegador.</p> <p>Un <code>Stage</code> JavaFX, javafx.stage.Stage, es un contenedor de nivel superior y extiende de la clase <code>Window</code>. Representa una ventana en una aplicaci\u00f3n de escritorio JavaFX. Dentro de un stage JavaFX, se puede insertar un <code>Scene</code> JavaFX que representar\u00e1 el contenido que se muestra dentro de una ventana, dentro de un <code>Stage</code>.</p> <p>Cuando se inicia una aplicaci\u00f3n JavaFX, se crea un objeto <code>Stage</code> ra\u00edz que se pasa al m\u00e9todo <code>start(Stage primaryStage)</code> de la clase ra\u00edz de la aplicaci\u00f3n JavaFX. Este objeto Stage representa la ventana principal de la aplicaci\u00f3n. Se pueden crear m\u00e1s objetos nuevos <code>Stage</code> m\u00e1s adelante si la aplicaci\u00f3n necesita abrir m\u00e1s ventanas.</p> <p>Normalmente las aplicaciones tienen una ventana o stage de nivel superior, ya que muchas ventanas pueden conducir a una mala experiencia por parte del usuario.</p> <p></p>"},{"location":"ud8/2stage/#crear-un-stage","title":"Crear un <code>Stage</code>","text":"<pre><code>Stage stage = new Stage();\n</code></pre>"},{"location":"ud8/2stage/#mostrar-un-stage","title":"Mostrar un <code>Stage</code>","text":"<p>Solo con crear un objeto Stage no basta para que se muestre en la aplicaci\u00f3n. Para que el Stage sea visible, se debe llamar a su m\u00e9todo <code>show()</code> o <code>showAndWait()</code>.</p> <pre><code>stage.show();\n</code></pre> <p>La diferencia entre los m\u00e9todos <code>show()</code> y <code>showAndWait()</code>, es que show() hace visible el <code>Stage</code> y sale del m\u00e9todo inmediatamente, mientras que showAndWait() muestra el objeto <code>Stage</code> y luego lo bloquea (permanece dentro del m\u00e9todo showAndWait()) hasta que se cierre el <code>stage</code>.</p>"},{"location":"ud8/2stage/#establecer-un-scene-a-un-stage","title":"Establecer un <code>Scene</code> a un <code>Stage</code>","text":"<p>Para mostrar algo dentro de un <code>Stage</code>, se debe establecer un objeto <code>Scene</code> en el Stage. El contenido de <code>Scene</code> se mostrar\u00e1 dentro del Stage cuando se muestre el Stage.</p> <pre><code>VBox vBox = new VBox(new Label(\"A JavaFX Label\"));\nScene scene = new Scene(vBox);\n\nStage stage = new Stage();\nstage.setScene(scene);\nstage.show();\n</code></pre>"},{"location":"ud8/2stage/#ponerle-titulo-a-un-stage","title":"Ponerle t\u00edtulo a un <code>Stage</code>","text":"<p>El t\u00edtulo del <code>Stage</code> se muestra en la barra de t\u00edtulo de la ventana.</p> <pre><code>stage.setTitle(\"Aplicaci\u00f3n JavaFX\");\n</code></pre>"},{"location":"ud8/2stage/#posicionar-un-stage","title":"Posicionar un <code>Stage</code>","text":"<p>Se puede establecer la posici\u00f3n (X,Y) de un <code>Stage</code> a trav\u00e9s de sus m\u00e9todos setX() y setY(). Los m\u00e9todos setX() y setY() establecen la posici\u00f3n de la esquina superior izquierda de la ventana.</p> <pre><code>Stage stage = new Stage();\n\nstage.setX(50);\nstage.setY(50);\n</code></pre>"},{"location":"ud8/2stage/#dimensionar-un-stage","title":"Dimensionar un <code>Stage</code>","text":"<p>Para establecer el ancho y el alto de un <code>Stage</code> utilizaremos los m\u00e9todos <code>setWidth()</code> y <code>setHeight()</code>.</p> <pre><code>Stage stage = new Stage();\n\nstage.setWidth(600);\nstage.setHeight(300);\n</code></pre>"},{"location":"ud8/2stage/#establecer-una-ventana-modal","title":"Establecer una ventana modal","text":"<p>Si queremos establecer la ventana como modal en un <code>Stage</code> usamos el m\u00e9todo <code>initModality()</code>. La modalidad determina si la ventana que representa el Stage bloquear\u00e1 otras ventanas abiertas por la misma aplicaci\u00f3n.</p> <pre><code>@Override\npublic void start(Stage primaryStage) {\nprimaryStage.setTitle(\"JavaFX App\");\n\nStage stage = new Stage();\nstage.initModality(Modality.APPLICATION_MODAL);\n//stage.initModality(Modality.WINDOW_MODAL);\n//stage.initModality(Modality.NONE);\n\nprimaryStage.show();\n\nstage.showAndWait();\n\n}\n</code></pre> <ul> <li>Modalidad.APPLICATION_MODAL, bloquear\u00e1 todas las dem\u00e1s ventanas abiertas por esta aplicaci\u00f3n. No puede acceder a ninguna otra ventana hasta que se haya cerrado esta ventana.</li> <li>Modality.WINDOW_MODAL el <code>Stage</code> creado bloquear\u00e1 la ventana del <code>Stage</code> que \"posee\" (propietario) el <code>Stage</code> creado, pero solo eso. No todas las ventanas de la aplicaci\u00f3n.</li> <li>Modalidad.NONE el <code>Stage</code> no bloquear\u00e1 ninguna otra ventana abierta en esta aplicaci\u00f3n.</li> </ul>"},{"location":"ud8/2stage/#establecer-propietario-de-un-stage","title":"Establecer propietario de un <code>Stage</code>","text":"<p>Un <code>Stage</code> puede ser propiedad de otro <code>Stage</code>. El propietario de un stage se establece a trav\u00e9s de su m\u00e9todo <code>initOwner()</code>.</p> <pre><code>@Override\npublic void start(Stage primaryStage) {\nprimaryStage.setTitle(\"JavaFX App\");\n\nStage stage = new Stage();\nstage.initModality(Modality.WINDOW_MODAL);\n\nstage.initOwner(primaryStage);\n\nprimaryStage.show();\n\nstage.showAndWait();\n}\n</code></pre>"},{"location":"ud8/2stage/#dar-estilo-a-un-stage","title":"Dar estilo a un <code>Stage</code>","text":"<p>Se puede dar estilo a un stage utilizando el m\u00e9todo <code>initStyle()</code>. Hay un conjunto de estilos diferentes:</p> <ul> <li>DECORATED: es una ventana est\u00e1ndar con decoraciones del sistema operativo (barra de t\u00edtulo y botones para minimizar/maximizar/cerrar) y un fondo blanco.</li> <li>UNDECORATED: es una ventana est\u00e1ndar sin decoraciones del sistema operativo, pero a\u00fan con un fondo blanco.</li> <li>TRANSPARENT: es una ventana sin decorar con un fondo transparente.</li> <li>UNIFIED: es como un escenario decorado, excepto que no tiene borde entre el \u00e1rea de decoraci\u00f3n y el \u00e1rea de contenido principal.</li> <li>UTILITY: es una ventana decorada, pero con decoraciones m\u00ednimas.</li> </ul> <pre><code>stage.initStyle(StageStyle.DECORATED);\n</code></pre>"},{"location":"ud8/2stage/#stage-a-pantalla-completa","title":"<code>Stage</code> a pantalla completa","text":"<p>Se puede establecer el stage a modo de pantalla completa a trav\u00e9s del m\u00e9todo <code>setFullScreen()</code>. Nota: puede que no obtengamos el resultado esperado sino a\u00f1adimos un <code>Scene</code> en el stage.</p> <pre><code>VBox vbox = new VBox();\nScene scene = new Scene(vbox);\n\nprimaryStage.setScene(scene);\nprimaryStage.setFullScreen(true);\n\nprimaryStage.show();\n</code></pre>"},{"location":"ud8/2stage/#eventos-del-ciclo-de-vida-de-un-stage","title":"Eventos del ciclo de vida de un <code>Stage</code>","text":"<p><code>Stage</code> emite algunos eventos que se pueden escuchar.</p> <ul> <li>Close Request: se recibe una notificaci\u00f3n cuando el usuario hace click en el bot\u00f3n con la X en la esquina superior derecha de la ventana del escenario. Escuchar el evento de cierre del escenario puede ser \u00fatil si se necesita limpiar algunos recursos despu\u00e9s de cerrar la ventana principal del escenario, o p. necesita detener algunos hilos, etc.</li> </ul> <pre><code>primaryStage.setOnCloseRequest((event) -&gt; {\nSystem.out.println(\"Closing Stage\");\n});\n</code></pre> <ul> <li>Hiding: se llama antes de que se oculte el stage, pero despu\u00e9s de que se haya solicitado ocultarlo.</li> </ul> <pre><code>primaryStage.setOnHiding((event) -&gt; {\nSystem.out.println(\"Hiding Stage\");\n});\n</code></pre> <ul> <li>Hidden: se llama despu\u00e9s de que se oculta el Stage.</li> </ul> <pre><code>primaryStage.setOnHidden((event) -&gt; {\nSystem.out.println(\"Stage hidden\");\n});\n</code></pre> <ul> <li>Showing: se llama despu\u00e9s de que se solicite que se muestre el stage, pero antes de que se muestre.</li> </ul> <pre><code>primaryStage.setOnShowing((event) -&gt; {\nSystem.out.println(\"Showing Stage\");\n});\n</code></pre> <ul> <li>Shown: se llama despu\u00e9s de que se muestre el stage.</li> </ul> <pre><code>primaryStage.setOnShown((event) -&gt; {\nSystem.out.println(\"Stage Shown\");\n});\n</code></pre>"},{"location":"ud8/2stage/#eventos-de-teclado-del-stage","title":"Eventos de teclado del <code>Stage</code>","text":"<p>Podemos escuchar eventos de teclado en un stage. De esta forma, se puede capturar todos los eventos del teclado que ocurren mientras el stage tiene el foco. Ejemplo que escucha las teclas ESC y Retorno en el teclado cuando un Stage tiene foco:</p> <pre><code>primaryStage.addEventHandler(KeyEvent.KEY_PRESSED,  (event) -&gt; {\nSystem.out.println(\"Key pressed: \" + event.toString());\n\nswitch(event.getCode().getCode()) {\ncase 27 : { // 27 = ESC key\nprimaryStage.close();\nbreak;\n}\ncase 10 : { // 10 = Return\nprimaryStage.setWidth( primaryStage.getWidth() * 2);\n}\ndefault:  {\nSystem.out.println(\"Unrecognized key\");\n}\n}\n});\n</code></pre>"},{"location":"ud8/3scene/","title":"JavaFX Scene","text":"<p>Para mostrar cualquier cosa en un escenario <code>Stage</code> se necesita una escena <code>Scene</code>. Un <code>Stage</code> solo puede mostrar una escena a la vez, pero es posible intercambiar la escena en tiempo de ejecuci\u00f3n. Al igual que un escenario en un teatro se puede reorganizar para mostrar varias escenas durante una obra, un objeto de escenario (stage) en JavaFX puede mostrar varias escenas (una a la vez) durante la vida \u00fatil de una aplicaci\u00f3n JavaFX.</p> <p>Quiz\u00e1s se pregunte por qu\u00e9 una aplicaci\u00f3n JavaFX tendr\u00eda m\u00e1s de una escena por etapa. Imagina un juego de computadora. Un juego puede tener m\u00faltiples \"pantallas\" para mostrar al usuario. Por ejemplo, una pantalla de men\u00fa inicial, la pantalla principal del juego (donde se juega el juego), una pantalla de finalizaci\u00f3n del juego y una pantalla de puntuaci\u00f3n m\u00e1s alta. Cada una de estas pantallas puede ser representada por una escena diferente. Cuando el juego necesita cambiar de una pantalla a la siguiente, simplemente adjunta la escena correspondiente al objeto Stage de la aplicaci\u00f3n JavaFX.</p> <p>Una escena est\u00e1 representada por un objeto <code>Scene</code> dentro de una aplicaci\u00f3n JavaFX.</p> <p>Note</p> <p>Para que un objeto <code>Scene</code> sea visible debe configurarse en un <code>Stage</code>.</p>"},{"location":"ud8/3scene/#scene-graph","title":"Scene Graph","text":"<p>Todos los componentes visuales (controls, layouts, etc.) deben adjuntarse a un <code>Scene</code> para ser mostrados, y ese <code>Scene</code> debe adjuntarse a un <code>Stage</code> para que la escena completa sea visible. El objeto gr\u00e1fico total final de todos los controles, layouts, etc. adjuntos a un <code>Scene</code> se denomina gr\u00e1fico de escena (Scene Graph).</p> <p>Consta de todos los nodos que se adjuntan a un objeto de Scene determinado. Cada objeto Scene tiene su propio gr\u00e1fico de escena.</p> <p>El Scene Graph tiene un \u00fanico nodo ra\u00edz. Se pueden adjuntar otros nodos al nodo ra\u00edz en una estructura de datos similar a un \u00e1rbol (un \u00e1rbol es una especie de gr\u00e1fico).</p>"},{"location":"ud8/3scene/#crear-un-scene","title":"Crear un Scene","text":"<p>Para crear un objeto <code>Scene</code> lo haremos a trav\u00e9s de su constructor. Como par\u00e1metro, se debe pasar el componente ra\u00edz de la GUI de JavaFX que actuar\u00e1 como la vista ra\u00edz que se mostrar\u00e1 dentro de la escena.</p> <pre><code>VBox  vBox  = new VBox();\nScene scene = new Scene(vBox);\n</code></pre>"},{"location":"ud8/3scene/#establecer-un-scene-en-un-stage","title":"Establecer un Scene en un Stage","text":"<p>Para hacer visible un <code>Scene</code> debe asignarse a un <code>Stage</code>.</p> <pre><code>VBox vBox = new VBox(new Label(\"A JavaFX Label\"));\nScene scene = new Scene(vBox);\n\nStage stage = new Stage();\nstage.setScene(scene);\n</code></pre> <p>Un Scene se puede adjuntar a un solo Stage a la vez, y el Stage tambi\u00e9n puede mostrar solo un Scene a la vez.</p>"},{"location":"ud8/3scene/#scene-mouse-cursor","title":"Scene Mouse Cursor","text":"<p>Es posible configurar el cursor del mouse de un <code>Scene</code>. Se establece el cursor del mouse de una escena a trav\u00e9s del m\u00e9todo <code>setCursor()</code>.</p> <pre><code>scene.setCursor(Cursor.OPEN_HAND);\n</code></pre> <p>La clase <code>javafx.scene.Cursor</code> contiene muchas constantes que puede usar para especificar qu\u00e9 cursor del mouse desea mostrar. Algunas de estas constantes son:</p> <ul> <li>Cursor.OPEN_HAND</li> <li>Cursor.CLOSED_HAND</li> <li>Cursor.CROSSHAIR</li> <li>Cursor.DEFAULT</li> <li>Cursor.HAND</li> <li>Cursor.WAIT</li> <li>Cursor.MOVE</li> </ul> <p>Puede consultar el resto en la documentaci\u00f3n oficial de JavaFX.</p>"},{"location":"ud8/4node/","title":"JavaFX Node","text":"<p>La clase <code>Node</code>, javafx.scene.Node, es la clase base (superclase) para todos los componentes agregados a JavaFX Scene Graph. La clase <code>Node</code> es abstracta, por lo que solo agregar\u00e1 subclases de la clase Node al Scene Graph. Todas las instancias de <code>Node</code> en el escenario gr\u00e1fico comparten un conjunto de propiedades comunes que est\u00e1n definidas por la clase JavaFX <code>Node</code> y que veremos a continuaci\u00f3n.</p>"},{"location":"ud8/4node/#conceptos-basicos-de-node","title":"Conceptos b\u00e1sicos de <code>Node</code>","text":"<p>Cada instancia de <code>Node</code> (subclase) solo se puede agregar al Scene Graph una vez. En otras palabras, cada instancia de Node solo puede aparecer en un lugar en el escenario gr\u00e1fico. Si intenta agregar la misma instancia de Node, o instancia de subclase de Node, al gr\u00e1fico de escena m\u00e1s de una vez, se generar\u00e1 una excepci\u00f3n.</p> <p>Un nodo JavaFX a veces puede tener subelementos, que tambi\u00e9n se denominan elementos secundarios.</p> <p>Una vez que se adjunta una instancia de node al gr\u00e1fico de escena, solo el hilo de la aplicaci\u00f3n JavaFX puede modificar la instancia de node.</p>"},{"location":"ud8/4node/#propiedades-de-javafx-node","title":"Propiedades de JavaFX <code>Node</code>","text":"<p>La clase <code>Node</code> y, por lo tanto, todas las subclases de Node, tienen las siguientes propiedades comunes:</p>"},{"location":"ud8/4node/#1-sistema-de-coordenadas-coordinate-system","title":"1. Sistema de coordenadas (Coordinate System)","text":"<p>Cada nodo JavaFX tiene su propio sistema de coordenadas cartesianas. La \u00fanica diferencia con un sistema de coordenadas cartesianas regular es que el eje Y est\u00e1 invertido. Eso significa que el origen del sistema de coordenadas est\u00e1 en la esquina superior izquierda del sistema de coordenadas. A medida que aumentan los valores de Y, el punto se mueve hacia abajo desde la parte superior del sistema de coordenadas. Esta inversi\u00f3n del eje Y es normal en los sistemas de coordenadas de gr\u00e1ficos 2D.</p> <p></p> <p>Es posible que un nodo JavaFX tenga coordenadas X e Y negativas.</p> <p>Cada nodo tiene su propio sistema de coordenadas. Este sistema de coordenadas se utiliza para colocar instancias de nodos secundarios dentro del nodo principal o al dibujar en un lienzo JavaFX. Eso significa que un nodo que es hijo de otro nodo tiene su propio sistema de coordenadas y una ubicaci\u00f3n (X,Y) dentro del sistema de coordenadas de su nodo principal.</p> <p>A continuaci\u00f3n se muestra un ejemplo de un sistema de coordenadas de nodo principal en el que un nodo secundario est\u00e1 ubicado en (25,25) en el sistema de coordenadas del nodo principal. El nodo secundario tambi\u00e9n tiene su propio sistema de coordenadas que tiene su (0,0) donde el nodo secundario se encuentra en el sistema de coordenadas principal, es decir, en (25,25) en el sistema de coordenadas del nodo principal.</p> <p></p>"},{"location":"ud8/4node/#2-cuadro-delimitador-bounding-box","title":"2. Cuadro delimitador (Bounding Box)","text":"<p>Un nodo JavaFX tiene un cuadro delimitador. El cuadro delimitador es un cuadro l\u00f3gico alrededor de la forma del nodo. El nodo completo se encuentra dentro del cuadro delimitador, es decir, gr\u00e1ficamente. En otras palabras, todas las esquinas y bordes del Nodo est\u00e1n contenidos dentro del cuadro delimitador, y no hay espacio adicional alrededor del Nodo, a menos que se agregue a trav\u00e9s de un efecto, relleno u otra cosa aplicada al Nodo.</p> <p>En realidad, un nodo tiene 3 cuadros delimitadores:</p> <ul> <li>layoutBounds Los l\u00edmites del nodo en su propio espacio de coordenadas, sin aplicar ning\u00fan efecto, recorte o transformaci\u00f3n.</li> <li>boundsInLocal Los l\u00edmites del nodo en su propio espacio de coordenadas, con efectos y clip aplicados, pero sin transformaciones.</li> <li>boundsInParent Los l\u00edmites del nodo en su espacio de coordenadas principal, con efectos, recorte y transformaciones aplicadas.</li> </ul> <p>Cada una de estas dimensiones del cuadro delimitador se puede leer desde sus propiedades correspondientes con el mismo nombre, es decir, propiedades denominadas layoutBounds,boundsInLocal yboundsInParent.</p> <p>El cuadro boundsInParent es utilizado por el nodo padre (padre) para dise\u00f1ar sus hijos. El nodo principal necesita conocer el espacio total, incluidos todos los efectos, clips y transformaciones de un nodo para poder asignarle espacio.</p>"},{"location":"ud8/4node/#3-layoutx-y-layouty","title":"3. layoutX y layoutY","text":"<p>Las propiedades layoutX y layoutY de un objeto de nodo contienen la X y la Y del nodo dentro de su padre.</p>"},{"location":"ud8/4node/#4-preferred-height-and-width","title":"4. Preferred height and width","text":"<p>Las propiedades de ancho y alto preferidas de un objeto de nodo especifican el ancho y alto preferidos del objeto de nodo dado (normalmente subclase de nodo). No todas las clases de nodos principales respetar\u00e1n el ancho preferido y la altura preferida de un nodo secundario. Depende de la implementaci\u00f3n concreta del nodo padre.</p>"},{"location":"ud8/4node/#5-minimum-height-and-minimum-width","title":"5. Minimum height and Minimum width","text":"<p>Las propiedades m\u00ednimas de ancho y alto de un objeto de nodo JavaFX especifican el ancho y el alto m\u00ednimos que un nodo quiere (o necesita) para mostrarse. No todas las clases de nodos principales pueden respetar estas propiedades. Depende de la implementaci\u00f3n concreta del nodo padre.</p>"},{"location":"ud8/4node/#6-maximum-height-and-maximum-width","title":"6. Maximum height and Maximum width","text":"<p>Las propiedades m\u00e1ximas de ancho y alto de un objeto de nodo especifican el ancho y alto m\u00e1ximo que un nodo quiere (o necesita) para mostrarse. No todas las clases de nodos principales pueden respetar estas propiedades. Depende de la implementaci\u00f3n concreta del nodo padre.</p>"},{"location":"ud8/4node/#7-user-data","title":"7. User data","text":"<p>Puede establecer datos de usuario en un nodo utilizando el m\u00e9todo <code>setUserData()</code>. Este m\u00e9todo toma cualquier objeto Java de su elecci\u00f3n. De esta manera puede adjuntar, por ejemplo objetos de instancias de nodo.</p>"},{"location":"ud8/4node/#8-items-child-nodes","title":"8. Items (Child nodes)","text":"<p>Muchas subclases de nodos pueden contener elementos o nodos secundarios. La forma exacta en que agrega y accede a estos nodos secundarios depende de la subclase de nodo concreta. Algunas clases tienen un m\u00e9todo <code>getItems()</code> que devuelve una lista de elementos. Otras clases tienen un m\u00e9todo <code>getChildren()</code> que hace lo mismo. Se tendr\u00e1 que comprobar la subclase de Nodo concreta para averiguar si puede tener elementos o nodos secundarios, y c\u00f3mo los agrega y accede a ellos.</p>"},{"location":"ud8/5uicontrols/","title":"UI Controls (User Interface Controls)","text":"<p>Los controles de la interfaz de usuario de JavaFX disponibles a trav\u00e9s de la API de JavaFX se crean mediante el uso de nodos en el gr\u00e1fico de escena. Pueden aprovechar al m\u00e1ximo las funciones visualmente ricas de la plataforma JavaFX y son port\u00e1tiles entre diferentes plataformas. JavaFX CSS permite la creaci\u00f3n de temas y estilos a los diferentes ontroles de la interfaz de usuario.</p> <p></p> <p>Las clases para construir controles de interfaz de usuario residen en el paquete <code>javafx.scene.control</code> de la API de JavaFX.</p> <p>La lista de controles de IU incluye componentes de IU t\u00edpicos que puede reconocer de su desarrollo anterior de aplicaciones cliente en Java. Sin embargo, el SDK de JavaFX presenta nuevos controles de interfaz de usuario de Java, como <code>TitledPane</code>, <code>ColorPicker</code> y <code>Pagination</code> entre otros.</p> <p>Podemos obtener informaci\u00f3n detallada sobre todos los controles de interfaz de usuario de JavaFX disponibles en Documentaci\u00f3n JavaFX UI y en la documentaci\u00f3n de la API para el paquete javafx.scene.control.</p>"},{"location":"ud8/5uicontrols/#funciones-y-efectos","title":"Funciones y efectos","text":"<p>Dado que los controles de la interfaz de usuario del paquete javafx.scene.control son extensiones de la clase Node, se pueden integrar con la representaci\u00f3n, la animaci\u00f3n, las transformaciones y las transiciones animadas del gr\u00e1fico de escena.</p> <p>Considere la tarea de crear un bot\u00f3n, aplicarle un reflejo y animar el bot\u00f3n alterando su opacidad de su valor m\u00e1ximo a su valor m\u00ednimo.</p> <p>La siguiente figura muestra tres estados del bot\u00f3n a trav\u00e9s de la l\u00ednea de tiempo de la animaci\u00f3n. La imagen de la izquierda muestra el bot\u00f3n cuando su opacidad se establece en 1,0, la imagen central muestra la opacidad establecida en 0,8 y la imagen de la derecha muestra la opacidad establecida en 0,5.</p> <p></p> <p>El siguiente ejemplo crea e inicia una l\u00ednea de tiempo indefinida, donde dentro de un cuadro de 600 milisegundos, la opacidad del bot\u00f3n cambia de su valor predeterminado (1,0) a 0,0.</p> <pre><code>Button button = new Button();\nbutton.setText(\"OK\");\nbutton.setFont(new Font(\"Tahoma\", 24));\nbutton.setEffect(new Reflection());\n\nfinal Timeline timeline = new Timeline();\ntimeline.setCycleCount(Timeline.INDEFINITE);\ntimeline.setAutoReverse(true);\nfinal KeyValue kv = new KeyValue(button.opacityProperty(), 0);\nfinal KeyFrame kf = new KeyFrame(Duration.millis(600), kv);\ntimeline.getKeyFrames().add(kf);\ntimeline.play();\n</code></pre> <p>Podemos aplicar otros efectos visuales disponibles en el paquete <code>javafx.scene.effect</code>, como sombra, iluminaci\u00f3n o desenfoque de movimiento.</p>"},{"location":"ud8/5uicontrols/#aplicar-estilo-a-los-controles-de-la-interfaz-de-usuario-con-css","title":"Aplicar estilo a los controles de la interfaz de usuario con CSS","text":"<p>Podemos personalizar el aspecto de los controles de la interfaz de usuario definiendo sus propias hojas de estilo en cascada (CSS). Usar CSS en aplicaciones JavaFX es muy similar a usar CSS en HTML, porque cada caso se basa en la misma especificaci\u00f3n de CSS. El estado visual de un control se define mediante el archivo .css, como se muestra en el ejemplo.</p> <pre><code>/*controlStyle.css */\n\n.scene{\n-fx-font: 14pt \"Cambria Bold\";\n-fx-color: #e79423;\n-fx-background: #67644e;\n}\n\n.button{\n-fx-text-fill: #006464;\n-fx-background-color: #e79423;\n-fx-border-radius: 20;\n-fx-background-radius: 20;\n-fx-padding: 5;\n}\n</code></pre> <pre><code>Scene scene = new Scene();\nscene.getStylesheets().add(\"uicontrolssample/controlStyle.css\");\n</code></pre> <p>Adem\u00e1s, tambi\u00e9n podemos definir el estilo de un control directamente en el c\u00f3digo de la aplicaci\u00f3n utilizando el m\u00e9todo <code>setStyle()</code>.</p>"},{"location":"ud8/5uicontrols/#graficos-charts","title":"Gr\u00e1ficos (Charts)","text":"<p>Adem\u00e1s de los elementos t\u00edpicos de una interfaz de usuario, JavaFX proporciona gr\u00e1ficos predefinidos en el paquete <code>javafx.scene.chart</code>. Actualmente se admiten los siguientes tipos de gr\u00e1ficos: gr\u00e1fico de \u00e1reas, gr\u00e1fico de barras, gr\u00e1fico de burbujas, gr\u00e1fico de l\u00edneas, gr\u00e1fico circular y gr\u00e1fico de dispersi\u00f3n. Un gr\u00e1fico puede contener varias series de datos.</p>"},{"location":"ud8/5uicontrols/#preferred-size-tamano-preferido","title":"Preferred Size (tama\u00f1o preferido)","text":"<p>Cada control calcula su preferred size en funci\u00f3n de su contenido, es decir, el alto y el ancho del control cuando se muestra.</p> <p>Por ejemplo, en el caso de un button se redimensionar\u00e1 a si mismo de forma que haya espacio suficiente para mostrar su contenido, en su caso el texto.</p>"},{"location":"ud8/6layouts/","title":"Layout","text":"<p>Los contenedores o paneles de dise\u00f1o (layout) nos permiten a\u00f1adir controles de la interfaz de usuario dentro de un gr\u00e1fico de escena de una aplicaci\u00f3n JavaFX sin tener que escribir el c\u00f3digo necesario para gestionar el posicionamiento o el cambio de tama\u00f1o de esos controles. El Layout gestionar\u00e1 todo eso por nosotros. La API de layout de JavaFX incluye 8 layouts:</p> <ol> <li><code>BorderPane</code>: presenta sus nodos de contenido en la regi\u00f3n superior, inferior, derecha, izquierda o central. </li> <li><code>HBox</code> organiza sus nodos de contenido horizontalmente en una sola fila y los dimensiona con sus tama\u00f1os preferidos. Normalmente usamos un HBox para dise\u00f1ar un conjunto de botones en un di\u00e1logo.</li> <li><code>VBox</code> organiza sus nodos de contenido verticalmente en una sola columna.</li> <li><code>StackPane</code> coloca sus nodos de contenido en una sola pila de atr\u00e1s hacia adelante.</li> <li><code>GridPane</code> permite al desarrollador crear una cuadr\u00edcula flexible de filas y columnas en la que dise\u00f1ar los nodos de contenido. Cada posici\u00f3n de la cuadr\u00edcula se llama celda. Un fila ser\u00e1 tan alta como el control m\u00e1s alto y una columna ser\u00e1 tan ancha como el control m\u00e1s ancho que contiene.</li> <li><code>FlowPane</code> organiza sus nodos de contenido en un \"flujo\" horizontal o vertical, envolvi\u00e9ndose en los l\u00edmites especificados de ancho (para horizontal) o alto (para vertical).</li> <li><code>TilePane</code> coloca sus nodos de contenido en mosaicos o celdas de dise\u00f1o de tama\u00f1o uniforme y los envuelve como hace <code>FlowPane</code>.</li> <li><code>AnchorPane</code> permite a los desarrolladores crear nodos de anclaje en la parte superior, inferior, izquierda o central del dise\u00f1o.</li> </ol> <p>Para lograr una estructura de dise\u00f1o deseada, se pueden anidar diferentes layouts dentro de una aplicaci\u00f3n JavaFX.</p> <p>En <code>HBox</code> y <code>VBox</code> si al reducir la ventana los hijos que contienen esos paneles no caben, entonces se cortan. En cambio, con <code>FlowPane</code>, pasan a la siguiente fila en el caso de que la orientaci\u00f3n sea horizontal y si es vertical pasar\u00edan a la siguiente columna.</p>"},{"location":"ud8/7events/","title":"Eventos","text":"<p>Cada vez que un usuario interact\u00faa con la aplicaci\u00f3n (nodos), se dice que ha ocurrido un evento. Existe un <code>UIThread</code> que est\u00e1 escuchando cuando lanzamos la aplicaci\u00f3n. Cuando el usuario hace algo el UIThread que est\u00e1 escuchando, mira a ver si se lanza un evento, y si es as\u00ed, env\u00eda el evento al controlador de eventos (event handler). El Event Handler se ejecuta en el subproceso del hilo UIThread. Mientras se ejecuta un evento del UIThread el usuario no puede interactuar con la aplicaci\u00f3n.</p> <p>Por ejemplo, hacer clic en un bot\u00f3n, mover el mouse, ingresar un car\u00e1cter a trav\u00e9s del teclado, seleccionar un elemento de la lista, desplazarse por la p\u00e1gina, etc. son ejemplos de actividades que provocan que suceda un evento.</p> <p>Un evento notifica que ha ocurrido algo importante. Los eventos suelen ser la parte \"primitiva\" de un sistema de eventos (tambi\u00e9n conocido como bus de eventos). Generalmente, un sistema de eventos tiene las siguientes 3 responsabilidades:</p> <ol> <li>Trigger an event (disparar un evento),</li> <li>Notify listeners (notificar a los oyentes partes interesadas) sobre el evento y</li> <li>Handle the event (manejar o procesar el evento).</li> </ol> <p>El mecanismo de notificaci\u00f3n de eventos lo realiza la plataforma JavaFX autom\u00e1ticamente. Por lo tanto, solo consideraremos c\u00f3mo disparar eventos, escuchar eventos y c\u00f3mo manejarlos.</p>"},{"location":"ud8/7events/#tipos-de-eventos","title":"Tipos de eventos","text":"<ul> <li>Eventos en primer plano (foreground events): requieren la interacci\u00f3n directa de un usuario. Se generan como consecuencia de la interacci\u00f3n de una persona con los componentes gr\u00e1ficos en una interfaz gr\u00e1fica de usuario. Por ejemplo, hacer clic en un bot\u00f3n, mover el mouse, ingresar un car\u00e1cter a trav\u00e9s del teclado, seleccionar un elemento de la lista, desplazarse por la p\u00e1gina, etc.</li> <li>Eventos de fondo (background events): no requieren la interacci\u00f3n del usuario final. Las interrupciones del sistema operativo, fallas de hardware o software, vencimiento del temporizador, finalizaci\u00f3n de la operaci\u00f3n son ejemplos de eventos en segundo plano.</li> </ul>"},{"location":"ud8/7events/#eventos-en-javafx","title":"Eventos en JavaFX","text":"<p>La clase denominada <code>Event</code> del paquete <code>javafx.event</code> es la clase base para un evento. Una instancia de cualquiera de sus subclases es un evento. JavaFX proporciona una amplia variedad de eventos. Algunos de ellos se enumeran a continuaci\u00f3n.</p> <ul> <li> <p>Mouse event: evento de entrada que ocurre cuando se hace clic en el mouse. Est\u00e1 representado por la clase denominada <code>MouseEvent</code>. Incluye acciones como hacer clic con el mouse, presionar el mouse, soltar el mouse, mover el mouse, objetivo ingresado con el mouse, objetivo salido del mouse, etc.</p> </li> <li> <p>Key event: evento de entrada que indica que se produjo una pulsaci\u00f3n de tecla en un nodo. Est\u00e1 representado por la clase denominada <code>KeyEvent</code>. Este evento incluye acciones como pulsaci\u00f3n de tecla, liberaci\u00f3n de tecla y escritura de tecla.</p> </li> <li> <p>Drag event: evento de entrada que ocurre cuando se arrastra el mouse. Est\u00e1 representado por la clase llamada <code>DragEvent</code>. Incluye acciones como arrastrar para insertar, arrastrar para soltar, etc.</p> </li> <li> <p>Window event: evento relacionado con las acciones de mostrar/ocultar ventanas. Est\u00e1 representado por la clase llamada <code>WindowEvent</code>.</p> </li> </ul>"},{"location":"ud8/7events/#manejo-de-eventos-event-handling","title":"Manejo de eventos (Event Handling)","text":"<p>Es el mecanismo que controla el evento y decide qu\u00e9 debe suceder, si ocurre un evento. Tiene el c\u00f3digo que se conoce como event handler que se ejecuta cuando ocurre un evento.</p> <p>En JavaFX cada evento tiene:</p> <ol> <li> <p>Target: el nodo en el que se produjo un evento. Un objetivo puede ser una ventana, una escena y un nodo.</p> </li> <li> <p>Source: la fuente a partir de la cual se genera el evento. Por ejemplo, el mouse es la fuente del evento.</p> </li> <li> <p>Type: tipo del evento ocurrido; en el caso de un evento del mouse, el tipo de evento es presionar el mouse y soltar el mouse.</p> </li> </ol> <p>Supongamos que tenemos una aplicaci\u00f3n que tiene botones. Si hace clic en un bot\u00f3n, la source ser\u00e1 el mouse, el target ser\u00e1 el nodo del bot\u00f3n presionado y el tipo de evento generado ser\u00e1 el clic del mouse.</p>"},{"location":"ud8/7events/#fases-del-manejo-de-eventos","title":"Fases del manejo de eventos","text":"<p>Cada vez que se genera un evento, JavaFX pasa por las siguientes fases.</p>"},{"location":"ud8/7events/#route-construction-construccion-de-rutas","title":"Route construction (Construcci\u00f3n de rutas)","text":"<p>Cada vez que se genera un evento, la ruta predeterminada/inicial del evento est\u00e1 determinada por la construcci\u00f3n de una cadena de env\u00edo de eventos. Es el camino desde el escenario hasta el Nodo fuente.</p> <p>A continuaci\u00f3n se muestra la cadena de env\u00edo de eventos para el evento generado, cuando hacemos clic en el bot\u00f3n en el escenario anterior: Stage -&gt; Scene -&gt; Button</p>"},{"location":"ud8/7events/#event-capturing-phase-fase-de-captura-de-eventos","title":"Event capturing phase (Fase de captura de eventos)","text":"<p>Despu\u00e9s de la fase anterior se dispara el evento. Este evento viaja a todos los nodos de la cadena de despacho anterior (de arriba a abajo). Si alguno de estos nodos tiene registrado un filtro (filter) para el evento generado, se ejecutar\u00e1. Si ninguno de los nodos en la cadena de despacho tiene un filtro para el evento generado, entonces se pasa al nodo de destino y finalmente el nodo de destino procesa el evento.</p>"},{"location":"ud8/7events/#event-bubbling-phase-fase-de-propagacion-de-eventos","title":"Event bubbling phase (Fase de propagaci\u00f3n de eventos)","text":"<p>Aqu\u00ed el evento viaja desde el nodo de destino hasta el nodo de Stage (de abajo hacia arriba). Si alguno de los nodos de la cadena de env\u00edo de eventos tiene un controlador (handler) registrado para el evento generado, se ejecutar\u00e1. Si ninguno de estos nodos tiene controladores para manejar el evento, entonces el evento llega al nodo ra\u00edz y finalmente se completar\u00e1 el proceso.</p>"},{"location":"ud8/7events/#event-handlers-and-filters","title":"Event handlers and filters","text":"<p>Los filter y handlers de eventos son aquellos que contienen la l\u00f3gica de la aplicaci\u00f3n para procesar un evento. Un nodo puede registrarse en m\u00e1s de un controlador/filtro (handler/filter).</p> <p>Como se mencion\u00f3 anteriormente, durante el evento, el procesamiento es un filtro que se ejecuta y durante la fase de propagaci\u00f3n del evento, se ejecuta un controlador. Todos los controladores y filtros implementan la interfaz EventHandler del paquete javafx.event.</p>"},{"location":"ud8/7events/#anadir-y-eliminar-un-event-filter","title":"A\u00f1adir y eliminar un event filter","text":"<p>Para agregar un filtro de eventos a un nodo, debe registrar este filtro utilizando el m\u00e9todo <code>addEventFilter()</code> de la clase Node.</p> <pre><code>//Creating the mouse event handler \nEventHandler&lt;MouseEvent&gt; eventHandler = new EventHandler&lt;MouseEvent&gt;() { @Override public void handle(MouseEvent e) { System.out.println(\"Hello World\"); boton.setFill(Color.DARKSLATEBLUE);  } };   //Adding event Filter \nboton.addEventFilter(MouseEvent.MOUSE_CLICKED, eventHandler);\n</code></pre> <p>Para eliminar un filter hacemos:</p> <pre><code>boton.removeEventFilter(MouseEvent.MOUSE_CLICKED, eventHandler);\n</code></pre>"},{"location":"ud8/7events/#anadir-y-eliminar-event-handler","title":"A\u00f1adir y eliminar event handler","text":"<p>Para agregar un controlador de eventos a un nodo, debe registrar este controlador mediante el m\u00e9todo <code>addEventHandler()</code> de la clase Node, como se muestra a continuaci\u00f3n.</p> <pre><code>//Creating the mouse event handler \nEventHandler&lt;MouseEvent&gt; eventHandler = new EventHandler&lt;MouseEvent&gt;() { @Override public void handle(MouseEvent e) { System.out.println(\"Hello World\"); boton.setFill(Color.DARKSLATEBLUE);             } };    //Adding the event handler \nboton.addEventHandler(MouseEvent.MOUSE_CLICKED, eventHandler);\n</code></pre> <p>Para eliminar:</p> <pre><code>boton.removeEventHandler(MouseEvent.MOUSE_CLICKED, eventHandler);\n</code></pre> <p>Controllers JavaFX</p>"},{"location":"ud9/1io/","title":"I/O Input/Output - Entrada/Salida de la informaci\u00f3n","text":"<p>Todo dato tiene un origen de entrada o un destino de salida (convenientemente en ingl\u00e9s: I/O). Input o entrada implica leer datos de una fuente y Output o salida implica escribirlos en un destino. Un programa trabaja con datos que provienen de una entrada la cual puede ser un teclado, un archivo en disco o un socket a trav\u00e9s de la red. As\u00ed mismo un programa genera resultados envi\u00e1ndolos a una salida la cual puede ser la pantalla, un archivo en disco o un socket a trav\u00e9s de la red. En Java, la conexi\u00f3n entre un programa y un origen o destino de datos se denomina flujo (en ingl\u00e9s: stream).</p> <p></p> <p>Un flujo de entrada (input stream) maneja los datos que fluyen hacia un programa. Un flujo de salida (output stream) maneja los datos que salen de un programa.</p> <p></p> <p>En las primeras versiones de Java el sistema de entrada/salida proporcionado en el paquete <code>java.io</code> era b\u00e1sico. En la versi\u00f3n 1.4 de Java se a\u00f1adi\u00f3 un nuevo sistema de entrada/salida llamado <code>java.NIO</code> (New IO) para suplir algunas de sus deficiencias que posteriormente en Java 7 se mejor\u00f3 a\u00fan m\u00e1s <code>java.NIO</code>. Entre las mejoras se incluyen permitir navegaci\u00f3n de directorios sencillo, soporte para reconocer enlaces simb\u00f3licos, leer atributos de ficheros como permisos e informaci\u00f3n como \u00faltima fecha de modificaci\u00f3n, soporte de entrada/salida as\u00edncrona y soporte para operaciones b\u00e1sicas sobre ficheros como copiar y mover ficheros.</p>"},{"location":"ud9/1io/#tipos-de-datos-caracteres-y-bytes","title":"Tipos de Datos - Caracteres y bytes","text":"<p>Existen dos tipos de flujos (streams) seg\u00fan el tipo de datos, flujos binarios y flujos de caracteres. Los tipos de datos que se pueden leer/escribir suelen ser bytes o caracteres y los m\u00e9todos que se utilizan son similares, pero se utilizan clases diferentes.</p> <p>Internamente, todos los datos consisten en patrones de bits agrupados en bytes. Entonces, l\u00f3gicamente, todos los flujos podr\u00edan llamarse \"flujos de bytes\" (byte streams). Sin embargo, los flujos destinados a bytes que representan caracteres se denominan \"flujos de caracteres\" (character streams) y todos los dem\u00e1s se denominan \"flujos de bytes\".</p> <p>Al escribir y leer datos de caracteres, \u00e9stos est\u00e1n en un formato legible para el ser humano, sin embargo, los datos binarios implican leer y escribir bytes que no son legibles si los abrimos en un editor de texto.</p> <ul> <li>Flujos binarios (byte streams): almacenan variables, clases del programa, archivos de imagen, sonido, etc. Por ejemplo, el archivo de c\u00f3digo de bytes creado por el compilador de Java contiene instrucciones de m\u00e1quina para la m\u00e1quina virtual de Java. Estos no est\u00e1n destinados a representar caracteres, y la entrada y salida de ellos debe usar flujos de bytes. Las clases principales para manejar estos flujos son las clases abstractas InputStream y OutputStream.</li> </ul> <p>Clases principales de InputStream:</p> <p></p> <p>Clases principales de OutputStream:</p> <p></p> <ul> <li>Flujos de caracteres (character streams): est\u00e1n optimizados para datos de caracteres. Se utilizan con frecuencia para leer/escribir ficheros de texto, xml y json. Las clases principales para manejar estos flujos son las clases abstractas Reader y Writer.</li> </ul> <p>Clases principales de Reader:</p> <p></p> <p>Clases principales de Writer:</p> <p></p> <p>La siguiente figura muestra la jerarqu\u00eda del paquete <code>java.io</code>. Los streams pueden estar orientados a bytes u orientados a caracteres. Cada tipo tiene flujos de entrada y flujos de salida.</p> <p></p>"},{"location":"ud9/1io/#flujos-orientados-a-bytes","title":"Flujos orientados a bytes","text":"<ul> <li>Dise\u00f1ado para entrada y salida de prop\u00f3sito general.</li> <li>Los datos pueden ser tipos de datos primitivos o bytes sin procesar.</li> </ul>"},{"location":"ud9/1io/#flujos-orientados-a-caracteres","title":"Flujos orientados a caracteres","text":"<ul> <li>Destinado a datos de caracteres.</li> <li>Los datos se transforman de/a caracteres Java de 16 bits utilizados dentro de los programas al formato utilizado externamente.</li> </ul>"},{"location":"ud9/1io/#tipos-de-acceso-a-ficheros","title":"Tipos de acceso a ficheros","text":"<ol> <li> <p>Acceso secuencial: Una lectura secuencial implica tener que acceder a un elemento antes de acceder al siguiente, es decir, de una manera lineal (sin saltos).</p> </li> <li> <p>Acceso aleatorio: los ficheros de acceso aleatorio permiten acceder a sus datos de una forma aleatoria, esto es indicando una determinada posici\u00f3n desde la que leer/escribir.</p> </li> </ol>"},{"location":"ud9/1io/#escribir-datos-en-un-fichero-binario","title":"Escribir datos en un fichero binario","text":"<p>La escritura en ficheros binarios representa el flujo de salida de bytes, es decir, necesitamos utilizar las clases que derivan de <code>OutputStream</code>. Se puede escribir datos en un fichero binario de muchas formas. Veamos un ejemplo utilizando la clase <code>FileOutputStream</code>.</p> <pre><code>public static void main(String[] args) {\ntry {\nDataOutputStream fos = new DataOutputStream(new FileOutputStream(\"datos.dat\"));\nfos.writeInt(0);\nfos.writeInt(1);\nfos.writeInt(33);\nfos.writeInt(-77);\nfos.close();\n} catch (FileNotFoundException e) { //todas pueden derivar de IOException\nSystem.out.println(e.getMessage());\n} catch (IOException e) {\nSystem.out.println(e.getMessage());\n}\n}\n</code></pre> <p>En el ejemplo, el constructor <code>FileOutputStream</code> abre el fichero <code>datos.dat</code> para escritura. Se crea un nuevo fichero; si un fichero antiguo tiene el mismo nombre, se eliminar\u00e1. Luego, un <code>DataOutputStream</code> se conecta al <code>FileOutputStream</code>.</p> <p><code>DataOutputStream</code> tiene m\u00e9todos para escribir datos primitivos en un flujo de salida. El m\u00e9todo writeInt() escribe los cuatro bytes de un tipo de datos int en la secuencia.</p> <p>El programa escribe cuatro enteros en el flujo de salida y luego cierra el flujo.</p> <p>Warning</p> <p>Siempre hay que cerrar el flujo para asegurarse de liberar todos los recursos asociados a \u00e9l y que el sistema operativo no consuma recursos.</p>"},{"location":"ud9/1io/#escritura-en-un-fichero-binario-usando-el-bufer","title":"Escritura en un fichero binario usando el b\u00fafer","text":"<p>Ahora vamos a escribir m\u00e1s enteros en el fichero. Para ello utilizamos <code>BufferedOutputStream</code>. Este b\u00fafer almacena los bytes antes de que se escriban en el disco. Recuerda que un b\u00fafer es un bloque de memoria que se usa para ensamblar datos antes de que se escriban todos a la vez.</p> <p>El almacenamiento en b\u00fafer hace que las operaciones de E/S sean m\u00e1s eficientes. Para un programa que realiza E/S masivas, el almacenamiento en b\u00fafer es esencial. La E/S es muy lenta en comparaci\u00f3n con las operaciones con almacenamiento principal. Sin almacenamiento en b\u00fafer, la E/S ser\u00eda muy, muy lenta.</p> <pre><code> public static void writeBuffer() {\ntry {\nDataOutputStream out = new DataOutputStream(\nnew BufferedOutputStream(\nnew FileOutputStream(\"datosBufer.dat\")));\nfor (int i = 0; i &lt; 1000; i++) {\nout.writeInt(i);\n}\nout.close();\n} catch (FileNotFoundException e) {\nthrow new RuntimeException(e);\n} catch (IOException e) {\nthrow new RuntimeException(e);\n}\n}\n</code></pre>"},{"location":"ud9/1io/#lectura-de-datos-en-un-fichero-binario","title":"Lectura de datos en un fichero binario","text":"<p>Para leer un fichero, primero hemos de preguntarnos un poco sobre \u00e9l, es decir, si fue escrito por un programa Java, entonces necesitaremos saber qu\u00e9 tipos de datos se usaron, y as\u00ed poder usar una subclase de <code>InputStream</code> para leer bytes para ese tipo de datos.</p> <p><code>InputStream</code>, como hemos visto en los diagramas, es una clase abstracta para objetos que leen flujos de bytes. Aunque, no todas las clases que derivan de ella est\u00e1n relacionadas con la entrada de ficheros de disco. Por ejemplo, <code>PipedInputStream</code> representa datos provenientes de otro programa en ejecuci\u00f3n.</p> <pre><code>public static void main(String[] args) {\nint sum = 0;\ntry {\nDataInputStream dis = new DataInputStream(new FileInputStream(\"datos.dat\"));\n\nsum += dis.readInt();\nsum += dis.readInt();\nsum += dis.readInt();\nsum += dis.readInt();\n\nSystem.out.println(sum);\ndis.close();\n} catch (FileNotFoundException e) { //todas pueden derivar de IOException\nSystem.out.println(e.getMessage());\n} catch (IOException e) {\nSystem.out.println(e.getMessage());\n}\n}\n</code></pre> <p>Al igual que en la escritura para la lectura tambi\u00e9n disponemos de la clase <code>BufferedInputStream</code>.</p>"},{"location":"ud9/1io/#path-vs-file","title":"Path vs File","text":"<p>En Java, <code>Path</code> y <code>File</code> son clases responsables de las operaciones de E/S de ficheros. Realizan las mismas funciones pero pertenecen a diferentes paquetes.</p>"},{"location":"ud9/1io/#javaiofile","title":"<code>java.io.File</code>","text":"<p>Las primeras versiones de Java incluyen el paquete <code>java.io</code>, que contiene casi todas las clases que podr\u00edamos necesitar para realizar operaciones de entrada y salida. La clase <code>File</code> es una representaci\u00f3n abstracta de nombres de rutas de archivos y directorios.</p>"}]}