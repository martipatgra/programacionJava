{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Programaci\u00f3n","text":"<p>Aqu\u00ed puedes encontrar los apuntes del m\u00f3dulo de Programaci\u00f3n, que se imparte en el primer curso del ciclo formativo de grado superior de Desarrollo de Aplicaciones Multiplataforma.</p> <p>La duraci\u00f3n del m\u00f3dulo es de 256 horas lectivas, a raz\u00f3n de  8 horas semanales.</p>"},{"location":"#resultados-de-aprendizaje-y-criterios-de-evaluacion","title":"Resultados de aprendizaje y criterios de evaluaci\u00f3n","text":"<ul> <li>RA1: Reconoce la estructura de un programa inform\u00e1tico, identificando y relacionando los elementos propios del lenguaje de programaci\u00f3n utilizado.</li> </ul> Criterios de evaluaci\u00f3n Se han identificado los bloques que componen la estructura de un programa inform\u00e1tico. Se han creado proyectos de desarrollo de aplicaciones Se han utilizado entornos integrados de desarrollo. Se han identificado los distintos tipos de variables y la utilidad espec\u00edfica de cada uno. Se ha modificado el c\u00f3digo de un programa para crear y utilizar variables. Se han creado y utilizado constantes y literales. Se han clasificado, reconocido y utilizado en expresiones los operadores del lenguaje. Se ha comprobado el funcionamiento de las conversiones de tipo expl\u00edcitas e impl\u00edcitas. Se han introducido comentarios en el c\u00f3digo. <ul> <li>RA2: Escribe y prueba programas sencillos, reconociendo y aplicando los fundamentos de la programaci\u00f3n orientada a objetos.</li> <li>RA3: Escribe y depura c\u00f3digo, analizando y utilizando las estructuras de control del lenguaje.</li> <li>RA4: Desarrolla programas organizados en clases analizando y aplicando los principios de la programaci\u00f3n orientada a objetos.</li> <li>RA5: Realiza operaciones de entrada y salida de informaci\u00f3n, utilizando procedimientos espec\u00edficos del lenguaje y librer\u00edas de clases.</li> <li>RA6: Escribe programas que manipulen informaci\u00f3n seleccionando y utilizando tipos avanzados de datos.</li> <li>RA7: Desarrolla programas aplicando caracter\u00edsticas avanzadas de los lenguajes orientados a objetos y del entorno de programaci\u00f3n.</li> <li>RA8: Utiliza bases de datos orientadas a objetos, analizando sus caracter\u00edsticas y aplicando t\u00e9cnicas para mantener la persistencia de la informaci\u00f3n.</li> <li>RA9: Gestiona informaci\u00f3n almacenada en bases de datos relacionales manteniendo la integridad y consistencia de los datos.</li> </ul>"},{"location":"#unidades-didacticas-temporalizacion","title":"Unidades did\u00e1cticas / Temporalizaci\u00f3n","text":"<p>A continuaci\u00f3n se muestran las unidades did\u00e1cticas y una estimaci\u00f3n temporal de cada una de ellas. El curso est\u00e1 dividido en 10 unidades did\u00e1cticas distribuidas en tres evaluaciones.</p>"},{"location":"#primera-evaluacion","title":"Primera evaluaci\u00f3n","text":"<p>Compuesta por las 4 primeras unidades, donde se estudiar\u00e1n los aspectos b\u00e1sicos de la programaci\u00f3n orientada a objetos usando el lenguaje de programaci\u00f3n Java.</p> Unidad T\u00edtulo 1 Elementos de un programa inform\u00e1tico 2 Estructuras b\u00e1sicas de control 3 Programaci\u00f3n orientada a objetos. Clases y Objetos 4 Arrays"},{"location":"#segunda-evaluacion","title":"Segunda evaluaci\u00f3n","text":"<p>Incluye 3 unidades y se profundizar\u00e1 en aspectos de codificaci\u00f3n como colecciones de Java, interfaces de usuario, reflections, expresiones regulares, etc.</p> Unidad T\u00edtulo 5 Programaci\u00f3n orientada a objetos avanzada 6 Colecciones 7 Programaci\u00f3n avanzada"},{"location":"#tercera-evaluacion","title":"Tercera evaluaci\u00f3n","text":"<p>Por \u00faltimo se aprender\u00e1n t\u00e9cnicas de lectura y escritura y persistencia de la informaci\u00f3n en ficheros y bases de datos.</p> Unidad T\u00edtulo 8 Interfaces de usuario 9 Entrada/Salida de la informaci\u00f3n 10 Persistencia de la informaci\u00f3n"},{"location":"#instrumentos-de-calificacion","title":"Instrumentos de calificaci\u00f3n","text":"<p>Como instrumentos de calificaci\u00f3n se utilizan:</p> <ul> <li>Desarrollo de programas </li> <li>Prototipos</li> <li>Memorias de resultados de pr\u00e1cticas</li> <li>Pruebas de evaluaci\u00f3n que incluyen cuestionarios y/o ejercicios pr\u00e1cticos</li> </ul>"},{"location":"#evaluacion","title":"Evaluaci\u00f3n","text":"<p>La evaluaci\u00f3n se realiza utilizando los diferentes instrumentos de calificaci\u00f3n vinculados con los criterios de evaluaci\u00f3n de cada uno de los resultados de aprendizaje que sirven como indicadores del \u00e9xito alcanzado con ese RA. </p> <p>Los RA tienen una ponderaci\u00f3n espec\u00edfica que determina la nota final del m\u00f3dulo.</p>"},{"location":"about/","title":"About me \u2764\ufe0f\u200d\ud83d\udd25","text":"<p>Mi nombre es Patricia Mart\u00ed, soy Ingeniera en Inform\u00e1tica. Durante casi una d\u00e9cada me dediqu\u00e9 al desarrollo software de manera profesional en diferentes empresas nacionales e internacionales. </p> <p>Actualmente, soy docente en el campo de la programaci\u00f3n, donde puedo compartir con entusiasmo y pasi\u00f3n los conocimientos y habilidades aprendidas durante mi trayectoria. </p> <p>Mi objetivo es inspirar a la pr\u00f3xima generaci\u00f3n de desarrolladores y ayudarles a adentrarse en el emocionante mundo de la programaci\u00f3n y la tecnolog\u00eda.</p> <p>Para cualquier consulta o mejora, pueden escribirme a trav\u00e9s de mi correo electr\u00f3nico p.marti2@edu.gva.es.</p>"},{"location":"shortcuts/","title":"Atajos de teclado para IntelliJ","text":""},{"location":"shortcuts/#codigo","title":"C\u00f3digo","text":""},{"location":"shortcuts/#eliminar-imports-que-no-se-usan-ctrl-alt-o","title":"Eliminar imports que no se usan --&gt; CTRL + ALT + o","text":""},{"location":"shortcuts/#formatear-el-codigo-ctrl-alt-l","title":"Formatear el c\u00f3digo --&gt; CTRL + ALT + l","text":""},{"location":"ud1/121conceptosbasicos/","title":"\ud83d\udcbe \u00bfQu\u00e9 es JAVA ?","text":""},{"location":"ud1/121conceptosbasicos/#historia-de-java","title":"Historia de Java","text":"<p>Java es un lenguaje de programaci\u00f3n orientado a objetos. Fue creado por James Gosling en 1995. Oracle lo compr\u00f3. Es un lenguaje indepediente de la plataforma donde va a ser ejecutado, esto significa, que una vez que se compila (.class tambi\u00e9n llamado bytecode) puede ser transportado a diferentes plataformas (Windows, MacOS, Linux) para ser ejecutado. \u00bfC\u00f3mo se hace esto? Utilizando la JVM (Java Virtual Machine). La JVM coge los bytecode compilados y los interpreta dependiendo del OS para poder ser ejecutado. Por tanto, el bytecode siempre es el mismo, pero lo que genera la JVM cambiar\u00e1 para cada SO. Tambi\u00e9n existen otros t\u00e9rminos muy famosos relacionados con Java como JRE y JDK. </p>"},{"location":"ud1/121conceptosbasicos/#caracteristicas-de-java","title":"Caracter\u00edsticas de Java","text":"<ul> <li> <p>Portabilidad: Java es altamente portable y puede ejecutarse en diferentes sistemas operativos sin necesidad de modificaciones. Esto se debe a la M\u00e1quina Virtual de Java (JVM), que interpreta el c\u00f3digo de byte Java en la plataforma de destino.</p> </li> <li> <p>Orientaci\u00f3n a Objetos: Java es un lenguaje orientado a objetos, lo que significa que se basa en la creaci\u00f3n y manipulaci\u00f3n de objetos. Esto facilita la organizaci\u00f3n y reutilizaci\u00f3n del c\u00f3digo.</p> </li> <li> <p>Sintaxis Clara y Legible: La sintaxis de Java se basa en gran medida en la de C++, pero se ha simplificado para mejorar la claridad y la legibilidad del c\u00f3digo. Esto hace que Java sea m\u00e1s f\u00e1cil de aprender y usar.</p> </li> <li> <p>Administraci\u00f3n Autom\u00e1tica de Memoria: Java utiliza un recolector de basura (garbage collector) para administrar la memoria autom\u00e1ticamente, lo que evita problemas comunes de administraci\u00f3n de memoria, como fugas de memoria.</p> </li> <li> <p>Seguridad: Java se centra en la seguridad y utiliza un sistema de permisos y pol\u00edticas de seguridad para proteger los sistemas contra c\u00f3digo malicioso.</p> </li> <li> <p>Multihilo (Multithreading): Java admite la programaci\u00f3n multihilo, lo que permite que las aplicaciones realicen m\u00faltiples tareas simult\u00e1neamente y mejoren la eficiencia.</p> </li> <li> <p>Bibliotecas Est\u00e1ndar Ricas: Java cuenta con una amplia biblioteca est\u00e1ndar que proporciona herramientas y funciones listas para usar, lo que acelera el desarrollo de aplicaciones.</p> </li> <li> <p>Plataforma Independiente: Java es una plataforma independiente, lo que significa que las aplicaciones Java pueden ejecutarse en cualquier sistema que tenga una JVM compatible.</p> </li> <li> <p>Compatibilidad Hacia Atr\u00e1s: Java se preocupa por la compatibilidad hacia atr\u00e1s, lo que significa que las versiones m\u00e1s nuevas del lenguaje generalmente son compatibles con el c\u00f3digo existente.</p> </li> <li> <p>Comunidad Activa: Java cuenta con una comunidad de desarrollo activa y una amplia base de usuarios. Esto resulta en abundantes recursos y soporte en l\u00ednea.</p> </li> <li> <p>Escalabilidad: Java es adecuado para proyectos de todos los tama\u00f1os, desde aplicaciones m\u00f3viles hasta sistemas empresariales a gran escala.</p> </li> <li> <p>Desarrollo Web y Empresarial: Java se utiliza ampliamente en el desarrollo web, especialmente en aplicaciones empresariales y servidores we</p> </li> </ul>"},{"location":"ud1/121conceptosbasicos/#por-que-aprender-java","title":"\u00bfPor qu\u00e9 aprender Java?","text":"<ul> <li>Naci\u00f3 en 1995 y todav\u00eda sigue siendo uno de los lenguajes m\u00e1s usados a nivel mundial.</li> <li>Su capacidad de escribirlo y ejecutarlo en cualquier plataforma: \"Write once, run anywhere\".</li> <li>Desde que naci\u00f3 han salido muchas releases de gran importancia, el lenguaje sigue evolucionando con nuevas funcionalidades.</li> <li>Tiene un comunidad muy grande de c\u00f3digo abierto, documentaci\u00f3n y tutoriales. Es usado por muchas compa\u00f1\u00edas de software, por tanto se ofertan muchos empleos de desarrolladores Java.</li> </ul>"},{"location":"ud1/121conceptosbasicos/#aplicaciones-de-java","title":"Aplicaciones de Java","text":"<p>Java es ampliamente utilizado en una amplia gama de aplicaciones, como aplicaciones de banca en l\u00ednea, aplicaciones de comercio electr\u00f3nico, sistemas de gesti\u00f3n de bases de datos, sistemas de control de vuelo, aplicaciones de telefon\u00eda m\u00f3vil y muchos m\u00e1s.</p>"},{"location":"ud1/121conceptosbasicos/#usos-de-java","title":"Usos de Java","text":"<p>Java se utiliza en una variedad de dominios, incluyendo:</p> <ul> <li>Desarrollo de aplicaciones web.</li> <li>Aplicaciones m\u00f3viles para Android.</li> <li>Aplicaciones de escritorio.</li> <li>Desarrollo de servidores empresariales.</li> <li>Sistemas embebidos.</li> <li>Aplicaciones cient\u00edficas y financieras.</li> <li>Juegos y entretenimiento.</li> </ul>"},{"location":"ud1/121conceptosbasicos/#ventajas-de-java","title":"Ventajas de Java","text":"<ul> <li>Portabilidad.</li> <li>Lenguaje orientado a objetos.</li> <li>Seguridad.</li> <li>Facilidad de uso.</li> <li>Bibliotecas est\u00e1ndar ricas.</li> <li>Comunidad activa.</li> <li>Escalabilidad.</li> </ul>"},{"location":"ud1/121conceptosbasicos/#importancia-de-java","title":"Importancia de Java","text":"<p>Java es importante en la inform\u00e1tica porque permite el desarrollo de aplicaciones y sistemas altamente funcionales y escalables. Su capacidad de ejecutarse en m\u00faltiples plataformas lo convierte en una herramienta valiosa para la creaci\u00f3n de software en una amplia variedad de campos.</p>"},{"location":"ud1/121conceptosbasicos/#principios-de-java","title":"Principios de Java","text":"<p>Los principios fundamentales de Java incluyen la portabilidad, la seguridad y la facilidad de uso. Java se basa en una sintaxis clara y una filosof\u00eda de \"escribir una vez, ejecutar en cualquier lugar\".</p>"},{"location":"ud1/121conceptosbasicos/#paradigma-de-programacion-java","title":"Paradigma de programaci\u00f3n Java","text":"<p>Java se basa en un paradigma de programaci\u00f3n orientado a objetos. Esto significa que los programas Java est\u00e1n compuestos por objetos que interact\u00faan entre s\u00ed. El enfoque orientado a objetos permite una organizaci\u00f3n y reutilizaci\u00f3n eficiente del c\u00f3digo.</p>"},{"location":"ud1/121conceptosbasicos/#como-funciona-java","title":"\u00bfC\u00f3mo funciona Java?","text":"<p>Java funciona a trav\u00e9s de un proceso de compilaci\u00f3n e interpretaci\u00f3n. El c\u00f3digo fuente Java se compila en un archivo de bytecode, que luego se ejecuta en la M\u00e1quina Virtual de Java (JVM). La JVM se encarga de la ejecuci\u00f3n del c\u00f3digo y garantiza la portabilidad entre plataformas.</p>"},{"location":"ud1/121conceptosbasicos/#plataforma-java","title":"Plataforma Java","text":"<p>La Plataforma Java es un conjunto de tecnolog\u00edas que incluye el lenguaje de programaci\u00f3n Java, la JVM y las bibliotecas est\u00e1ndar. La Plataforma Java proporciona un entorno completo para el desarrollo y la ejecuci\u00f3n de aplicaciones Java.</p>"},{"location":"ud1/121conceptosbasicos/#java-virtual-machine-jvm","title":"Java Virtual Machine (JVM)","text":"<p>La JVM es una parte fundamental de Java, ya que interpreta y ejecuta el bytecode generado por el compilador Java. La JVM garantiza la portabilidad del c\u00f3digo, permitiendo que las aplicaciones Java se ejecuten en diferentes sistemas operativos.</p>"},{"location":"ud1/121conceptosbasicos/#sintaxis-de-java","title":"Sintaxis de Java","text":"<p>La sintaxis de Java se caracteriza por su claridad y legibilidad. El c\u00f3digo Java utiliza reglas y estructuras espec\u00edficas que facilitan la escritura y comprensi\u00f3n del c\u00f3digo. Esto incluye la declaraci\u00f3n de variables, estructuras de control, definici\u00f3n de clases y m\u00e1s.</p>"},{"location":"ud1/121conceptosbasicos/#otros-conceptos-relacionados-con-java","title":"Otros conceptos relacionados con Java","text":""},{"location":"ud1/121conceptosbasicos/#jre","title":"JRE","text":"<p>Java Runtime Environment. La m\u00e1quina virtual de Java est\u00e1 incluida en el JRE. Se utiliza para ejecutar aplicaciones Java en el SO, por tanto si queremos desplegar una aplicaci\u00f3n en Java, necesitamos tener instalado previamente el JRE para esa m\u00e1quina y plataforma.</p>"},{"location":"ud1/121conceptosbasicos/#jdk","title":"JDK","text":"<p>Java Development Kit. Es m\u00e1s pesado que el JRE, contiene todas las herramientas para programar y compilar las clases Java en bytecode, por tanto cuando desarrollamos clases Java necesitamos el JDK. Adem\u00e1s incluy el JRE.</p>"},{"location":"ud1/121conceptosbasicos/#versiones-java","title":"Versiones Java","text":"<p>La \u00faltima versi\u00f3n de Java se conoce como LTS Release (Long Term Support), y la podemos encontrar en su p\u00e1gina Oficial.</p>"},{"location":"ud1/122setup/","title":"\ud83d\udcbe \u00bfQu\u00e9 se necesita para programar en Java?","text":"<ul> <li>Instalar el JDK la \u00falltima release, versi\u00f3n estable de Java. Lo podemos descarga desde la p\u00e1gina oficial de Oracle.</li> <li>Instalar un IDE (Integrated Development Environment), es un programa que te ayudar a desarrollar aplicaciones. Hay muchas opciones disponibles de IDEs.</li> </ul>"},{"location":"ud1/122setup/#setup-jdk-java-y-intellij-en-windows","title":"Setup JDK Java y IntelliJ en Windows","text":"<ol> <li> <p>Vamos a la p\u00e1gina de Oracle y descargamos el JDK.</p> </li> <li> <p>Instalamos el JDK.</p> </li> </ol> <p>En linux usamos el siguiente comando para instalar el jdk: sudo apt-get install openjdk-XX-jdk, donde XX es la versi\u00f3n del java.</p> <ol> <li> <p>Windows: A\u00f1adimos en las variables de entorno del sistema dentro de la variable Path, la ruta donde se ha instalado java en nuestra m\u00e1quina (C:\\Program Files\\Java\\jdk-VERSION\\bin)</p> </li> <li> <p>Windows: Agregamos tambi\u00e9n una nueva variable llamada JAVA_HOME --&gt; C:\\Program Files\\Java\\jdk-VERSION (Ruta de nuestra m\u00e1quina).</p> </li> <li> <p>Verificamos que se ha instalado java, ejecutando desde l\u00ednea de comandos:</p> </li> </ol> <pre><code>java --version\n</code></pre> <ol> <li> <p>Descargamos e instalamos IntelliJ Community</p> </li> <li> <p>En File -&gt; Settings, modificamos las siguientes opciones:  </p> </li> </ol>"},{"location":"ud1/123holamundo/","title":"\ud83d\udcbe Proyecto \"Hola Mundo\". Estructura de un programa","text":"<p>Cada vez que est\u00e1s aprendiendo un nuevo lenguaje de programaci\u00f3n es una tradici\u00f3n crear un nuevo programa muy simple que genera el texto Hola mundo. Veamos como podemos hacer esto en IntelliJ.</p> <ol> <li>Hacemos click en crear nuevo proyecto y elegimos el JDK que hemos instalado. </li> <li>Luego en Next, Next, a\u00f1adimos nombre al proyecto y Finish.  </li> <li>Creamos una nueva clase Java llamada Hello.java  </li> <li>Vamos a crear un m\u00e9todo para imprimir el mensaje Hola mundo. Usaremos un m\u00e9todo especial llamado main. El main es el primer m\u00e9todo que Java busca y ejecuta en el proyecto. Es el punto de entrada. </li> <li>Ejecutamos el programa mediante </li> <li>A\u00f1adimos y ejecutamos la siguiente sentencia dentro del m\u00e9todo main: System.out.println(\"Hello World\"); </li> </ol>"},{"location":"ud1/123holamundo/#challenge","title":"Challenge","text":"<p>Question</p> <p>Modifica el programa para que imprima por pantalla Hello Teacher.</p> <p>Question</p> <p>Realizar las actividades 1 y 2.</p>"},{"location":"ud1/131variables/","title":"\ud83d\udcbe \u00bfQu\u00e9 son las variables?","text":"<p>Las variables en Java es una forma de almacenar informaci\u00f3n en nuestro ordenador. Definimos variables asign\u00e1ndoles un nombre. De igual manera se puede acceder a la informaci\u00f3n que guardan las variables, simplemente accediendo por el nombre que le hemos dado. Es el ordenador el que se encarga de averiguar d\u00f3nde se almacena internamente en la memoria RAM del ordenador. </p> <p> Como su nombre indica \"variable\", se puede modificar el contenido que \u00e9sta almacena, es decir, es variable. Lo \u00fanico que tenemos que hacer es decirle al PC qu\u00e9 tipo de informaci\u00f3n queremos guardar en nuestra variable y darle un nombre. Existe diferentes tipos de informaci\u00f3n que podemos utilizar para definir nuestras variables. Se les conoce como tipos de datos o data types. Los tipos de datos son palabras reservas keywords en Java, es decir, no podemos utilizarlas fuera del contexto de tipo de datos. </p> <p> Para definir una variable, necesitamos especificar el tipo de datos, luego darle un nombre a nuestra variable, y opcionalmente, podemos agregar una expresi\u00f3n para inicializar la variable con un valor. </p>"},{"location":"ud1/131variables/#reglas-para-el-nombrado-de-variables","title":"Reglas para el nombrado de variables","text":"<ul> <li> <p>Tiene que comenzar con una letra o '_', nunca con n\u00fameros.</p> </li> <li> <p>Puede contener n\u00fameros. No debe contener espacios en blanco.</p> </li> <li> <p>No debe ser muy largo y debe expresar algo en el contexto.</p> </li> <li> <p>No se pueden usar palabras reservadas.</p> </li> <li> <p>May\u00fasculas y min\u00fasculas se tratan diferente.</p> </li> </ul> <p></p> <p>Definimos nuestra primera variable en el programa de la siguiente forma: </p> <p>La l\u00ednea que acabamos de escribir se conoce como sentencia de declaraci\u00f3n.</p>"},{"location":"ud1/131variables/#keywords","title":"Keywords","text":"<p>Son palabras reservadas del lenguaje. Es decir, son palabras que tienen un significado especial en Java y no puedes usarlas fuera de ese contexto. Es decir, no se puede declarar variables utilizando palabras reservadas como nombre. Ejemplos: public, class, void, static, etc. Existen 61 keywords en Java.</p>"},{"location":"ud1/131variables/#vida-de-las-variables","title":"Vida de las variables","text":"<p>Las variables son memorias reservadas para almacenar valores en RAM. Estas posiciones de memoria se liberan tan pronto como termina la vida de la variable. Seg\u00fan la vida de las variables, hay tres tipos de Variables.</p> <p>1. Variables locales: La vida permanece dentro de un bloque donde se ha declarado.</p> <p>2. Variables de instancia: Declaradas dentro de la clase pero fuera de los m\u00e9todos. No deber\u00eda ser est\u00e1tico.</p> <p>3. Variables est\u00e1ticas: es como una variable global. Declarado como est\u00e1tico en la clase pero fuera de los m\u00e9todos.</p> <pre><code>    static int pi = 3.14;\n</code></pre>"},{"location":"ud1/131variables/#visibilidad-de-las-variables","title":"Visibilidad de las variables","text":"<p>En las variables locales, su \u00e1mbito y uso se encuentra dentro del m\u00e9todo o bloque en el que se defini\u00f3 y se destruyen despu\u00e9s de la ejecuci\u00f3n del m\u00e9todo. Es decir, no se puede usar una variable local fuera del m\u00e9todo actual.</p> <p>A las variables de instancia se puede acceder solo a trav\u00e9s de objetos de la clase para la que se defini\u00f3.</p> <p>Un campo / variable est\u00e1tico pertenece a la clase y se cargar\u00e1 en la memoria junto con la clase. Se invocan sin crear un objeto. (Usando el nombre de la clase como referencia). Solo hay una copia de la variable est\u00e1tica disponible en toda la clase, es decir, el valor de la variable est\u00e1tica ser\u00e1 el mismo en todos los objetos. Puede definir una variable est\u00e1tica utilizando la palabra clave static.</p>"},{"location":"ud1/131variables/#mutacion-o-manipulacion-de-las-variables","title":"Mutaci\u00f3n o manipulaci\u00f3n de las variables","text":"<p>Supongamos que hemos ejecutado la siguiente l\u00ednea de c\u00f3digo:</p> <pre><code>int number = 5;\n</code></pre> <p>\u00bfC\u00f3mo podr\u00edamos sumar 6 al valor actualmente almacenado en <code>number</code>? Un enfoque ingenuo podr\u00eda ser probar esta l\u00ednea de c\u00f3digo:</p> <pre><code>    number + 6;\n</code></pre> <p>Sin embargo, esta l\u00ednea de c\u00f3digo es una expresi\u00f3n que da como resultado un valor: no hemos alterado el valor de <code>number</code>.</p> <pre><code>// Recuerda, number es una variable que contiene el valor 5\nnumber + 6; // se eval\u00faa como:\n5 + 6; // y luego da como resultado:\n11;\n\n// Pero 11; no es una declaraci\u00f3n que Java entienda,\n// entonces el compilador lanza un error cuando ve: number + 6;\n</code></pre> <p>Para aumentar el valor de <code>number</code> en 6, necesitamos reasignar el valor de <code>number</code> para que sea el resultado de <code>number + 6</code>:</p> <pre><code>number = number + 6; // se eval\u00faa como:\nnumber = 5 + 6; // y luego se suman los valores\nnumber = 11;// como resultado se asigna el valor 11 a number\n</code></pre> <p>Aqu\u00ed, hemos usado el valor de <code>number</code> para calcular y almacenar un nuevo valor en la variable <code>number</code>; en este caso, 11.</p>"},{"location":"ud1/131variables/#creacion-de-una-variable","title":"Creaci\u00f3n de una variable","text":"<p>Para crear una variable se especifica el tipo de dato y se le da un nombre descriptivo que de informaci\u00f3n sobre esa variable. Ejemplo de creaci\u00f3n de una variable:</p> <pre><code>int numero;\n</code></pre>"},{"location":"ud1/131variables/#inicializacion-de-las-variables","title":"Inicializaci\u00f3n de las variables","text":"<p>La variable anterior <code>numero</code> no tiene un valor inicial asignado, es decir, no est\u00e1 inicializada. Inicializar una variable significa darle un valor inicial acorde al tipo de dato definido para esa variable en el momento de su creaci\u00f3n. En Java adem\u00e1s, las variables deben ser inicializadas antes de poder ser usadas.</p> <p>Ejemplo:</p> <pre><code>int numero = 99; //Se crea y se inicializa\n</code></pre>"},{"location":"ud1/131variables/#scope-ambito-de-las-variables","title":"Scope - \u00c1mbito de las variables","text":"<p>El alcance o \u00e1mbito (scope) de una variable es la parte de un programa en la que existe. En Java, el alcance de una variable comienza donde se declara y termina cuando se alcanza la llave de cierre del bloque que la contiene.</p> <p>Ejemplo de variables en programaci\u00f3n Java</p> <pre><code>public static void main(String[] args) {\nint valor = 5;\nfor (int i = 1; i &lt;= 5; i++) {\nint y = 10;\nSystem.out.println(valor) // \u00a1valor todav\u00eda est\u00e1 dentro del alcance aqu\u00ed!\n}\nSystem.out.println(valor) // \u00a1valor todav\u00eda est\u00e1 dentro del alcance aqu\u00ed tambi\u00e9n!\n}\n</code></pre> <ul> <li><code>valor</code> est\u00e1 dentro del alcance entre su declaraci\u00f3n en la l\u00ednea 2 y la llave que la encierra en la l\u00ednea 8.</li> <li><code>y</code> est\u00e1 dentro del alcance entre su declaraci\u00f3n en la l\u00ednea 4 y la llave que la encierra en la l\u00ednea 6.</li> <li>Las variables de bucle est\u00e1n dentro del alcance entre sus bucles <code>for</code> { }. Entonces, <code>i</code> est\u00e1 dentro del alcance entre las l\u00edneas 3 - 6. Nota: Dos variables con el mismo nombre no pueden existir dentro del mismo \u00e1mbito (scope).</li> </ul>"},{"location":"ud1/131variables/#buenas-practicas-con-variables","title":"Buenas pr\u00e1cticas con variables","text":"<ul> <li> <p>Utiliza nombres descriptivos que reflejen el prop\u00f3sito de la variable. Evita nombres gen\u00e9ricos como \"x\" o \"temp\". Un nombre descriptivo como \"numeroDeEstudiantes\" es m\u00e1s claro y evita futuros comentarios en c\u00f3digo. Recuerda que un c\u00f3digo muy comentado significa que est\u00e1 mal escrito. Y un c\u00f3digo bien escrito tendr\u00e1 muy pocos comentarios, solo cosas significativas para aclarar c\u00f3digo complejo.</p> </li> <li> <p>Evita el uso de abreviaturas confusas que puedan confundir a otros desarrolladores. Usa nombres completos y legibles en su lugar.</p> </li> <li> <p>Convenio de nombres. Sigue un convenio de nombres consistente, como CamelCase o snake_case, seg\u00fan las convenciones de estilo de tu lenguaje de programaci\u00f3n.</p> </li> <li> <p>No uses palabras reservadas del lenguaje como nombres de variables, ya que puede causar conflictos y errores.</p> </li> <li> <p>Manten buen alcance (scope), limita el alcance de las variables al m\u00ednimo necesario. Declarar variables en el \u00e1mbito m\u00e1s cercano a su uso mejora la legibilidad y reduce la posibilidad de errores.</p> </li> <li> <p>Inicializaci\u00f3n oportuna, inicializa las variables en el momento de la declaraci\u00f3n o antes de su primer uso. Evita dejar variables sin inicializar, ya que puede causar comportamientos inesperados.</p> </li> <li> <p>Comentarios significativos. Agrega comentarios relevantes cuando el prop\u00f3sito de una variable no sea obvio. Esto ayuda a otros programadores a entender tu c\u00f3digo.</p> </li> <li> <p>Evita variables globales. Limita el uso de variables globales, ya que pueden causar problemas de mantenimiento y depuraci\u00f3n. Usa variables locales siempre que sea posible.</p> </li> <li> <p>Evita variables reutilizadas para diferentes prop\u00f3sitos en diferentes partes de tu c\u00f3digo. Esto puede causar confusi\u00f3n y errores.</p> </li> <li> <p>Usa constantes para valores fijos. Si un valor es constante y no debe cambiar, decl\u00e1ralo como una constante en lugar de una variable.</p> </li> <li> <p>Evita magia num\u00e9rica, es decir, evita usar valores num\u00e9ricos sin explicaci\u00f3n directa en el c\u00f3digo. Usa constantes descriptivas o comenta el prop\u00f3sito de los n\u00fameros m\u00e1gicos.</p> </li> <li> <p>Refactoriza nombres cuando sea necesario. Si el prop\u00f3sito de una variable cambia, ren\u00f3mbrala para reflejar el nuevo prop\u00f3sito en lugar de reutilizarla.</p> </li> <li> <p>Evita variables muertas. Elimina variables que ya no se utilizan en el c\u00f3digo. Las variables inactivas dificultan la lectura y pueden llevar a confusiones.</p> </li> <li> <p>No crear variables demasiado largas. Si una variable tiene un nombre excesivamente largo, puede ser dif\u00edcil de leer. Encuentra un equilibrio entre la claridad y la concisi\u00f3n.</p> </li> </ul>"},{"location":"ud1/132sentencias/","title":"\ud83d\udcbe Sentencias","text":"<p>Hemos comentado que un programa es un conjunto de instrucciones. Estas instrucciones se llaman sentencias o statements en ingl\u00e9s. Una sentencia es un segmento de c\u00f3digo que realiza una acci\u00f3n en el programa. A medida que se ejecuta un programa, decimos que ejecuta sentencias, lo que significa que lleva a cabo las acciones especificadas por esas sentencias. En nuestro programa Hello World, tenemos un statement en la l\u00ednea 4 y 6. La regla en Java es que las sentencias deben terminar con un punto y coma. Si se olvida, se producir\u00eda un error de sintaxis. </p>"},{"location":"ud1/132sentencias/#sentencias-de-declaracion","title":"Sentencias de declaraci\u00f3n","text":"<p>Se usan para definir una variable de un tipo de dato en particular. En Java, una variable debe declararse antes de que pueda usarse en un programa. De no hacerlo, se producir\u00eda un error de sintaxis. En su forma m\u00e1s simple una declaraci\u00f3n incluye el tipo de datos y el nombre de la variable. Opcionalmente se puede establecer la variable a cierto valor. Es decir, se dice que se ha inicializado.</p> <pre><code>Ejemplos:\nint numero;\nint a = 3; //se crea la variable a y se le asigna el valor 3\nint dia;\n</code></pre>"},{"location":"ud1/132sentencias/#sentencias-de-asignacion","title":"Sentencias de asignaci\u00f3n","text":"<p>Una sentencia de asignaci\u00f3n es una sentencia que almacena (asigna) un valor en una variable. Una sentencia de asignaci\u00f3n utiliza el signo igual (=) como operador de asignaci\u00f3n. En su forma m\u00e1s simple, tiene una variable en el lado izquierdo del signo igual y alg\u00fan tipo de valor en el lado derecho.</p> <pre><code>Ejemplos:\nnumero = 6; //asigno el valor 6 a la variable numero\na = 0;\ndia = 22;\n</code></pre> <p>En el siguiente ejemplo, hay variables tanto a la izquierda como a la derecha del operador de asignaci\u00f3n (=). Pero tienen un significado muy diferente. La variable de la derecha (num2) se trata como un valor. Si esa variable almacena 20, entonces ese es su valor. De hecho, cualquier cosa que ocurra en el lado derecho de un operador de asignaci\u00f3n se trata como un valor. La variable de la izquierda (num1) se trata como una ubicaci\u00f3n de memoria. Es donde se almacenar\u00e1 el valor 20 como resultado de la ejecuci\u00f3n de esta declaraci\u00f3n. El efecto de esta declaraci\u00f3n es copia el valor almacenado en num2 en num1, como se ilustra en la siguiente imagen.</p> <pre><code>Ejemplo\n//se crean las variables\nint num1 = 10;\nint num2 = 20;\n\nnum1 = num2; //se copia el valor de num2 a la variable num1\n</code></pre> <p></p>"},{"location":"ud1/132sentencias/#challenge","title":"Challenge","text":"<p>Question</p> <p>En el programa Hello World, imprime por pantalla la variable miPrimerEntero que hemos creado.</p>"},{"location":"ud1/132sentencias/#challenge2","title":"Challenge2","text":"<p>Question</p> <p>En el programa Hello World, crea las siguientes variables adicionales justo debajo de la declaraci\u00f3n \"int miPrimerEntero = 7;\" en el programa:</p> <ul> <li>num1 de tipo int y con un valor de 10.</li> <li>num2 de tipo int y con un valor de 8.</li> <li>y una tercera total que sea la suma de las anteriores.</li> <li>imprime por pantalla la variable total.</li> </ul>"},{"location":"ud1/132sentencias/#paquetes-en-java-java-packages","title":"Paquetes en Java - Java Packages","text":"<p>Un paquete es una forma de organizar nuestros proyectos Java. Se pueden ver como carpetas dentro de la estructuraci\u00f3n interna del proyecto.</p> <p>Los paquetes son el mecanismo que usa Java para facilitar la modularidad del c\u00f3digo. Un paquete puede contener una o m\u00e1s definiciones de interfaces y clases, distribuy\u00e9ndose habitualmente como un archivo. Para utilizar los elementos de un paquete es necesario importar este en el m\u00f3dulo de c\u00f3digo en curso, usando para ello la sentencia import.</p> <p>IntelliJ nos ofrece la opci\u00f3n de automatizar esto cuando creamos un proyecto, simplemente seleccionando la opci\u00f3n: </p>"},{"location":"ud1/142noprimitive/","title":"\ud83d\udcbe No primitivos u objetos","text":"<p>En Java, los tipos de datos no primitivos son los tipos de datos de referencia o los tipos de datos creados por el usuario. Todos los tipos de datos no primitivos se implementan utilizando conceptos de objeto. Cada variable del tipo de datos no primitivo es un objeto. Los tipos de datos no primitivos pueden utilizar m\u00e9todos adicionales para realizar determinadas operaciones. El valor predeterminado de la variable de tipo de datos no primitivos es nulo.</p>"},{"location":"ud1/142noprimitive/#string-cadena-de-caracteres","title":"String - Cadena de caracteres","text":"<p>String es una clase integrada en el lenguaje Java ampliamente utilizada y definido en el paquete java.lang. Representa cadenas de caracteres y se utilizan para almacenar varios atributos como nombre de usuario, contrase\u00f1a, etc. Los String son inmutables; es decir, no se pueden modificar una vez creados. Siempre que se modifica un objeto String, en realidad se crea uno nuevo String.</p> <p>Existen varias formas para crear un String:</p> <pre><code>    String texto = \"Severo Ochoa\";\nString texto2 = new String(\"Severo Ochoa\");\n</code></pre>"},{"location":"ud1/142noprimitive/#asignacion-de-memoria-de-objetos-string","title":"Asignaci\u00f3n de memoria de objetos String","text":"<p>La memoria se divide en dos partes, el String Pool y la memoria Heap.</p> <p></p> <p>Veamos como funcionar\u00eda para la imagen anterior.</p> <ol> <li> <p>Siempre que creamos un String con comillas dobles, se almacenan en String Pool. String Pool almacena el \u00fanico valor en \u00e9l. Es por eso que, String s1 = \"blogs\" se almacenan como el primer valor en el String Pool.</p> </li> <li> <p>Siempre que creamos un objeto usando la palabra clave new, se almacena en la memoria Heap pero fuera del String Pool. Aqu\u00ed se puede almacenar valores duplicados ya que pertenece a diferentes objetos. Entonces, para la declaraci\u00f3n String s2 = new String(\u201cblogs\u201d), aunque el valor de s1 y s2 es el mismo, s2 se almacenar\u00e1 fuera del String Pool.</p> </li> <li> <p>Cuando creamos otro String usando comillas dobles, primero verifica todos los valores en el String Pool y si coincide con alguno se asigna la misma ubicaci\u00f3n asignada a otro objeto de referencia. Por lo tanto, String s3 = \u201dblogs\u201d no agregar\u00e1 una nueva entrada en el String Pool.</p> </li> <li> <p>Pero si creamos otro objeto con un valor existente usando la palabra clave new. Asignar\u00e1 nueva memoria al nuevo objeto en el Heap. Por lo tanto, a String s4 = new String (\"blogs\") se le asignar\u00e1 nueva memoria.</p> </li> <li> <p>Ahora, si manipulamos el valor en s1 usando s1 = \u201dNew\u201c + s1, no actualizar\u00e1 la entrada o referencia existente de s1. Este proceso crear\u00e1 una nueva entrada en el String Pool con el valor \"New blogs\" y la referencia de memoria cambiar\u00eda para el objeto s1.</p> </li> </ol>"},{"location":"ud1/142noprimitive/#java-string-class-methods","title":"Java String Class Methods","text":"<p>La clase java.lang.String proporciona muchos m\u00e9todos \u00fatiles para realizar operaciones en la secuencia de valores char.</p>"},{"location":"ud1/142noprimitive/#date","title":"Date","text":"<p>En sus inicios se crearon las clases java.util.Date y java.sql.Date para almacenar y manejar fechas. Pero ambas clases son defectuosas en dise\u00f1o e implementaci\u00f3n. Por ejemplo, las clases existentes (como java.util.Date y SimpleDateFormatter) no son thread-safe, lo que genera posibles problemas de concurrencia para los usuarios.</p> <p>Por tanto, desde Java 8 y posteriores se ha desarrollado una nueva API java.time que resuelve los problemas que presentaban las librer\u00edas anteriores.</p> <p></p> <p>More information</p> <p>Why do we need a new date and time library?</p> <p>Ejemplo de c\u00f3digo para mostara la fecha y la hora:</p> <pre><code>  //mostrar fecha\nLocalDate ld = LocalDate.now();\nSystem.out.println(ld);\n\n//mostrar hora\nLocalTime lt = LocalTime.now();\nSystem.out.println(lt);\n\n//mostrar fecha y hora\nLocalDateTime ldt = LocalDateTime.now();\nSystem.out.println(ldt);\n\n//formatear la fecha con un formato dado\nDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"dd-MM-yyyy HH:mm:ss\");\nString formatted = formatter.format(ldt);\nSystem.out.println(formatted);\n</code></pre>"},{"location":"ud1/142noprimitive/#enum-en-java","title":"Enum en Java","text":"<p>El tipo enumerado es un tipo de datos especial que permite que una variable sea un conjunto de constantes predefinidas. La variable debe ser igual a uno de los valores que se han predefinido para ella.</p> <p>Debido a que son constantes, los nombres de los campos del tipo enum deben estar en letras may\u00fasculas.</p> <p>En Java, se define un enumerado utilizando la palabra clave enum seguido del nombre siguiendo la convenci\u00f3n del nombrado de clases. Primera letra en may\u00fascula y CamelCase.</p> <p>Para crear un enum en Java, bot\u00f3n derecho en el paquete --&gt; new Java class y seleccionamos enum.</p> <p>Ejemplo de enumerado:</p> <pre><code>  public enum PuntosCardinales {\nNORTE, SUR, ESTE, OESTE\n}\n\npublic class Main {\n\npublic static void main(String[] args) {\nPuntosCardinales myVar = PuntosCardinales.ESTE;\nSystem.out.println(myVar);\n}\n\n}\n</code></pre>"},{"location":"ud1/143string/","title":"\ud83d\udcbe String en Java","text":"<p>Un String es un tipo de dato no primitvo que, en Java representa una cadena de caracteres no modificable. Todos los literales de la forma \"cualquier texto\", es decir, literales entre comillas dobles, que aparecen en un programa java se implementan como objetos de la clase String.</p> <p>A diferencia de muchos objetos vimos que un String se puede crear sin la palabra new.</p> <p>String text = \"hola\";</p>"},{"location":"ud1/143string/#creacion-de-string","title":"Creaci\u00f3n de String","text":"<p>Se puede crear un String de varias formas.</p> <pre><code>    String texto = \"Severo Ochoa\";\n\n//Utilizando new\nString texto2 = new String(\"Severo Ochoa\");\n\n//Utilizando el operador concatenaci\u00f3n +\nString s2 = text + \" 2021\";      //s2 contiene \"Severo Ochoa 2021\"\n</code></pre>"},{"location":"ud1/143string/#el-operador-concatenacion","title":"El operador concatenaci\u00f3n","text":"<p>La clase proporciona el operador + (concatenaci\u00f3n) para unir dos o m\u00e1s String. El resultado de aplicar este operador es un nuevo String concatenaci\u00f3n de los otros. Por ejemplo, si tenemos dos String b y c:</p> <pre><code>String b = \"Ordenador\";\nString c = \" Port\u00e1til\";\n</code></pre> <p></p> <p>La operaci\u00f3n</p> <pre><code>b = b + c;\n</code></pre> <p>Crea un nuevo String que se incluye en el String Pool:</p> <p></p>"},{"location":"ud1/143string/#indices","title":"\u00cdndices","text":"<p>Cada uno de los caracteres que forman un String son del tipo primitivo char. Los caracteres de un string est\u00e1n numerados internamente con \u00edndices empezando desde el cero:</p> <p></p> <p>El primer car\u00e1cter tiene \u00edndice 0 y el \u00faltimo tiene la longitud del string menos 1.</p>"},{"location":"ud1/143string/#metodos-de-la-clase-string","title":"M\u00e9todos de la clase String","text":"<p>La clase String proporciona m\u00e9todos para el tratamiento de las cadenas de caracteres: acceso a caracteres individuales, buscar y extraer una subcadena, copiar cadenas, convertir cadenas a may\u00fasculas o min\u00fasculas, etc.</p> <p></p> <p>Para acceder a alguno de los m\u00e9todos siguientes utilizamos la notaci\u00f3n \".\"</p> <pre><code>  String texto = \"Clase\";\nint longitud = texto.length(); //devuelve 5\n</code></pre> <p></p> <p>Tip</p> <p>Para m\u00e1s informaci\u00f3n consulta la documentaci\u00f3n oficial de la clase String</p>"},{"location":"ud1/143string/#comparar-strings","title":"Comparar Strings","text":"<p>Los operadores relacionales como == o &lt; &gt; NO se utilizan para comparar Strings, aunque el c\u00f3digo compile no es correcto, ya que == compara objetos, y devolver\u00eda falso aunque dos strings tuvieran el mismo texto puesto que son objetos diferentes.</p> <p>Para comparar strings utilizamos el m\u00e9todo equals.</p> <pre><code>  String name = \"Patri\";\n\nif (name.equals(\"Patri\")) {\nSystem.out.println(\"Coincide.\");\n}\n</code></pre> <p>La siguiente tabla muestra los m\u00e9todos que se utilizan para comparar Strings.</p> <p></p>"},{"location":"ud1/143string/#char-dentro-de-string","title":"char dentro de String","text":"<p>Como se ha comentado, un String est\u00e1 compuesto de caracteres tipo char.</p> <p>Para acceder a los caracteres dentro de un String usamos el m\u00e9todo charAt.</p> <p>Se puede usar la concatenaci\u00f3n + para concatenar char con String.</p> <pre><code>String food = \"cookie\";\nchar firstLetter = food.charAt(0); // 'c'\nSystem.out.println(firstLetter + \" is for \" + food); </code></pre> <p>Tambi\u00e9n podemos recorrer el String con un bucle for e imprimir cada uno de los caracteres que lo forman.</p> <pre><code>String major = \"CSE\";\nfor (int i = 0; i &lt; major.length(); i++) {\nchar c = major.charAt(i);\nSystem.out.println(c);\n}\n</code></pre> <pre><code>OUTPUT\nC\nS\nE\n</code></pre>"},{"location":"ud1/143string/#char","title":"char","text":"<p>A todos los valores char se les asigna un n\u00famero internamente por el ordenador, son los llamados valores ASCII. Por ejemplo:</p> <p>el car\u00e1cter 'A' es 65 en c\u00f3digo ASCII</p> <p>el car\u00e1cter 'a' es 97 en c\u00f3digo ASCII</p> <p>Mezclar tipos de datos char e int autom\u00e1ticamente cause una conversi\u00f3n en entero. Por ejemplo:</p> <p>'a' + 10 --&gt; devuelve 107.</p> <p>Para convertir un entero en su equivalente a car\u00e1cter (char) har\u00edamos:</p> <p>(char) ('a' + 2) --&gt; devuelve 'c'.</p>"},{"location":"ud1/143string/#diferencias-entre-char-y-string","title":"Diferencias entre char y String","text":"<ul> <li>String es un objeto, por tanto, contiene m\u00e9todos.</li> <li>char es un tipo de dato primitivo, no puedes llamar a m\u00e9todos con \u00e9l.</li> <li>String utiliza comillas dobles.</li> <li>char utiliza comillas simples.</li> <li>No se puede comparar un String usando operadores relacionales.</li> <li>Si se puede comparar un char usando operadores relacionales: 'a' &lt; 'b', 'X' == 'X', ...</li> </ul>"},{"location":"ud1/14datatypejava/","title":"\ud83d\udcbe Tipos de datos","text":"<p>Un tipo de datos es un conjunto de valores y un conjunto de operaciones definidas en ellos. Se pueden clasificar en primitivos y objetos.</p> <p></p>"},{"location":"ud1/14datatypejava/#tipos-primitivos","title":"\ud83d\udd39 Tipos primitivos","text":"<p>Los primitivos son los m\u00e1s b\u00e1sicos y fundamentales, vienen integrados en Java. Especifican el tipo de valor almacenado en una variable y el tama\u00f1o en memoria.  </p> <p>\ud83d\udc49 Existen 8 tipos primitivos en Java: <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, <code>boolean</code> y <code>char</code>.</p> \ud83e\udde9 Primitive data type \ud83d\udce6 Wrapper class byte Byte short Short int Integer long Long float Float double Double boolean Boolean char Character"},{"location":"ud1/14datatypejava/#byte","title":"\ud83d\udd38 byte","text":"<p>Como su propio nombre denota, emplea un solo byte (8 bits) de almacenamiento.</p> <ul> <li>Tama\u00f1o: 8 bits  </li> <li>Rango: [-128, 127]  </li> <li>Se usa raramente, ocupa muy poca memoria.</li> </ul> <pre><code>  byte b = 2;\n</code></pre>"},{"location":"ud1/14datatypejava/#short","title":"\ud83d\udd38 short","text":"<ul> <li>Tama\u00f1o: 16 bits</li> <li>Rango: [-32.768, 32.767]</li> </ul> <pre><code>  short s = 3467;\n</code></pre>"},{"location":"ud1/14datatypejava/#int","title":"\ud83d\udd38 int","text":"<ul> <li>Tama\u00f1o: 32 bits</li> <li>Rango: [-2.147.483.648, 2.147.483.647]</li> <li>\u2705 Es el entero predeterminado en Java.</li> </ul> <pre><code>        int maxValor = 2147483647;\n// Desde Java 7 puedes usar guiones bajos\nint maxValue = 2_147_483_647;\n</code></pre>"},{"location":"ud1/14datatypejava/#long","title":"\ud83d\udd38 long","text":"<p>Es el tipo entero de mayor tama\u00f1o.</p> <ul> <li>Tama\u00f1o: 64 bits</li> <li>Rango: [-9.223.372.036.854.775.808, 9.223.372.036.854.775.807]</li> <li>Se indica con una L al final.</li> </ul> <pre><code>  long myLongNumber = 500L;\n</code></pre>"},{"location":"ud1/14datatypejava/#float","title":"\ud83d\udd38 float","text":"<p>Tiene una parte flotante que sirve para expresar n\u00fameros decimales. No se recomienda mucho su uso.</p> <ul> <li>Tama\u00f1o: 32 bits</li> <li>Rango: \u00b11.4E-45 a \u00b13.4028235E38</li> <li>Decimales de precisi\u00f3n simple.</li> <li>Se indica con una f al final.</li> </ul> <pre><code>  float f = 4;\nfloat f = 4f;\n</code></pre>"},{"location":"ud1/14datatypejava/#double","title":"\ud83d\udd38 double","text":"<p>Se recomienda su uso. Muchas librer\u00edas internas de Java, relacionadas con operaciones matem\u00e1ticas, usan double.</p> <ul> <li>Tama\u00f1o: 64 bits</li> <li>Rango: \u00b14.9E-324 a \u00b11.7976931348623157E308</li> <li>\u2705 Es el decimal predeterminado en Java.</li> </ul> <pre><code>  double d = 5.0;\ndouble d = 5d;\n</code></pre>"},{"location":"ud1/14datatypejava/#char","title":"\ud83d\udd38 char","text":"<p>Se utiliza para almacenar caracteres (letras, n\u00fameros, signos, etc.) individuales.</p> <ul> <li>Tama\u00f1o: 16 bits</li> <li>Permite almacenar caracteres Unicode (hasta 65.535).</li> <li>\u00datil para representar letras, s\u00edmbolos y emojis.</li> </ul> <p>Unicode es un est\u00e1ndar de codificaci\u00f3n internacional que nos permite representar diferentes idiomas; y la forma en que funciona es usando una combinaci\u00f3n de los dos bytes que un char ocupa en la memoria, que puede representar hasta 65535 diferentes tipos de caracteres. Unicode table.</p> <pre><code>  char c = 'P';\nchar u = '\\u00A2';//print unicode character\n</code></pre> <p>\u26a1 Un car\u00e1cter precedido por una barra invertida () es una secuencia de escape y tiene un significado especial para el compilador. La siguiente tabla muestra las secuencias de escape de Java:</p> <p></p>"},{"location":"ud1/14datatypejava/#boolean","title":"\ud83d\udd38 boolean","text":"<ul> <li>Representa solo dos valores posibles: true o false.</li> <li>Tama\u00f1o no definido exactamente en Java (depende de la JVM).</li> <li>Tiene la finalidad de facilitar el trabajo con valores \"verdadero/falso\" (booleanos), resultantes por regla general de evaluar expresiones.</li> </ul> <pre><code>  boolean isMyNamePatri = true;\n</code></pre>"},{"location":"ud1/14datatypejava/#tipos-de-datos-primitivos-en-java","title":"Tipos de datos primitivos en Java","text":"Tipo Tama\u00f1o en bits Valor m\u00ednimo Valor m\u00e1ximo Ejemplo byte 8 -128 127 <code>byte b = 100;</code> short 16 -32,768 32,767 <code>short s = 1000;</code> int 32 -2,147,483,648 2,147,483,647 <code>int i = 100000;</code> long 64 -9,223,372,036,854,775,808 9,223,372,036,854,775,807 <code>long l = 100000L;</code> float 32 \u2248 \u00b11.4E-45 \u2248 \u00b13.4028235E38 <code>float f = 3.14f;</code> double 64 \u2248 \u00b14.9E-324 \u2248 \u00b11.7976931348623157E308 <code>double d = 3.14;</code> char 16 0 ( '\\u0000' ) 65,535 ( '\\uffff' ) <code>char c = 'A';</code> boolean 1 bit* <code>true</code> / <code>false</code> \u2014 <code>boolean b = true;</code> <p>* El tama\u00f1o de <code>boolean</code> no est\u00e1 especificado exactamente en Java; internamente depende de la JVM, pero conceptualmente ocupa 1 bit.</p>"},{"location":"ud1/14datatypejava/#wrapper-classes-en-java-clases-contenedores","title":"\ud83d\udce6 Wrapper classes en Java (clases contenedores)","text":"<p>Las clases contenedoras o Wrapper classes proporcionan una forma de utilizar tipos de datos primitivos como objetos. </p> <p>Son muy \u00fatiles para operaciones avanzadas y colecciones (ej. ArrayList).</p> <p>En Java, tenemos una Wrapper class para cada uno de los 8 tipos de datos primitivos. Gracias a esto, podemos realizar operaciones en un dato primitivo.</p>"},{"location":"ud1/14datatypejava/#wrapper-classes-en-java","title":"\ud83d\udce6 Wrapper classes en Java","text":"Tipo primitivo Wrapper class M\u00e9todos \u00fatiles byte Byte <code>Byte.parseByte(\"1\")</code>, <code>Byte.MIN_VALUE</code> (-128), <code>Byte.MAX_VALUE</code> (127) short Short <code>Short.parseShort(\"12\")</code>, <code>Short.MIN_VALUE</code> (-32,768), <code>Short.MAX_VALUE</code> (32,767) int Integer <code>Integer.parseInt(\"123\")</code>, <code>Integer.MIN_VALUE</code> (-2,147,483,648), <code>Integer.MAX_VALUE</code> (2,147,483,647) long Long <code>Long.parseLong(\"9999\")</code>, <code>Long.MIN_VALUE</code> (-9,223,372,036,854,775,808), <code>Long.MAX_VALUE</code> (9,223,372,036,854,775,807) float Float <code>Float.parseFloat(\"3.14\")</code>, <code>Float.MIN_VALUE</code> (\u22481.4E-45), <code>Float.MAX_VALUE</code> (\u22483.4028235E38) double Double <code>Double.parseDouble(\"2.71\")</code>, <code>Double.MIN_VALUE</code> (\u22484.9E-324), <code>Double.MAX_VALUE</code> (\u22481.7976931348623157E308) boolean Boolean <code>Boolean.parseBoolean(\"true\")</code>, <code>Boolean.TRUE</code>, <code>Boolean.FALSE</code> char Character <code>Character.isLetter('a')</code>, <code>Character.MIN_VALUE</code> (<code>'\\u0000'</code>), <code>Character.MAX_VALUE</code> (<code>'\\uffff'</code>) <pre><code>   int minimoValorInt = Integer.MIN_VALUE;\nint i = Integer.parseInt(\"123\");   // 123 (int)\n</code></pre> <p>\ud83d\udcd0 Cu\u00e1ndo usar <code>float</code> vs <code>double</code></p> Tipo Precisi\u00f3n Memoria Uso recomendado float ~7 cifras decimales 32 bits - Arrays grandes de n\u00fameros decimales (ahorro memoria)  - Gr\u00e1ficos 2D/3D, librer\u00edas que lo requieran (OpenGL, motores de juego)  - Dispositivos con memoria limitada double ~15 cifras decimales 64 bits - C\u00e1lculos matem\u00e1ticos y cient\u00edficos  - Finanzas y datos sensibles a la precisi\u00f3n  - Es el tipo decimal predeterminado en Java"},{"location":"ud1/15operators/","title":"\ud83d\udcbe Operadores","text":"<p>Los operadores son s\u00edmbolos especiales en Java que realizan operaciones entre uno o varios operandos y devuelve un resultado. Uno de los m\u00e1s usados es el operador suma (+) como hemos visto en clases anteriores.</p>"},{"location":"ud1/15operators/#operando","title":"Operando","text":"<p>Es cualquier t\u00e9rmino, que puede ser una variable o valor y que es manipulado por un operador.</p> <pre><code>   int valor = 8;\nint numero = valor + 12;\n</code></pre> <p>En el ejemplo anterior, + es el operador y valor y 12 son los operandos. valor + 12 es una expresi\u00f3n que devuelve el resultado de 20.</p>"},{"location":"ud1/15operators/#expresiones","title":"Expresiones","text":"<p>Una expresi\u00f3n es una combinaci\u00f3n de literales, operadores, nombres de variables y par\u00e9ntesis que se utilizan para calcular un valor.</p> <pre><code>  int miPrimerEntero = 7 + 5;\nint resultado = 0;\n\nresultado = (miPrimerEntero * 10) / (32 + 12);\n</code></pre> <p>Java examina la expresi\u00f3n de la derecha del signo igual y realiza el c\u00e1lculo de una expresi\u00f3n matem\u00e1tica. Despu\u00e9s asigna ese valor a la variable resultado. Podr\u00edamos complicar m\u00e1s la expresi\u00f3n utilizando operadores como par\u00e9ntesis, multiplicaciones, divisiones, etc.</p> <p>Las partes de una expresi\u00f3n deben estar ordenadas correctamente. Las reglas para las expresiones Java correctas son casi las mismas que las del \u00e1lgebra:</p> <ol> <li> <p>Cada operador debe tener el n\u00famero correcto de operandos.</p> <ul> <li>Multiplicaci\u00f3n *, Divisi\u00f3n /, Suma +, Resta: debe tener dos operandos, uno en cada lado.</li> <li>La negaci\u00f3n - y unario m\u00e1s + deben ir seguidos de un operando.</li> </ul> </li> <li> <p>Los par\u00e9ntesis () pueden rodear una expresi\u00f3n legal para convertirla en operando.</p> </li> </ol> <p></p>"},{"location":"ud1/15operators/#expresiones-mixtas-con-int-y-double","title":"Expresiones mixtas con int y double","text":"<p>Si ambos operandos de un operador aritm\u00e9tico son de tipo int, entonces la operaci\u00f3n es una operaci\u00f3n entera. Si alg\u00fan operando es de punto flotante, entonces la operaci\u00f3n es de punto flotante.</p>"},{"location":"ud1/15operators/#tipos-de-operadores-en-java","title":"Tipos de operadores en Java","text":"<p>Java proporciona muchos tipos de operadores que se pueden usar seg\u00fan la necesidad. Se clasifican seg\u00fan la funcionalidad que brindan. Algunos de los tipos son los siguientes:</p> <p>Operadores aritm\u00e9ticos, unarios, de asignaci\u00f3n, relacionales, l\u00f3gicos, etc.</p>"},{"location":"ud1/15operators/#operador-de-asignacion","title":"Operador de asignaci\u00f3n (=)","text":"<p>Es uno de los operadores m\u00e1s usados. Se usa para asignar un valor a cualquier variable. Tiene una asociaci\u00f3n de derecha a izquierda, es decir, el valor dado en el lado derecho del operador se asigna a la variable de la izquierda y, por lo tanto, el valor del lado derecho debe declararse antes de usarlo o debe ser una constante.</p>"},{"location":"ud1/15operators/#operadores-aritmeticos","title":"Operadores aritm\u00e9ticos","text":"<p>Se utilizan para realizar operaciones aritm\u00e9ticas simples.</p> S\u00edmbolo Operaci\u00f3n Descripci\u00f3n + Suma Realiza la suma de los operandos. - Resta Realiza la resta de los operandos. * Producto Multiplica los operandos. / Divisi\u00f3n Realiza la divisi\u00f3n. % M\u00f3dulo Calcula el resto."},{"location":"ud1/15operators/#operadores-unarios","title":"Operadores unarios","text":"<p>Los operadores unarios solo necesitan un operando. Se usan para incrementar, disminuir o negar un valor.</p> S\u00edmbolo Operaci\u00f3n Descripci\u00f3n ++ Incremento Incrementa el valor en 1 unidad. -- Decremento El valor disminuye en 1 unidad. ! NOT l\u00f3gico Invierte un valor booleano. <p>Existen dos versiones de estos operadores:</p> <ul> <li>Pre-incremento y pre-decremento. El valor se aumenta/disminuye primero y luego se calcula el resultado.</li> </ul> <p></p> <pre><code> int a = 8, b = 1;\nb = ++a; //b=9, a=9\n</code></pre> <ul> <li>Post-Incremento y post-decremento: el valor se usa por primera vez para calcular el resultado y luego se incrementa/decrementa.</li> </ul> <pre><code> int a = 8, b = 1;\nb = a++;//b = 8, a = 9\n</code></pre> <p></p>"},{"location":"ud1/15operators/#operadores-relacionales","title":"Operadores relacionales","text":"<p>Estos operadores se utilizan para verificar relaciones como igualdad, mayor que, menor que. Devuelven el resultado booleano despu\u00e9s de la comparaci\u00f3n.</p> S\u00edmbolo Operaci\u00f3n Descripci\u00f3n == Igual a Devuelve verdadero si el valor de la izquierda del s\u00edmbolo es igual al de la derecha. != Distinto a Devuelve verdadero si el valor de la izquierda es distinto al de la derecha. &lt; Menor que Devuelve verdadero si el valor de la izquierda es menor que el de la derecha. &lt;= Menor o igual que Devuelve verdadero si el valor de la izquierda es menor o igual que el de la derecha. &gt; Mayor que Devuelve verdadero si el valor de la izquierda es mayor que el de la derecha. &gt;= Mayor o igual que Devuelve verdadero si el valor de la izquierda es mayor o igual al de la derecha. <pre><code>  int a = 20, b = 10;\nSystem.out.println(\"a == b :\" + (a == b));//Devuelve falso, porque a no es igual a b\n</code></pre>"},{"location":"ud1/15operators/#operadores-logicos","title":"Operadores l\u00f3gicos","text":"<p>Estos operadores se utilizan para realizar operaciones l\u00f3gicas AND y OR. Se usa ampliamente en sentencias if-then o bucles para verificar condiciones, establecer un punto de salida de un bucle o la toma de  decisiones. Los operadores condicionales son:</p> S\u00edmbolo Operaci\u00f3n Descripci\u00f3n &amp;&amp; AND l\u00f3gico Devuelve verdadero cuando ambas condiciones son ciertas. || OR l\u00f3gico Devuelve verdadero si al menos una condici\u00f3n es cierta. <p></p> <pre><code>    int a = 20, b = 10, c= 10;\nSystem.out.println((b == c &amp;&amp; a == c)); //False\nSystem.out.println((a == c &amp;&amp; b == c)); //False\nSystem.out.println((a == b || b == c)); //True\n</code></pre>"},{"location":"ud1/15operators/#operadores-de-bits","title":"Operadores de bits","text":"S\u00edmbolo Operaci\u00f3n Descripci\u00f3n &amp; AND Si ambos bits de entrada son 1, establece como resultado 1. De lo contrario 0. | OR Si por lo menos uno de los bits de entrada es 1, establece como resultado 1. De lo contrario 0. ^ XOR Si uno de los bits de entrada es 1 y el otro 0, establece como resultado 1. Si los bits son iguales establece 0. ~ NOT Invierte todos los bits y devuelve el resultado en complemento a 2."},{"location":"ud1/15operators/#operador-ternario","title":"Operador ternario (?:)","text":"<p>Ternario es una versi\u00f3n abreviada de la sentencia if-else. Tiene tres operandos y de ah\u00ed el nombre ternario. El formato general es:</p> <p></p> <p>La declaraci\u00f3n anterior significa que si la condici\u00f3n se eval\u00faa como verdadera, entonces ejecuta las instrucciones despu\u00e9s del \u2018?\u2018 de lo contrario, ejecuta las instrucciones despu\u00e9s de \u2018:\u2018.</p> <pre><code>  int nota = 7;\nString notaFinal = (nota &gt;= 5) ? \"Aprobado\" : \"Suspendido\";\nSystem.out.println(notaFinal); //muestra Aprobado\n</code></pre>"},{"location":"ud1/15operators/#abreviaciones","title":"Abreviaciones","text":"<p>En muchos casos, el operador de asignaci\u00f3n se puede combinar con otros operadores para construir una versi\u00f3n m\u00e1s corta de la declaraci\u00f3n llamada Declaraci\u00f3n Compuesta (Compound Statement).</p> <ul> <li>+= , para sumar el operando izquierdo con el operando derecho y luego asignarlo a la variable de la izquierda.</li> </ul> <pre><code>  int a = 5;\na += 5; // a = a + 5;\n</code></pre> <ul> <li>\u2013 = , para restar el operando izquierdo con el operando derecho y luego asignarlo a la variable de la izquierda.</li> </ul> <pre><code>  int a = 5;\na -= 5; // a = a - 5;\n</code></pre> <ul> <li>*= , para multiplicar el operando izquierdo con el operando derecho y luego asign\u00e1ndolo a la variable de la izquierda.</li> </ul> <pre><code>  int a = 5;\na *= 5; // a = a * 5;\n</code></pre> <ul> <li>/ = , para dividir el operando izquierdo con el operando derecho y luego asignarlo a la variable de la izquierda.</li> </ul> <pre><code>  int a = 5;\na /= 5; // a = a / 5;\n</code></pre> <ul> <li>% = , para asignar el m\u00f3dulo del operando izquierdo con el operando derecho y luego asignarlo a la variable de la izquierda.</li> </ul> <pre><code>  int a = 5;\na %= 5; // a = a % 5;\n</code></pre>"},{"location":"ud1/15operators/#precedencia-de-operadores","title":"Precedencia de operadores","text":"<p>El orden de precedencia, es decir, como Java decide la prioridad al evaluar los operadores en una expresi\u00f3n, se puede ver en Java Operator Precedence Table</p>"},{"location":"ud1/15operators/#conversiones-de-tipo","title":"Conversiones de tipo","text":""},{"location":"ud1/15operators/#conversiones-por-defecto","title":"Conversiones por defecto","text":"<p>Las reglas de Java para saber el tipo de datos resultante de una expresi\u00f3n se siguen las siguientes reglas:</p> Si alg\u00fan operando es El otro operando se transforma a double double float float long long byte or short int <p>Si se aplican dos regla, se elige la que aparece primero en la tabla.</p>"},{"location":"ud1/15operators/#conversiones-forzosas-casting-entre-tipos-nativos","title":"Conversiones forzosas (casting entre tipos nativos)","text":"<p>Es una forma de convertir un n\u00famero de un tipo a otro tipo de dato. Para hacerlo ponemos en par\u00e9ntesis el tipo de dato al que queremos convertirlo.</p> <pre><code>    byte miByte = (byte) (14 / 2); //conviero la operaci\u00f3n divisi\u00f3n que devuelve un int a byte\n\n//Otra forma\nfloat a = 8.0f;\nint b = 10;\nb = (int) a;//convierto el tipo float a int\n</code></pre> <p>Otros operadores</p> <p>Existen m\u00e1s operadores que no se han mencionado en el curso. Si se desea consultar todos los operadores de Java se pueden ver en su documentaci\u00f3n oficial. More information</p>"},{"location":"ud1/15operators/#sintaxis-de-las-expresiones-matematicas","title":"Sintaxis de las expresiones matem\u00e1ticas","text":"M\u00e9todo Returns Ejemplo Math.abs valor absoluto Math.abs(-308) returns 308 Math.ceil redondeo hacia arriba Math.ceil(2.13) returns 3.0 Math.floor redondeo hacia abajo Math.floor(2.93) returns 2.0 Math.max valor m\u00e1x. de dos valores Math.max(45, 207) returns 207 Math.min valor min. de dos valores Math.min(3.8, 2.75) returns 2.75 Math.pow potencia Math.pow(3, 4) returns 81.0 Math.round redondear al entero m\u00e1s cercano Math.round(2.718) returns 3 Math.sqrt ra\u00edz cuadrada Math.sqrt(81) returns 9.0"},{"location":"ud1/16comments/","title":"\ud83d\udcbe Comentarios en Java","text":"<p>Los comentarios son ignorados por el ordenador y se usan en el programa para ayudar a describir alguna funcionalidad o explicaci\u00f3n del c\u00f3digo fuente. Existen dos tipos de comentarios.</p>"},{"location":"ud1/16comments/#comentarios-de-una-linea","title":"Comentarios de una l\u00ednea","text":"<p>Usamos la doble barra // para realizar un comentario de una sola l\u00ednea. Lo podemos usar en una l\u00ednea en blanco o detr\u00e1s del c\u00f3digo.</p> <pre><code>   int gravity; //variable para calcular la gravedad\n</code></pre>"},{"location":"ud1/16comments/#comentarios-multilinea","title":"Comentarios multil\u00ednea","text":"<p>Usamos la barra con asterisco doble para realizar comentarios que afecten a m\u00e1s de una l\u00ednea. De forma que cuando abramos un comentario usaremos /*, para cerrarlo */.</p> <pre><code>   /*\n      Clase que almacena en la base de datos\n      los datos de una persona.\n   */\npublic class Persona {\n...\n}\n</code></pre>"},{"location":"ud1/17constantesliterales/","title":"\ud83d\udcbe Constantes y literales","text":""},{"location":"ud1/17constantesliterales/#las-constantes","title":"Las constantes","text":"<p>Un programa puede contener ciertos valores que no deben cambiar durante su ejecuci\u00f3n. Estos valores se llaman constantes. Definici\u00f3n: Una constante es una zona de memoria que se referencia con un identificador, conocido como nombre de la constante, donde se almacena un valor que no puede cambiar durante la ejecuci\u00f3n del programa.</p> <p>La nomenclatura para definiar las constantes es la siguiente:</p> <ul> <li>Todas las letras de cada palabra deben estar en may\u00fasculas</li> <li>Se separa cada palabra con un _</li> <li>Se declaran similar a las variables, con la diferencia de que el tipo de dato va despu\u00e9s de la palabra reservada final</li> </ul> <pre><code>    final double PI = 3.141591;\nfinal int MIN_WIDTH = 4;\nfinal double TASAS = 0.045;\n</code></pre> <p>Las constantes hacen que el programa sea m\u00e1s f\u00e1cil de leer y verificar que sea correcto. Si es necesario cambiar una constante (por ejemplo, si cambian las tasas), todo lo que tendremos que hacer es cambiar la declaraci\u00f3n de la constante. No ser\u00e1 necesario buscar en todo el programa cada aparici\u00f3n de ese n\u00famero espec\u00edfico.</p>"},{"location":"ud1/17constantesliterales/#los-literales","title":"Los literales","text":"<p>Un literal Java es un valor de tipo entero, real, l\u00f3gico, car\u00e1cter, cadena de caracteres o un valor nulo (null) que puede aparecer dentro de un programa. Por ejemplo: 150, 12.4, \u201cANA\u201d, null, \u2018t\u2019. Los literales suelen aparecer en la asignaci\u00f3n de valores a las variables o formando parte de expresiones aritm\u00e9ticas o l\u00f3gicas.</p> <p></p>"},{"location":"ud1/18inputoutputconsole/","title":"\ud83d\udcbe Programaci\u00f3n de la consola: entrada y salida de informaci\u00f3n (I/O input/output)","text":"<p>Java viene con una biblioteca de clases que se puede usar para realizar tareas comunes. La biblioteca de clases de Java est\u00e1 organizada en un conjunto de paquetes, donde cada paquete contiene una colecci\u00f3n de clases relacionadas.</p> <p>En esta secci\u00f3n presentamos las clases System y Scanner que se utilizan para imprimir la salida y leer la entrada de un programa.</p> <p>El tipo m\u00e1s simple de interfaz de usuario es la interfaz de l\u00ednea de comandos, en la que la entrada se toma de la l\u00ednea de comandos a trav\u00e9s del teclado y la salida se muestra en la consola. Algunas aplicaciones Java utilizan este tipo de interfaz otros usan interfaz gr\u00e1fica como veremos m\u00e1s adelante.</p> <p></p> <p></p>"},{"location":"ud1/18inputoutputconsole/#salida-de-la-informacion","title":"Salida de la informaci\u00f3n","text":"<p>En Java, cualquier origen o destino de I/O se considera un flujo de bytes o caracteres. Para realizar la salida, insertamos bytes o caracteres en la secuencia. Para realizar la entrada, extraemos bytes o caracteres del flujo (stream). Incluso los caracteres introducidos en un teclado, si se consideran como una secuencia de pulsaciones de teclas, se pueden representar como un stream.</p> <p>En Java, la I/O se maneja a trav\u00e9s de m\u00e9todos que pertenecen a clases contenidas en el paquete java.io. Ya hemos visto c\u00f3mo se usa el m\u00e9todo de salida println() para enviar una cadena a la consola. Por ejemplo:</p> <pre><code>   System.out.println(\"Hola mundo\");\n</code></pre> <p>imprime el texto Hola mundo por la consola.</p> <p>Los objetos System.out y System.err se pueden usar para escribir la salida en la consola. Como sugiere su nombre, el flujo de errores se usa principalmente para mensajes de error, mientras que el flujo de salida se usa para otras salidas impresas.</p> <pre><code>   System.err.println(\"Fallo al abrir el fichero\");\n</code></pre> <p>De manera similar, como sugiere su nombre, el objeto System.in se puede usar para manejar la entrada, que se trata en el siguiente punto.</p> <p>La \u00fanica diferencia entre los m\u00e9todos print() y println() es que println() tambi\u00e9n imprimir\u00e1 un retorno de carro y un avance de l\u00ednea despu\u00e9s de imprimir sus datos, lo que permitir\u00e1 que la salida posterior se imprima en una nueva l\u00ednea. Por ejemplo:</p> <pre><code>   System.out.print(\"Hola\");\nSystem.out.print(\"mundo\"):\nSystem.out.println(\"Texto con salto de l\u00ednea\");\nSystem.out.println(\"adi\u00f3s\");\n</code></pre> <pre><code>   HolamundoTexto con salto de l\u00ednea\n   adi\u00f3s\n</code></pre>"},{"location":"ud1/18inputoutputconsole/#entrada-de-la-informacion-javautilscanner","title":"Entrada de la informaci\u00f3n java.util.Scanner","text":"<p>Se ha agregado la clase Scanner al paquete java.util que permite la entrada de teclado sin forzar el programador para manejar las excepciones. La clase Scanner est\u00e1 dise\u00f1ada para ser una forma muy flexible de reconocer fragmentos de datos que se ajustan a patrones espec\u00edficos de cualquier flujo de entrada.</p> <p>Para usar la clase Scanner para la entrada de teclado, debemos crear una instancia de Scanner y asociarla con System.in. La clase tiene un constructor para este prop\u00f3sito, por lo que la declaraci\u00f3n</p> <pre><code>   Scanner sc = new Scanner(System.in);\n</code></pre> <p>declara y crea una instancia de un objeto que se puede utilizar para la entrada del teclado. Despu\u00e9s de crear un objeto Scanner, podemos hacer una llamada a nextInt(), nextDouble(), o next() para leer, respectivamente, un entero, un n\u00famero real, o String del teclado.</p> <pre><code>   public static void main(String[] args) {\nScanner sc = new Scanner (System.in);\nSystem.out.print(\"Introduce un n\u00famero: \");\nint num = sc.nextInt();//Read the integer\nSystem.out.println(\"El n\u00famero introducido es: \" + num);\n}\n</code></pre> <p>Cuando se ejecuta el m\u00e9todo nextInt(), no se ejecutan m\u00e1s declaraciones hasta que el m\u00e9todo devuelve un valor int. Normalmente, esto no sucede hasta que el usuario ha escrito los d\u00edgitos de un n\u00famero entero y presiona la tecla Intro o Intro.</p> <p>Para leer un String utilizamos el m\u00e9todo next().</p> <pre><code>   public static void main(String[] args) {\nScanner sc = new Scanner (System.in);\nSystem.out.print(\"Introduce una palabra: \");\nString str = sc.next();\nSystem.out.println(str);\n}\n</code></pre> <p>Un objeto Scanner tiene un conjunto de cadenas de caracteres que separan o delimitan los fragmentos de datos que est\u00e1 buscando. De forma predeterminada, este conjunto de delimitadores consta de cualquier secuencia no vac\u00eda de caracteres en blanco, es decir, los caracteres de espacio, tabulaci\u00f3n, retorno y nueva l\u00ednea. Esto permitir\u00e1 al usuario ingresar varios n\u00fameros enteros separados por espacios antes de presionar la tecla Enter. En c\u00f3digo ser\u00eda:</p> <pre><code>   System.out.print(\"Introduce dos n\u00fameros: \");\nint num = sc.nextInt();\nint num2 = sc.nextInt();\n</code></pre> <p>Los espacios en blanco como delimitadores tambi\u00e9n significan que el m\u00e9todo next() no puede devolver una cadena vac\u00eda ni puede devolver una cadena que contenga espacios. Por ejemplo, considere el c\u00f3digo:</p> <pre><code>   System.out.print(\"Introduce un texto separado por espacio en blanco: \");\nString str = sc.next();\n</code></pre> <p>Si se escribe \"Hola mundo\" y se presiona la tecla enter, la cadena str almacenar\u00e1 s\u00f3lo \"Hola\".</p> <p>Para que un objeto Scanner lea cadenas que contienen espacios, debemos usar el m\u00e9todo nextLine():</p> <pre><code>   String str = sc.nextLine();\n</code></pre>"},{"location":"ud1/19poo/","title":"\ud83d\udcbe Introducci\u00f3n a la programaci\u00f3n orientada a objetos","text":"<p>La programaci\u00f3n modular es un paradigma que consiste en dividir un programa en m\u00f3dulos con el fin de hacerlo m\u00e1s legible y manejable. Enfatiza este concepto mediante la construcci\u00f3n de aplicaciones a partir de su divisi\u00f3n en componentes independientes que llevan a cabo tareas concretas.</p> <p>Al aplicar programaci\u00f3n modular, un problema complejo debe ser dividido en otros subproblemas m\u00e1s simples a\u00fan.</p> <p>Un m\u00f3dulo es cada una de las partes de un programa que resuelve uno de los subproblemas.</p> <p>La programaci\u00f3n orientada a objetos (POO) se basa en la programaci\u00f3n modular, aunque supone una ruptura respecto a \u00e9sta al introducir el concepto de objeto, lo que supone un gran avance en t\u00e9rminos de modularizaci\u00f3n y reutilizaci\u00f3n de c\u00f3digo.</p>"},{"location":"ud1/19poo/#fundamentos-de-la-poo","title":"Fundamentos de la POO","text":"<ul> <li>Abstracci\u00f3n: es el pilar de la POO, un principio por el cual se a\u00edsla toda aquella informaci\u00f3n que no resulta relevante a un determinado nivel de conocimiento. Consiste en captar las caracter\u00edsticas esenciales de un objeto, asi como su comportamiento.</li> <li>Encapsulaci\u00f3n: se centra en ocultad la complejidad de la clase. Significa proteger a los miembros de una clase de un acceso ilegal o no autorizado.</li> <li>Herencia: es el pilar m\u00e1s fuerte que asegura la reutilizaci\u00f3n de c\u00f3digo. Permite la definici\u00f3n de nuevas clases a partir de otras ya existentes.</li> <li>Polimorfismo: posibilita que una misma operaci\u00f3n pueda realizar tareas diferentes, dependiendo del tipo de objeto sobre el cual se ha invocado.</li> </ul>"},{"location":"ud1/19poo/#concepto-de-objeto","title":"Concepto de objeto","text":"<p>Entonces, \u00bfqu\u00e9 es un objeto? Al igual que en el mundo real, un objeto es cualquier cosa. Un objeto puede ser una cosa f\u00edsica, como un coche, o una cosa mental, como una idea. Puede ser algo natural, como un animal, o algo artificial hecho por el hombre, como un cajero autom\u00e1tico. Un programa que administra un cajero autom\u00e1tico involucrar\u00eda cuentas bancarias y objetos de cliente. Un programa de ajedrez involucrar\u00eda un objeto tablero y objetos piezas de ajedrez.</p>"},{"location":"ud1/19poo/#atributos-y-acciones","title":"Atributos y acciones","text":""},{"location":"ud1/19poo/#atributos","title":"Atributos","text":"<p>Al igual que con los objetos reales, los objetos de nuestros programas tienen ciertos atributos o propiedades caracter\u00edsticos. Por ejemplo, un objeto de cajero autom\u00e1tico tendr\u00eda una cantidad actual de efectivo que podr\u00eda dispensar. Un objeto pieza ajedrez puede tener un par de atributos de fila y columna que especifiquen su posici\u00f3n en el tablero de ajedrez. Observe que los atributos de un objeto son en s\u00ed mismos objetos. El atributo de efectivo del cajero autom\u00e1tico y los atributos de fila y columna de la pieza de ajedrez son n\u00fameros.</p> <p>A veces nos referimos a la colecci\u00f3n de atributos y valores de un objeto como su estado.</p>"},{"location":"ud1/19poo/#acciones-o-metodos","title":"Acciones o M\u00e9todos","text":"<p>Adem\u00e1s de sus atributos o propiedades, los objetos tambi\u00e9n tienen acciones o comportamientos caracter\u00edsticos. Como ya dijimos, los objetos en los programas son din\u00e1micos. Hacen cosas o les hacen cosas.</p> <p>Por ejemplo, en un programa de ajedrez, ChessPieces tiene la capacidad de moveTo () a una nueva posici\u00f3n en el tablero de ajedrez. De manera similar, cuando un cliente presiona el bot\u00f3n \"Saldo actual\" en un cajero autom\u00e1tico, esto le est\u00e1 diciendo al cajero autom\u00e1tico que informe () el saldo bancario actual del cliente. (Observe c\u00f3mo usamos par\u00e9ntesis para distinguir acciones de objetos y atributos).</p> <p>Las acciones asociadas con un objeto se pueden utilizar para enviar mensajes a los objetos y recuperar informaci\u00f3n de los objetos. Un mensaje es el paso de informaci\u00f3n o datos de un objeto a otro. En este ejemplo, le decimos a pe\u00f3n1: Pieza de ajedrez que se mueva a (3,4).</p> <pre><code>    chessPiece.move(3, 4);\n</code></pre> <p>Los n\u00fameros 3 y 4 en este caso son argumentos que le dicen al pe\u00f3n a qu\u00e9 casilla moverse. (Un tablero de ajedrez tiene 8 filas y 8 columnas y cada cuadrado se identifica por sus coordenadas de fila y columna). En general, un argumento es un valor de datos que especializa el contenido de un mensaje de alguna manera.</p> <p>Responder a un mensaje o realizar una acci\u00f3n a veces provoca un cambio en el estado de un objeto. Por ejemplo, despu\u00e9s de realizar moveTo (3,4), el pe\u00f3n estar\u00e1 en una casilla diferente. Su posici\u00f3n habr\u00e1 cambiado.</p> <p>Por otro lado, algunos mensajes (o acciones) no modifican el estado del objeto. Informar el saldo de la cuenta bancaria del cliente no cambia el saldo.</p>"},{"location":"ud1/19poo/#caracteristicas-basicas","title":"Caracter\u00edsticas b\u00e1sicas","text":"<ul> <li>Estado: est\u00e1 representado por atributos de un objeto.</li> <li>Comportamiento: se representa mediante m\u00e9todos de un objeto. Tambi\u00e9n refleja la respuesta de un objeto con otros objetos.</li> <li>Identidad: le da un nombre \u00fanico a un objeto y permite que un objeto interact\u00fae con otros objetos.</li> </ul>"},{"location":"ud1/19poo/#creacion-y-destruccion-de-objetos","title":"Creaci\u00f3n y destrucci\u00f3n de objetos","text":""},{"location":"ud1/19poo/#creacion","title":"Creaci\u00f3n","text":"<p>Para crear un objeto utilizamos la palabra reservada new, que asigna memoria del Heap. Se usa el nombre de la clase (constructor) seguido por par\u00e9ntesis. Se le llama instanciar un objeto.</p> <pre><code>    ATM atm = new ATM();\n</code></pre>"},{"location":"ud1/19poo/#destruccion","title":"Destrucci\u00f3n","text":"<p>En Java no es posible destruir objetos de forma expl\u00edcita, los objetos se destruyen de forma autom\u00e1tica por el recolector de basura. Java busca objetos inalcanzables y los destruye, normalmente cuando falta memoria. Los convierte de nuevo en memoria binaria no utilizada.</p>"},{"location":"ud1/19poo/#uso-de-objetos-acceso-a-atributos-y-metodos","title":"Uso de objetos: acceso a atributos y m\u00e9todos","text":"<p>Para acceder a los atributos y m\u00e9todos de un objeto utilizamos la notaci\u00f3n \".\" detr\u00e1s del nombre del objeto. El objeto debe ser creado previamente sino dar\u00e1 error de compilaci\u00f3n.</p> <pre><code>    double cantidad = atm.efectivo;\natm.mostrarEfectivo();\n</code></pre> <p>M\u00e1s adelante veremos la visibilidad de los m\u00e9todos y atributos de los objetos.</p>"},{"location":"ud1/19poo/#ejemplo-completo-de-clase-coche","title":"Ejemplo completo de clase Coche","text":"<pre><code>public class Coche {\n\n//atributos, campos o estado\nprivate String marca;\nprivate String modelo;\nprivate int km;\nprivate LocalDate fabricacion;\n\n//acciones o comportamiento\npublic void arrancar(){}\n\npublic void frenar() {}\n\npublic void repostar(){}\n}\n</code></pre>"},{"location":"ud1/1elementos/","title":"\ud83d\udcbe Elementos de un programa inform\u00e1tico","text":"<p> Un programa es una secuencia de instrucciones que un ordenador ejecuta para realizar alguna tarea. Parece una idea bastante simple, pero para que el ordenador pueda hacer uso de las instrucciones, deben estar escritas de forma que las pueda usar. Esto significa que los programas deben estar escritos en lenguajes de programaci\u00f3n.   Los lenguajes de programaci\u00f3n se diferencian de los lenguajes humanos ordinarios en que son completamente inequ\u00edvocos y muy estrictos sobre lo que est\u00e1 y no est\u00e1 permitido en un programa. Las reglas que determinan lo que est\u00e1 permitido se denominan sintaxis del lenguaje. Las reglas de sintaxis especifican el vocabulario b\u00e1sico del lenguaje y c\u00f3mo se pueden construir los programas. </p>"},{"location":"ud1/1elementos/#lenguajes-de-programacion","title":"\ud83d\udcbb Lenguajes de programaci\u00f3n","text":"<p>Un lenguaje de programaci\u00f3n es un sistema de s\u00edmbolos e instrucciones que permite a las personas comunicarse con los ordenadores para darles \u00f3rdenes y desarrollar aplicaciones de todo tipo.</p> <p>Existen muchos lenguajes, cada uno con sus caracter\u00edsticas y \u00e1mbitos de aplicaci\u00f3n. El \u00edndice TIOBE \ud83d\udcca es una de las referencias m\u00e1s conocidas para medir su popularidad en funci\u00f3n de su uso en la industria y la comunidad.</p> <p>Algunos ejemplos destacados son:</p> <ul> <li> <p>\ud83d\udfe6 C \u2192 muy utilizado en el desarrollo de sistemas y aplicaciones de alto rendimiento, como bases de datos, videojuegos \ud83c\udfae, el n\u00facleo de Linux \ud83d\udc27, IoT y dispositivos inteligentes.</p> </li> <li> <p>\ud83d\udc0d Python \u2192 popular por su sencillez y versatilidad; ampliamente usado en inteligencia artificial \ud83e\udd16, an\u00e1lisis de datos \ud83d\udcca, big data y automatizaci\u00f3n.</p> </li> <li> <p>\u2615 Java \u2192 orientado a la portabilidad y robustez; empleado en puntos de venta \ud83d\uded2, aplicaciones de escritorio \ud83d\udcbb, cajeros autom\u00e1ticos \ud83c\udfe7 y dispositivos m\u00f3viles \ud83d\udcf1.</p> </li> </ul> <p></p>"},{"location":"ud1/1elementos/#con-que-lenguaje-de-programacion-debo-empezar","title":"\u00bfCon qu\u00e9 lenguaje de programaci\u00f3n debo empezar?","text":"<p>En realidad, no existe el mejor lenguaje de programaci\u00f3n para empezar, y el lenguaje que elijas pr\u00e1cticamente no tendr\u00e1 un efecto duradero en tu carrera. Los lenguajes de programaci\u00f3n pueden verse muy diferentes en la superficie, pero la mayor\u00eda de los conceptos fundamentales se transferir\u00e1n de un lenguaje a otro. Aprender un nuevo idioma tambi\u00e9n ser\u00e1 m\u00e1s f\u00e1cil con el tiempo; un principiante puede tardar meses antes de que se sienta c\u00f3modo con su primer lenguaje; un programador experimentado puede familiarizarse con un nuevo idioma en cuesti\u00f3n de d\u00edas.</p>"},{"location":"ud1/1elementos/#7-tips-para-aprender-a-programar-con-exito","title":"7 Tips para aprender a programar con \u00e9xito","text":"<pre><code>1. Learn by doing. Always play with the code while learning\n2. Grasp the fundamentals for long-term benefits\n3. Code by hand. It sharpens proficiency and you\u2019ll need it to get a job\n4. Ask for help. You\u2019ll need it\n5. Seek out more online resources. There\u2019s a wealth of content\n6. Don\u2019t just read the sample code. Tinker with it!\n7. Take breaks when debugging\n</code></pre> <p>Tip</p> <p>S\u00e9 persistente, no te rindas!</p>"},{"location":"ud10/1persistence/","title":"Persistencia de la informaci\u00f3n","text":"<p>La persistencia es la capacidad de guardar el estado de un objeto en alg\u00fan tipo de almacenamiento, para poder restaurarlo en alg\u00fan momento posteriormente.</p> <p></p> <p>Hoy en d\u00eda, la mayor\u00eda de aplicaciones inform\u00e1ticas necesitan almacenar y gestionar gran cantidad de datos.</p> <p>Esos datos, se suelen guardar en bases de datos relacionales, ya que \u00e9stas son las m\u00e1s extendidas actualmente.</p>"},{"location":"ud10/1persistence/#tipos-de-bases-de-datos","title":"Tipos de bases de datos","text":"<p>Una base de datos es una herramienta que recopila datos, los organiza y los relaciona para que se pueda hacer una r\u00e1pida b\u00fasqueda y recuperar con ayuda de un ordenador. Hoy en d\u00eda, las bases de datos tambi\u00e9n sirven para desarrollar an\u00e1lisis. Las bases de datos m\u00e1s modernas tienen motores espec\u00edficos para sacar informes de datos complejos.</p> <p>Adem\u00e1s, es importante saber que hay varios tipos de base de datos: la relacional; la distribuida; NoSQL; orientada a objetos; y, gr\u00e1ficas. La existencia de estas diversas bases de datos se debe a la variedad de forma de trabajo que se requiere de ellas.</p> <p>Las bases de datos relacionales representan la informaci\u00f3n en forma de tablas, con filas y columnas que se relacionan mediante campos clave. Adem\u00e1s se trabaja con el lenguaje est\u00e1ndar conocido como SQL, para poder realizar las consultas que deseemos a la base de datos.</p> <p>El sistema gestor de bases de datos, en ingl\u00e9s conocido como: Database Management System (DBMS), gestiona el modo en que los datos se almacenan, mantienen y recuperan.</p> <p>En el caso de una base de datos relacional, el sistema gestor de base de datos se denomina: Relational Database Management System (RDBMS).</p> <p></p> <p>Tradicionalmente, la programaci\u00f3n de bases de datos ha sido un caos debido a la gran cantidad de productos de bases de datos en el mercado, cada uno con sus caracter\u00edsticas y lenguaje diferente.</p>"},{"location":"ud10/2mapeo/","title":"\u26d3\ufe0f Desfase objeto - relacional","text":"<p>Las bases de datos relacionales no est\u00e1n dise\u00f1adas para almacenar objetos, ya que existe un desfase entre las construcciones t\u00edpicas que proporciona el modelo relacional y las proporcionadas por la programaci\u00f3n basada en objetos.</p> <p>El desfase objeto-relacional consiste en la diferencia de aspectos que existen entre la programaci\u00f3n orientada a objetos y la base de datos.</p> <p>Hay que recordar que el modelo relacional trata con relaciones y conjuntos y que, en las BD relacionales tenemos reglas de integridad:</p> <ul> <li>Todas las tablas deben tener una clave primaria</li> <li>La clave primaria tiene que ser \u00fanica y no puede ser NULL</li> <li>Para relacionar dos tablas usamos una foreign key</li> </ul> <p>Sin embargo, el modelo de Programaci\u00f3n Orientada a Objetos trata con objetos y las asociaciones entre ellos. Por esta raz\u00f3n, el problema entre estos dos modelos surge en el momento de querer persistir los objetos.</p>"},{"location":"ud10/2mapeo/#mapeo-objeto-relacional","title":"Mapeo objeto - relacional","text":"<p>Al trabajar con POO y BDR tenemos que estar continuamente gestionando los objetos para escribir la sentencia SQL, o recolectar todos los atributos para componer un objeto cuando leemos informaci\u00f3n desde la base de datos.</p> <p>A este conjunto de t\u00e9cnicas se le conoce como mapeo objeto-relacional. Y puede hacerse ayud\u00e1ndose de alguna herramienta o bien manualmente por el programador.</p> <p></p>"},{"location":"ud10/3conectores/","title":"\u2699\ufe0f Conectores o drivers","text":"<p>Un conector o driver es un mecanismo que permite a un lenguaje de programaci\u00f3n conectarse, y trabajar, contra una base de datos. Se encarga de mantener el di\u00e1logo con la base de datos, para poder llevar a cabo el acceso y manipulaci\u00f3n de los datos.</p> <p>Algunos de los m\u00e1s conocidos son:</p> <ul> <li> <p>ODBC (Open Database Connectivity). Es un est\u00e1ndar viejo. Esta tecnolog\u00eda proporciona una interfaz com\u00fan para tener acceso a bases de datos SQL heterog\u00e9neas. ODBC est\u00e1 basado en SQL (Structured Query Language) como un est\u00e1ndar para tener acceso a datos. ODBC permite la conexi\u00f3n f\u00e1cil desde varios lenguajes de programaci\u00f3n y se utiliza mucho en el entorno Windows.</p> </li> <li> <p>JDBC (Java Data Base Connectivity).</p> </li> </ul> <p>En este curso, nos vamos a centrar en JDBC, puesto que, desde el punto de vista de Java, es una de las tecnolog\u00edas m\u00e1s importantes de conectividad a la base de datos. Y, adem\u00e1s, Java 8 ha eliminado el puente JDBC-ODBC, lo que significa que los controladores ODBC de Microsoft ya no funcionan.</p>"},{"location":"ud10/3conectores/#jdbc","title":"JDBC","text":"<p>Casi de forma simult\u00e1nea a ODBC, la empresa Sun Microsystems, en 1997 sac\u00f3 a la luz JDBC, un API conector de bases de datos, implementado espec\u00edficamente para usar con el lenguaje Java. Se trata de un API bastante similar a ODBC en cuanto a funcionalidad, pero adaptado a las especificidades de Java. Es decir, la funcionalidad se encuentra capsulada en clases (ya que Java es un lenguaje totalmente orientado a objetos) y, adem\u00e1s, no depende de ninguna plataforma espec\u00edfica, de acuerdo con la caracter\u00edstica multiplataforma defendida por Java.</p> <p>Es una API que permite la ejecuci\u00f3n de operaciones contra una base de datos desde Java independientemente del sistema operativo donde se ejecute o de la base de datos a la cual se acceda.</p> <p></p> <p>Es importante destacar tambi\u00e9n que JDBC no exige ninguna instalaci\u00f3n, ni ning\u00fan cambio sustancial en el c\u00f3digo a la hora de utilizar uno u otro controlador. Esta caracter\u00edstica se sustenta, en primer lugar, en la utilidad de Java que permite cargar program\u00e1ticamente cualquier clase a partir de su nombre; en segundo lugar, en la funcionalidad de la clase DriverManager (de la API JDBC), que sin necesidad de indicarle el driver espec\u00edfico que hay que utilizar es capaz de encontrarlo y seleccionarlo de entre todos los que el sistema tenga cargados en memoria.</p> <p>A pesar de eso tampoco es mucho problema ya que actualmente podemos encontrar un driver JDBC para pr\u00e1cticamente cualquier SGBDR existente. El conector lo proporciona el fabricante de la base de datos o bien un tercero.</p>"},{"location":"ud10/3conectores/#conexion-con-la-bbdd-desde-jdbc","title":"Conexi\u00f3n con la BBDD desde JDBC","text":"<p>Antes de empezar a desarrollar aplicaciones JDBC es necesario aseguramos que tenemos instalado el SGBD, y adem\u00e1s que tenemos acceso desde el lugar donde estemos desarrollando la aplicaci\u00f3n. Una vez verificado el sistema gestor de base de datos, ser\u00e1 necesario obtener el controlador JDBC del sistema gestor. Generalmente, cada fabricante pondr\u00e1 a disposici\u00f3n de sus usuarios los diferentes tipos de controladores que tenga para sus productos. Sea cual sea el tipo de controlador que finalmente necesita, \u00e9ste tendr\u00e1 como m\u00ednimo una biblioteca en formato .jar con todas las clases de la API JDBC. Habr\u00e1 que a\u00f1adir el archivo .jar como biblioteca de nuestra aplicaci\u00f3n.</p> <p>Para descargar el driver JDBC para MySQL podemos hacerlo desde el repositorio de Maven:</p> <p>MySQL JDBC</p>"},{"location":"ud10/3conectores/#establecimiento-y-cierre-de-conexion","title":"Establecimiento y cierre de conexi\u00f3n","text":"<p>Las clases que afectan a la gesti\u00f3n de la conexi\u00f3n con la BBDD son:</p> <ul> <li> <p><code>DriverManager</code>: esta clase se utiliza para registrar el controlador para un tipo de base de datos espec\u00edfico (por ejemplo, MySQL en este tutorial) y para establecer una conexi\u00f3n de base de datos con el servidor a trav\u00e9s de su m\u00e9todo <code>getConnection()</code>.</p> </li> <li> <p><code>Connection</code>, es una interfaz que representa una conexi\u00f3n a la base de datos establecida (sesi\u00f3n) desde la cual podemos crear declaraciones para ejecutar consultas y recuperar resultados, obtener metadatos sobre la base de datos, cerrar conexi\u00f3n, etc.Los objetos <code>Connection</code> mantendr\u00e1n la capacidad de comunicarse con el sistema gestor mientras permanezcan abiertos. Esto es, desde que se crean hasta que se cierran utilizando el m\u00e9todo close.</p> </li> </ul> <p>El objeto <code>Connection</code> est\u00e1 totalmente vinculado a una fuente de datos, por eso en pedir la conexi\u00f3n hay que especificar de qu\u00e9 fuente se trata siguiendo el protocolo JDBC e indicando la url de los datos, y en su caso el usuario y password.</p> <p>Example \ud83e\udd13</p> <ul> <li>jdbc:bbdd://server:port/schema</li> <li>jdbc:postgresql://localhost:5432/severo</li> </ul> <p>La url seguir\u00e1 el protocolo JDBC, comenzar\u00e1 siempre por la palabra jdbc seguida de dos puntos. El resto depender\u00e1 del tipo de controlador utilizado, del host donde se aloje el SGBD, del puerto que este use para escuchar las peticiones y del nombre de la base de datos o esquema con el que queremos trabajar.</p> <pre><code>import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\n\n...\n\npublic static void main(String[] args) {\nString user = \"patricia\";\nString password = \"marti\";\nString url = \"jdbc:mysql://localhost/severo_ad\";\n\ntry (final Connection connection = DriverManager.getConnection(url, user, password)) {\nSystem.out.println(connection.getCatalog());\n} catch (SQLException ex) {\nSystem.out.println(\"SQLException: \" + ex.getMessage());\nSystem.out.println(\"SQLState: \" + ex.getSQLState());\nSystem.out.println(\"VendorError: \" + ex.getErrorCode());\n}\n}\n</code></pre>"},{"location":"ud10/3conectores/#operaciones-basicas","title":"Operaciones b\u00e1sicas","text":"<p>El API JDBC distingue dos tipos de consultas:</p> <ul> <li>Consultas: SELECT</li> <li>Actualizaciones: INSERT, UPDATE, DELETE, sentencias DDL.</li> </ul>"},{"location":"ud10/3conectores/#interfaces-y-clases-principales-de-jdbc","title":"Interfaces y clases principales de JDBC","text":"<ul> <li> <p><code>Statement</code> y <code>PreparedStatement</code>: estas interfaces se utilizan para ejecutar consultas SQL est\u00e1ticas y consultas SQL parametrizadas, respectivamente. <code>Statement</code> es la superinterfaz de la interfaz <code>PreparedStatement</code>, que se utiliza para consultas parametrizadas. Sus m\u00e9todos com\u00fanmente utilizados son:</p> <ul> <li><code>boolean execute(String sql)</code>: ejecuta una sentencia SQL general. Devuelve verdadero si la consulta devuelve un <code>ResultSet</code>, falso si la consulta devuelve un recuento de actualizaciones o no devuelve nada. Este m\u00e9todo solo se puede utilizar con una sentencia.</li> <li> <p><code>int executeUpdate(String sql)</code>: ejecuta una sentencia INSERT, UPDATE o DELETE y devuelve un conteo actualizado que indica el n\u00famero de filas afectadas (por ejemplo, 1 fila insertada, 2 filas actualizadas o 0 filas afectadas).</p> <pre><code>Statement stmt = con.createStatement();\nString q1 = \"insert into userid values (1,root,Patricia Marti)\";\nint x = stmt.executeUpdate(q1);\n</code></pre> </li> </ul> </li> <li> <p><code>ResultSet executeQuery(String sql)</code>: ejecuta una sentencia SELECT y devuelve un objeto <code>ResultSet</code> que contiene los resultados devueltos por la consulta.</p> <pre><code>Statement stmt = con.createStatement();\nString q1 = \"select * from userid where id = '\" + id + \"' AND pwd = '\" + pwd + \"'\";\nResultSet rs = stmt.executeQuery(q1);\n</code></pre> </li> <li> <p><code>ResultSet</code>: contiene los datos de la tabla devueltos por una consulta SELECT. Este objeto se usa para iterar sobre las filas en el conjunto de resultados usando el m\u00e9todo <code>next()</code>.</p> </li> </ul> <p>\ud83e\udd13 SQLException: Es la excepci\u00f3n que se lanza cuando hay alg\u00fan problema entre la base de datos y el programa Java JDBC. Contiene los siguientes m\u00e9todos:</p> <ul> <li><code>.getMessage()</code>, nos indica la descripci\u00f3n del mensaje de error.</li> <li><code>.getSQLState()</code>, devuelve un c\u00f3digo SQL est\u00e1ndar definido por ISO/ANSI y el Open Group que identifica de forma un\u00edvoca el error que se ha producido. SQLState Official</li> <li><code>.getErrorCode(</code>), es un c\u00f3digo de error que lanza la base de datos. En este caso el c\u00f3digo de error es diferente dependiendo del proveedor de base de datos que estemos utilizando.</li> <li><code>.getCause()</code>, nos devuelve una lista de objetos que han provocado el error.</li> <li><code>.getNextException()</code>, devuelve la cadena de excepciones que se ha producido. De tal manera que podemos navegar sobre ella para ver en detalle de esas excepciones.</li> </ul>"},{"location":"ud10/3conectores/#liberacion-de-recursos","title":"Liberaci\u00f3n de recursos","text":"<p>Danger \ud83d\ude2c</p> <p>Se debe cerrar expl\u00edcitamente <code>Statement</code>, <code>ResultSet</code> y <code>Connection</code> cuando ya no se necesiten, a menos que se declaren con un try-catch-with-resources.</p> <p>Las instancias de <code>Connection</code> y las de <code>Statement</code> almacenan, en memoria, mucha informaci\u00f3n relacionada con las ejecuciones realizadas. Adem\u00e1s, mientras permanecen activas mantienen en el SGBD un conjunto importante de recursos abiertos, destinados a servir de forma eficiente las peticiones de los clientes. El cierre de estos objetos permite liberar recursos tanto del cliente como del servidor.</p> <p>Aunque se haya cerrado la conexi\u00f3n, los objetos <code>Statements</code> que no se hab\u00edan cerrado expresamente permanecen m\u00e1s tiempo en memoria que los objetos cerrados previamente, ya que el garbage collector de Java deber\u00e1 hacer m\u00e1s comprobaciones para asegurar que ya no dispone de dependencias ni internas ni externas y se puede eliminar. Es por ello que se recomienda proceder siempre a cerrarlo manualmente utilizando el m\u00e9todo <code>close()</code>. El cierre de los objetos <code>Statement</code> asegura la liberaci\u00f3n inmediata de los recursos y la anulaci\u00f3n de las dependencias.</p> <p>Si en un mismo m\u00e9todo queremos cerrar un objeto <code>Statement</code> y <code>Connection</code>, lo haremos siguiendo estos pasos:</p> <ol> <li> <p>Cerramos el <code>Statement</code> y</p> </li> <li> <p>la instancia <code>Connection</code>.</p> </li> </ol> <p>Failure \ud83d\ude35\u200d\ud83d\udcab</p> <p>Si lo hici\u00e9ramos al rev\u00e9s, cuando intent\u00e1ramos cerrar el <code>Statement</code> nos saltar\u00eda una excepci\u00f3n de tipo <code>SQLException</code>, ya que el cierre de la conexi\u00f3n lo habr\u00eda dejado inaccesible.</p> <p>Cuando se cierra un objeto <code>Statement</code>, su objeto <code>ResultSet</code> actual, si existe, tambi\u00e9n se cierra. Pero eso no ocurre cuando se cierra la conexi\u00f3n.</p> <pre><code>try (Connection connection = dataSource.getConnection();\nStatement statement = connection.createStatement()) {\n\ntry (ResultSet resultSet = statement.executeQuery(\"SELECT * FROM ....\")) {\n// Do actions.\n}\n}\n</code></pre>"},{"location":"ud10/4transactions/","title":"\u26a1Transacciones","text":"<p>En el \u00e1mbito de las Bases de Datos, una transacci\u00f3n es cualquier conjunto de sentencias SQL que se ejecutan como si de una sola se tratara. La idea principal es poder ejecutar varias sentencias, que est\u00e1n relacionadas de alguna manera, de forma que, si cualquiera de ellas fallara o produjera un error, no se ejecutara ninguna m\u00e1s e incluso se deshicieran todos los cambios que hayan podido efectuar las que ya se hab\u00edan ejecutado dentro de la misma transacci\u00f3n, por eso decimos, que las transacciones se consideran unitarias. Es decir, las operaciones que componen la transacci\u00f3n se deben ejecutar todas o ninguna. Esto ayuda a preservarla integridad de los datos e impide posibles desfases entre clientes y servidor.</p> <p>De entrada, cualquier sentencia SQL se considera una transacci\u00f3n en s\u00ed misma y si se produce un error durante su ejecuci\u00f3n se anular\u00e1n todas las operaciones simples derivadas de la ejecuci\u00f3n de la sentencia.</p> <p>Una transacci\u00f3n tiene dos finales posibles, <code>COMMIT</code> o <code>ROLLBACK</code>. Si se finaliza correctamente y sin problemas se har\u00e1 con <code>COMMIT</code>, con lo que los cambios se realizan en la base de datos, y si por alguna raz\u00f3n hay un fallo, se deshacen los cambios efectuados hasta ese momento, con la ejecuci\u00f3n de <code>ROLLBACK</code>.</p> <p></p> <p>Por defecto, al menos en MySQL, en una conexi\u00f3n trabajamos en modo autocommit con valor true. Eso significa que cada consulta es una transacci\u00f3n en la base de datos, es decir, que los cambios se aplicar\u00e1n en la base de datos una vez que la query se haya ejecutado correctamente.</p> <p>Por tanto, si queremos definir una transacci\u00f3n de varias operaciones, estableceremos el modo autocommit a false con el m\u00e9todo <code>setAutoCommit</code> de la clase <code>Connection</code>.</p> <p>En modo <code>no autocommit</code> las transacciones quedan definidas por las ejecuciones de los m\u00e9todos <code>commit</code> y <code>rollback</code>. Una transacci\u00f3n abarca desde el \u00faltimo commit o rollback hasta el siguiente commit. Los m\u00e9todos <code>commit</code> o <code>rollback</code> forman parte de la clase <code>Connection</code>.</p> <p>En la siguiente porci\u00f3n de c\u00f3digo, se puede ver un ejemplo sencillo de c\u00f3mo se puede utilizar <code>commit</code> y <code>rollback</code>: tras las operaciones se realiza el <code>commit</code>, y si ocurre una excepci\u00f3n, al capturarla realizar\u00edamos el <code>rollback</code>.</p> <pre><code>public static void execute (String [] sqlqueries) throws SQLException {\nboolean autocommit = true;\nString user = \"patricia\";\nString password = \"marti\";\nString url = \"jdbc:mysql://localhost/severo_ad\";\n\ntry (final Connection con = DriverManager.getConnection(url, user, password)) {\ntry (Statement stmt = con.createStatement()) {\nautocommit = con.getAutoCommit();\ncon.setAutoCommit(false);\nfor (String query : sqlqueries) {\nstmt.executeUpdate(query);\n}\ncon.commit();\ncon.setAutoCommit(autocommit);\n} catch (SQLException ex) {\ncon.rollback();\nthrow ex;\n}\n}\n}\n</code></pre>"},{"location":"ud10/6rendimiento/","title":"\ud83e\udde0 Mejora del rendimiento","text":"<p>Otro aspecto importante que mide la calidad de las aplicaciones es la eficiencia con la que se consigue comunicar con el SGBD. Para optimizar la conexi\u00f3n es importante reconocer qu\u00e9 procesos pueden actuar de cuello de botella y bajo qu\u00e9 circunstancias o qu\u00e9 otras agilizan las respuestas de los SGBD.</p> <ol> <li> <p>En primer lugar, analizaremos la petici\u00f3n de conexi\u00f3n a un SGBD porque se trata de un proceso costoso pero inevitable que hay que considerar.</p> </li> <li> <p>En segundo lugar, estudiaremos las sentencias predefinidas (<code>PreparedStatement</code>), porqu\u00e9 su uso facilita la creaci\u00f3n de datos clave e \u00edndices temporales de modo que sea posible anticiparse a la demanda o disponer de los datos de forma mucho m\u00e1s r\u00e1pida.</p> </li> </ol>"},{"location":"ud10/6rendimiento/#ciclo-de-vida-de-una-conexion","title":"\ud83e\ude90 Ciclo de vida de una conexi\u00f3n","text":"<p>El establecimiento de una conexi\u00f3n es un procedimiento bastante lento, tanto en la parte cliente como la parte servidor. En la parte cliente, <code>DriverManager</code> debe descubrir el controlador correcto de entre todos los que tenga que gestionar. La mayor\u00eda de veces las aplicaciones trabajar\u00e1n s\u00f3lo con un \u00fanico controlador, pero hay que tener en cuenta que <code>DriverManager</code> no conoce a priori qu\u00e9 URL de conexi\u00f3n corresponde a cada controlador, y para averiguarlo env\u00eda una petici\u00f3n de conexi\u00f3n a cada controlador que tenga registrado, el controlador que no le devuelve error ser\u00e1 el correcto.</p> <p>En el lado servidor, se crear\u00e1 un contexto espec\u00edfico y se habilitar\u00e1n un conjunto de recursos para cada cliente conectado. Es decir, que durante la petici\u00f3n de conexi\u00f3n del SGBD debe gastar un tiempo considerable antes de no dejar operativa la comunicaci\u00f3n cliente-servidor.</p> <p>Este elevado gasto de tiempo concentrado en el momento de la petici\u00f3n de conexi\u00f3n nos hace plantear si podemos considerar ineficiente abrir y cerrar la conexi\u00f3n cada vez que tengamos que ejecutar una sentencia SQL, como hemos hecho hasta ahora. Desafortunadamente no hay una \u00fanica respuesta, sino que depende de la frecuencia de uso de la conexi\u00f3n y el n\u00famero de conexiones contra un mismo SGBD coexistiendo al mismo tiempo.</p> <p></p> <p>Como en todo, se trata de encontrar el punto de equilibrio entre la cantidad de recursos empleados por conexi\u00f3n y la rentabilidad que se saca en mantenerlas abiertas. </p> <ul> <li> <p>Si el n\u00famero de clientes, y por tanto de conexiones, es bajo y la frecuencia de uso es alta, ser\u00e1 preferible mantener las conexiones abiertas mucho tiempo. </p> </li> <li> <p>Por el contrario, si el n\u00famero de conexiones es muy alto y el uso infrecuente, lo que ser\u00e1 preferible ser\u00e1 abrir y cerrar la conexi\u00f3n cada vez que se necesite. </p> </li> </ul> <p>Mientras tanto, habr\u00e1 una multitud de casos en que la soluci\u00f3n consistir\u00e1 en mantener las conexiones abiertas, pero no permanentemente. Se puede dar un tiempo de vida a cada conexi\u00f3n, o bien cerrarlas despu\u00e9s de restar inactiva una cantidad determinada de tiempo, o se puede usar el criterio de mantener un n\u00famero m\u00e1ximo de conexiones abiertas, cerrando las m\u00e1s antiguas o las m\u00e1s inactivas cuando se sobrepase el l\u00edmite.</p> <p>\ud83d\ude36\u200d\ud83c\udf2b\ufe0f Nota</p> <p>Por otra parte, hay que tener en cuenta tambi\u00e9n que una misma aplicaci\u00f3n puede trabajar con varias conexiones simult\u00e1neamente para incrementar la eficiencia. Cada conexi\u00f3n abre un hilo de ejecuci\u00f3n independiente, por lo que es posible el env\u00edo simult\u00e1neo de peticiones.</p>"},{"location":"ud10/6rendimiento/#sentencias-predefinidas","title":"\u26a1 Sentencias predefinidas","text":"<p><code>PreparedStatement</code> presenta ventajas sobre su antecesor <code>Statement</code> cuando tengamos que trabajar con sentencias que haya que ejecutar varias veces. </p> \u2b50Statement\u2b50 \u2b50PreparedStatement\u2b50 Statement is usually parsed and executed each time. PreparedStatement is parsed once and executed with different parameters repeatedly. A statement is a static Sql statement.It does not support parameters. A PreparedStatement is a dynamic Sql statement.It does supports parameters. It is slower because every time the statements get parsed and executed. This is faster because this is precompiled once and gets executed with different parameters. Statement verifies metadata against database everytime. PreparedStatement verifies metadata against database only once. If we want to execute sql statement once it is recommended to use statement. If we want to execute sql statements repeatedly it is recommended to use PreparedStatement. <p>La raz\u00f3n es que cualquier sentencia SQL, cuando se env\u00eda el SGBD ser\u00e1 compilada antes de ser ejecutada. Usando un objeto <code>Statement</code>, cada vez que hacemos una ejecuci\u00f3n de una sentencia, ya sea v\u00eda executeUpdate o bien v\u00eda executeQuery, el SGBD la compilar\u00e1, ya que le llegar\u00e1 en forma de cadena de caracteres.</p> <p>En cambio, al <code>PreparedStament</code> la sentencia nunca var\u00eda y por lo tanto se puede compilar y almacenar dentro del mismo objeto, por lo que las siguientes veces que se ejecute no habr\u00e1 que compilarla. Esto reducir\u00e1 sensiblemente el tiempo de ejecuci\u00f3n. La parametrizaci\u00f3n, adem\u00e1s, ayuda a crear sentencias muy gen\u00e9ricas que se puedan reutilizar f\u00e1cilmente.</p> <p>En algunos sistemas gestores, adem\u00e1s, usar <code>PreparedStatement</code> puede llegar a suponer m\u00e1s ventajas, ya que utilizan la secuencia de bytes de la sentencia para detectar si se trata de una sentencia nueva o ya se ha servido con anterioridad. De esta manera se propicia que el sistema almacene las respuestas en la cach\u00e9, de manera que se puedan entregar de forma m\u00e1s r\u00e1pida.</p> <p>Important \ud83e\udd14</p> <p>The use of a <code>Statement</code> in JDBC should be 100% localized to being used for DDL (ALTER, CREATE, GRANT, etc) as these are the only statement types that cannot accept BIND VARIABLES. <code>PreparedStatements</code> or <code>CallableStatements</code> should be used for EVERY OTHER type of statement (DML, Queries). As these are the statement types that accept bind variables.</p> <p>This is a fact, a rule, a law -- use prepared statements EVERYWHERE. Use STATEMENTS almost no where.</p>"},{"location":"ud10/6rendimiento/#ejemplos-de-problemas-con-statement","title":"\ud83d\udcdd Ejemplos de problemas con Statement","text":"<ul> <li>[x] 1. <code>Statement</code> acepta cadenas como consultas SQL. Por lo tanto, el c\u00f3digo se vuelve menos legible cuando concatenamos cadenas SQL:</li> </ul> <pre><code>public void insert(PersonEntity personEntity) {\nString query = \"INSERT INTO persons(id, name, age, email) VALUES(\" + personEntity.getId() + \", '\" + personEntity.getName() + \", '\" + personEntity.getAge() + \", '\" + personEntity.getEmail() + \"')\";\n\nStatement statement = connection.createStatement();\nstatement.executeUpdate(query);\n}\n</code></pre> <ul> <li>[x] 2. Es vulnerable a la inyecci\u00f3n de SQL. </li> </ul> <pre><code>public void check(String name) {\nString query = \"SELECT * FROM users WHERE name = '\" + name + \"';\";\n\nStatement statement = connection.createStatement();\nstatement.executeUpdate(query);\n}\n</code></pre> <p>Si un usuario malintencionado escribe como nombre de usuario a consultar: </p> <p><code>Alicia'; DROP TABLE usuarios; SELECT * FROM datos WHERE nombre LIKE '%</code></p> <p>Se generar\u00eda la siguiente consulta SQL, (el color verde es lo que pretende el programador, el azul es el dato, y el rojo, el c\u00f3digo SQL inyectado):</p> <p></p> <p>En la base de datos se ejecutar\u00eda la consulta en el orden dado, se seleccionar\u00edan todos los registros con el nombre 'Alicia', se borrar\u00eda la tabla 'usuarios' y finalmente se seleccionar\u00eda toda la tabla \"datos\", que no deber\u00eda estar disponible para los usuarios web comunes.'</p>"},{"location":"ud10/7projectstructure/","title":"\ud83e\udded Estructura de un proyecto con JDBC","text":"<p>Para las tareas de clase vamos a seguir una estructura que iremos perfilando basada en el MVC (modelo - vista - controlador). En el IntelliJ, crearemos un nuevo proyecto con la siguiente distribuci\u00f3n de paquetes:</p> <p></p>"},{"location":"ud10/7projectstructure/#1-creando-la-bbdd","title":"1\ufe0f\u20e3 - Creando la BBDD","text":"<p>Lo primero que tendremos que hacer asegurarnos de que tenemos el servidor de base de datos instalado y la base de datos creada con las tablas que necesitemos para nuestra aplicaci\u00f3n.</p> <p></p> <p>Creamos tambi\u00e9n la tabla login con la que vamos a trabajar en los ejemplos:</p> <pre><code>CREATE TABLE `login` (\n`id` int NOT NULL AUTO_INCREMENT,\n`user_name` varchar(50) NOT NULL,\n`password` varchar(255) NOT NULL,\n`created_at` datetime DEFAULT CURRENT_TIMESTAMP,\nPRIMARY KEY (`id`),\nUNIQUE KEY `user_name` (`user_name`)\n);\n</code></pre>"},{"location":"ud10/7projectstructure/#2-clase-connection","title":"2\ufe0f\u20e3 - Clase <code>Connection</code>","text":"<p>Conectar a la BD es un coste muy grande, ya que es un proceso lento, por lo tanto, implementaremos la clase de conexi\u00f3n a la base de datos utilizando el patr\u00f3n singleton. </p> <p>Esta clase estar\u00e1 ubicada dentro del paquete util.</p> <p>Ejemplo de conexi\u00f3n a la BBDD usando Singleton:</p> DatabaseConnection.java<pre><code>public class DatabaseConnection {\n\nprivate static Connection connection = null;\n\nprivate DatabaseConnection() {}\n\nstatic\n{\nString url = \"jdbc:mysql://localhost/severo\";\nString user = \"patricia\";\nString password = \"marti\";\ntry {\nconnection = DriverManager.getConnection(url, user, password);\n} catch (SQLException e) {\ne.printStackTrace();\n}\n}\n\npublic static Connection getConnection() {\nreturn connection;\n}\n\npublic static void close() throws SQLException {\nconnection.close();\n}\n}\n</code></pre>"},{"location":"ud10/7projectstructure/#3-creando-el-modelo","title":"3\ufe0f\u20e3 - Creando el modelo","text":"<p>El modelo contiene una representaci\u00f3n de los datos que maneja la aplicaci\u00f3n y su l\u00f3gica de negocio.</p> <p>Para el ejemplo, el modelo de <code>Login</code> debe contener los atributos que contiene la tabla login como variables de la clase Normalmente los modelos de la clase se encuentran en un paquete llamado model.</p> Login.java<pre><code>public class Login {\n\nprivate int id;\nprivate String username;\nprivate String password;\nprivate LocalDateTime createdAt;\n\n//constructors\n\n//getters y setters\n\n@Override\npublic String toString() {\nreturn \"Login{\" +\n\"id=\" + id +\n\", username='\" + username + '\\'' +\n\", password='\" + password + '\\'' +\n\", createdAt=\" + createdAt +\n'}';\n}\n}\n</code></pre>"},{"location":"ud10/7projectstructure/#4-clases-para-la-manipulacion-de-la-base-de-datos","title":"4\ufe0f\u20e3 - Clases para la manipulaci\u00f3n de la base de datos","text":"<p>Dentro del paquete mysql a\u00f1adiremos clases que ser\u00e1n las encargadas de manipular la informaci\u00f3n contra la base de datos. </p> <p>En el ejemplo tenemos una clase que realiza la manipulaci\u00f3n de la informaci\u00f3n referente a la tabla login.</p> LoginAccessDB.java<pre><code>public class LoginAccessDB {\n\nprivate static Connection con = DatabaseConnection.getConnection();\n\npublic List&lt;Login&gt; getLogins() throws SQLException {\n\nString sql = \"SELECT * FROM login\";\ntry (Statement statement = con.createStatement()) {\nList&lt;Login&gt; lg = new ArrayList&lt;&gt;();\nResultSet resultSet = statement.executeQuery(sql);\n\nwhile (resultSet.next()) {\nLogin login = new Login();\nlogin.setId(resultSet.getInt(1));\nlogin.setUsername(resultSet.getString(\"username\"));\nlogin.setPassword(resultSet.getString(\"password\"));\nlogin.setCreatedAt(resultSet.getTimestamp(\"created_at\").toLocalDateTime());\nlg.add(login);\n}\n\nreturn lg;\n}\n}\n}\n</code></pre> <p>\ud83d\ude36\u200d\ud83c\udf2b\ufe0f Nota</p> <p>M\u00e1s adelante veremos que hay clases que siguen el patr\u00f3n DAO que se encargan del acceso a base de datos.</p>"},{"location":"ud10/7projectstructure/#5-test","title":"5\ufe0f\u20e3 - Test","text":"<p>Por \u00faltimo comprobamos que todo funciona correctamente haciendo una peque\u00f1a prueba en nuestro <code>main</code> o punto de entrada al programa.</p> MainApp.java<pre><code>public class MainApp {\n\npublic static void main(String[] args) {\nLoginAccessDB loginHandleDB = new LoginAccessDB();\ntry {\nfor (Login l: loginHandleDB.getLogins()) {\nSystem.out.println(l);\n}\n} catch (SQLException ex) {\nSystem.out.println(\"SQLException: \" + ex.getMessage());\nSystem.out.println(\"SQLState: \" + ex.getSQLState());\nSystem.out.println(\"VendorError: \" + ex.getErrorCode());\n}\n}\n}\n</code></pre>"},{"location":"ud10/7projectstructure/#6-fichero-readme","title":"6\ufe0f\u20e3 - Fichero README","text":"<p>Readme: el propio nombre, l\u00e9eme, indica su prop\u00f3sito: ser le\u00eddo. El archivo readme es el primer archivo que un desarrollador debe mirar antes de embarcarse en un proyecto, por lo que tambi\u00e9n es esencial saber c\u00f3mo escribir un buen archivo readme, para que toda la informaci\u00f3n relevante se presente de forma compacta.</p> <p>Consejo</p> <p>El nombre del archivo se escribe README en may\u00fasculas. De este modo, los sistemas que diferencian entre may\u00fasculas y min\u00fasculas listar\u00e1n el archivo antes que todos los dem\u00e1s archivos que empiezan con min\u00fasculas.</p>"},{"location":"ud10/7projectstructure/#que-suelen-incluir-los-ficheros-readme","title":"\u00bfQu\u00e9 suelen incluir los ficheros README?","text":"<p>Suelen incluir informaci\u00f3n sobre:</p> <ul> <li>Una descripci\u00f3n general del sistema o proyecto.</li> <li>El estado del proyecto, que es particularmente importante si el proyecto est\u00e1 todav\u00eda en desarrollo. En \u00e9l se mencionan los cambios planeados y la direcci\u00f3n de desarrollo del proyecto, y se especifica directamente si un proyecto est\u00e1 terminado.</li> <li>Los requisitos del entorno de desarrollo para la integraci\u00f3n.</li> <li>Una lista de las tecnolog\u00edas utilizadas y, cuando proceda, enlaces con m\u00e1s informaci\u00f3n.</li> <li>Bugs conocidos y posibles correcciones de errores.</li> <li>Secci\u00f3n de preguntas frecuentes con todas las preguntas planteadas hasta la fecha.</li> <li>Informaci\u00f3n sobre derechos de autor y licencias.</li> </ul>"},{"location":"ud10/7projectstructure/#como-escribir-un-fichero-readme","title":"C\u00f3mo escribir un fichero README","text":"<p>El contenido del fichero README debe estar en ingl\u00e9s.</p> <p></p> <p>C\u00f3mo crear un fichero README</p>"},{"location":"ud10/7projectstructure/#exportar-la-bbdd-de-mysql","title":"Exportar la BBDD de MySQL","text":"<p>En MySQL workbench seleccionamos Server --&gt; Data Export</p> <p></p> <p>Selecciono el esquema de BBDD que quiero exportar y hago click en Start export</p> <p></p> <p>Workbench me muestra d\u00f3nde se ha generado el fichero:</p> <p></p>"},{"location":"ud2/11booleanexpressions/","title":"Expresiones booleanas","text":"<p>Las sentencias if del cap\u00edtulo anterior inclu\u00edan preguntas simples de verdadero / falso (expresiones booleanas) como num&lt;10 o jugadores==1. A menudo, las expresiones booleanas simples no son suficientes. Este cap\u00edtulo trata sobre expresiones booleanas m\u00e1s complicadas.</p>"},{"location":"ud2/11booleanexpressions/#_1","title":"&amp;&amp;","text":"<p>El operador AND &amp;&amp; es un operador l\u00f3gico. Un operador l\u00f3gico examina dos valores verdadero / falso y genera un \u00fanico valor verdadero / falso.</p> <p>Por ejemplo cuando necesitas verificar m\u00e1s de una expresi\u00f3n.</p> <pre><code>    if (harina == 100 &amp;&amp; azucar &gt;= 65) {\n\n}\n</code></pre> <p>Cada parte es una expresi\u00f3n relacional. Una expresi\u00f3n relacional es un tipo de expresi\u00f3n booleana que usa un operador relacional para calcular un valor verdadero o falso.</p> <p>Las expresiones se eval\u00faan de izquierda a derecha, as\u00ed, tan pronto se detecta el primer false, la expresi\u00f3n entera se convierte en false y no se eval\u00faa el resto de expresiones.</p>"},{"location":"ud2/11booleanexpressions/#_2","title":"||","text":"<p>El operador OR || se usa en una expresi\u00f3n booleana para verificar que haya al menos una verdadera. Si solo un lado es verdadero, toda la expresi\u00f3n es verdadera. Si ambos lados son falsos, toda la expresi\u00f3n es falsa.</p> <pre><code>    if (ahorrosMensuales &gt; 1000 || pr\u00e9stamo == 3000) {\n\n}\n</code></pre>"},{"location":"ud2/11booleanexpressions/#_3","title":"!","text":"<p>El operador NOT ! cambia de verdadero a falso y de falso a verdadero. Esto puede parecer una tonter\u00eda, pero a menudo es \u00fatil. A veces es m\u00e1s natural expresar una condici\u00f3n de una manera particular, pero la l\u00f3gica del programa requiere lo contrario de lo que ha escrito.</p> <pre><code>    if (!(precio &lt; 35)) {\n\n}\n</code></pre>"},{"location":"ud2/1seleccion/","title":"Sentencia IF","text":"<p>Este apartado analiza c\u00f3mo los programas del ordenador toman decisiones utilizando la sentencia if. Esta sentencia es uno de los bloques de construcci\u00f3n fundamentales de la programaci\u00f3n.</p> <p>Veamos c\u00f3mo funciona.</p> <p>Los limpiaparabrisas se controlan con un interruptor de encendido y apagado. El diagrama de flujo de la derecha muestra c\u00f3mo se toma esta decisi\u00f3n.</p> <p>Comience en la parte superior del gr\u00e1fico y luego siga la l\u00ednea hasta la pregunta:</p> <p>\u00bfesta lloviendo? La respuesta es verdadera o falsa.</p> <p></p> <p>Si la respuesta es verdadera,</p> <ul> <li>siga la l\u00ednea etiquetada como Verdadero,</li> <li>siga las instrucciones en el cuadro \"Activo limpiaparabrisas ,</li> <li>siga la l\u00ednea para \"Continuar\".</li> </ul> <p>Si la respuesta es falsa,</p> <ul> <li>siga la l\u00ednea etiquetada como Falso,</li> <li>siga las instrucciones en el cuadro \"limpiaparabrisas desactivados\",</li> <li>siga la l\u00ednea para \"Continuar\".</li> </ul> Ejemplo del programa en c\u00f3digo <pre><code>public static void main(String[] args) {\n    Scanner scan = new Scanner( System.in );\n    String respuesta;\n    System.out.print(\"\u00bfEst\u00e1 lloviendo? (Y or N): \");\n    respuesta = scan.nextLine();\n\n    if (respuesta.equals(\"Y\")) {\n        System.out.println(\"Activa limpiaparabrisas\");\n    } else {\n        System.out.println(\"Desactiva limpiaparabrisas\");\n    }\n}\n</code></pre>"},{"location":"ud2/1seleccion/#sentencia-simple-condicional-if","title":"Sentencia simple condicional if","text":"<p>La declaraci\u00f3n if es la m\u00e1s b\u00e1sica de todas las declaraciones de flujo de control. Le dice a su programa que ejecute una determinada secci\u00f3n de c\u00f3digo solo si una prueba en particular se eval\u00faa como verdadera. La sentencia simple condicional if tiene la siguiente estructura:</p> <pre><code>    if (*condici\u00f3n*) {\n//sentencias\n}\n</code></pre> <p></p> <p>Condicion es una expresi\u00f3n booleana. Recuerde que una expresi\u00f3n es una combinaci\u00f3n de literales, operadores, nombres de variables y par\u00e9ntesis que se utilizan para calcular un valor, o incluso una llamada a un m\u00e9todo.</p> <p>Una expresi\u00f3n booleana es una expresi\u00f3n que se eval\u00faa como verdadera o falsa.</p> <p>Dada esta descripci\u00f3n de la sintaxis de la sentencia if, los siguientes son ejemplos de sentencias if v\u00e1lidas:</p> <pre><code>    if (true) {\nSystem.out.println(\"expresi\u00f3n if\");\n}\n\nint num = 6;\nif (num &gt; 0) {\nSystem.out.println(\"El n\u00famero es positivo.\");\n}\n</code></pre>"},{"location":"ud2/1seleccion/#sentencia-condicional-compuesta-if-else","title":"Sentencia condicional compuesta if-else","text":"<p>Una segunda versi\u00f3n de la sentencia if incorpora una cl\u00e1usula else en la estructura. Esto nos permite ejecutar cualquiera de dos declaraciones separadas (simple o compuesta) como resultado de un booleano expresi\u00f3n.</p> <pre><code>    if (*condici\u00f3n*) {\n//sentencias 1\n} else {\n//sentencias 2\n}\n</code></pre> <p></p> <p>Ejemplo:</p> <pre><code>    int numJugadores = 2;\n\nif (numJugadores == 1) {\nSystem.out.println(\"Single player\");\n} else {\nSystem.out.println(\"Multiplayer\");\n}\n</code></pre>"},{"location":"ud2/1seleccion/#sentencia-condicional-if-else-multiple","title":"Sentencia condicional if-else m\u00faltiple","text":"<p>Lo que se ejecuta dentro de los if or else, es decir las sentencias pueden ser a su vez sentencias if-else. En otras palabras, es posible incrustar una o m\u00e1s sentencias if-else dentro de otra sentencia if-else, creando as\u00ed una estructura de control anidada. Como ocurre con la mayor\u00eda de las cosas, hacer una estructura de control demasiado compleja no es una buena idea, pero existe una estructura de control est\u00e1ndar anidada ifelse que es muy \u00fatil. Se conoce como selecci\u00f3n de m\u00faltiples v\u00edas.</p> <pre><code>    if (*condici\u00f3n*) {\n//sentencias 1\n} else if (*condici\u00f3n*) {\n//sentencias 2\n} else if (*condici\u00f3n*) {\n...\n} else {\n//sentencias\n}\n</code></pre> <p></p> <p>Ejemplo:</p> <pre><code>    if (numJugadores == 1) {\nSystem.out.println(\"Single player\");\n} else if (numJugadores == 2) {\nSystem.out.println(\"Two player\");\n} else if (numJugadores == 3) {\nSystem.out.println(\"Multiplayer\");\n} else {\nSystem.out.println(\"Not possible, too many players\");\n}\n</code></pre>"},{"location":"ud2/22dowhile/","title":"Sentencia DO-WHILE","text":"<p>El bucle do-while es una variante del bucle while que proporciona el lenguaje de programaci\u00f3n Java. Se puede expresar de la siguiente forma:</p> <pre><code>    //inicializadores\ndo {\n//bloque de c\u00f3digo: sentencia(s)\n//actualizador\n} while (condici\u00f3n);\n</code></pre> <p></p> <p>La diferencia entre do-while y while es que do-while eval\u00faa la condici\u00f3n despu\u00e9s de ejecutar el cuerpo del bucle. Por lo tanto, las sentencias dentro del bloque do-while se ejecutan al menos una vez.</p> <p>Una estructura while correctamente dise\u00f1ada debe incluir 3 partes:</p> <ul> <li>un inicializador,</li> <li>una condici\u00f3n de bucle y</li> <li>un actualizador. El actualizador debe garantizar que la condici\u00f3n de entrada del bucle finalmente falle, permitiendo as\u00ed que el bucle termine.</li> </ul>"},{"location":"ud2/22dowhile/#ejemplo-muestra-los-numeros-del-0-al-4","title":"Ejemplo: Muestra los n\u00fameros del 0 al 4","text":"<pre><code>    int i = 0;\n\ndo {\nSystem.out.println(i);\ni++;\n} while (i &lt; 5);\n</code></pre> <p>Salida</p> <pre><code>    0\n    1\n    2\n    3\n    4\n</code></pre> <p>Traza</p> Iteraci\u00f3n Variable i &lt; 5 Acci\u00f3n i = 0 no se verifica imprime 0, incrementa i=1 1a i = 1 true imprime 1, i = 2 2a i = 2 true imprime 2, i = 3 3a i = 3 true imprime 3, i = 4 4a i = 4 true imprime 4, i = 5 5a i = 5 false termina"},{"location":"ud2/22dowhile/#ejemplo-sumar-los-numeros-del-0-al-10","title":"Ejemplo: Sumar los n\u00fameros del 0 al 10","text":"<pre><code>    int i = 0; //inicializador\nint suma = 0;\n\ndo {\nsuma = suma + i;\ni++;//actualizador\n} while (i &lt;= 10);\n\nSystem.out.println(suma);\n</code></pre> <p>Salida</p> <pre><code>    55\n</code></pre>"},{"location":"ud2/22for/","title":"Sentencia FOR","text":"<p>Un bucle de conteo, o bucle controlado por un contador, es un bucle en el que sabes de antemano cu\u00e1ntas veces se repetir\u00e1. Como por ejemplo el siguiente c\u00f3digo que cuenta hasta 100:</p> <pre><code>    int i = 0;\n\nwhile (i &lt; 100) {\nSystem.out.println(i):\ni++;\n}\n</code></pre> <p>Aunque podemos usar una estructura while como la anterior para codificar un bucle de conteo, Java posee una estructura para \u00e9ste prop\u00f3sito, el bucle for. El bucle for se utiliza cuando el n\u00famero de iteraciones es conocido. Mientras que while y do-while se utiliza generalmente cuando el n\u00famero de iteraciones no se conoce.</p> <pre><code>    for(inicializador; condici\u00f3n; modificador) {\n//cuerpo del bucle\n}\n\n//VARIANTES: Si solo tiene una sentencia en el cuerpo tambi\u00e9n \n//se puede escribir sin llaves\nfor(inicializador; condici\u00f3n; modificador)\n//sentencia;\n\nfor(inicializador; condici\u00f3n; modificador) //sentencia;\n</code></pre> <pre><code>    for(int i = 0; i &lt; 100; i++) {\nSystem.out.println(i);\n}\n</code></pre> <p>Proceso:</p> <ol> <li>Inicializador: inicializa y/o declara variables y se ejecuta solo una vez.</li> <li>Condici\u00f3n: se eval\u00faa la condici\u00f3n. Si la condici\u00f3n es verdadera, se ejecuta el cuerpo del bucle for.</li> <li>Modificador: actualiza el valor de inicializador.</li> <li>La condici\u00f3n se eval\u00faa nuevamente. El proceso contin\u00faa hasta que la condici\u00f3n es falsa.</li> </ol> <p></p>"},{"location":"ud2/22for/#ejemplo-imprime-cualquier-texto-por-pantalla-4-veces","title":"Ejemplo: Imprime cualquier texto por pantalla 4 veces","text":"<pre><code>    for (int i = 1; i &lt;= 4; ++i) {\nSystem.out.println(\"This is a for loop.\");\n}\n</code></pre> <p>Salida</p> <pre><code>    This is a for loop.\n    This is a for loop.\n    This is a for loop.\n    This is a for loop.\n</code></pre> <p>Traza</p> Iteraci\u00f3n Variable i &lt;= 4 Acci\u00f3n 1a i=1 true imprime texto, i=2 2a i=2 true imprime texto, i=3 3a i=3 true imprime texto, i=4 4a i=4 true imprime texto, i=5 5a i=5 false termina <p>La variable de inicializaci\u00f3n en el bucle for, puede ser declarada en otro lugar del c\u00f3digo. Ejemplo:</p> <pre><code>    int i;\n\n//c\u00f3digo\n\nfor (i = 1; i &lt;= 4; ++i) {\nSystem.out.println(\"This is a for loop.\");\n}\n</code></pre> <p>Pero esto, viola la idea de que todas las partes del bucle se combinan en una sola declaraci\u00f3n. Por tanto, estar\u00eda bien si la declaraci\u00f3n de la variable i forma parte de la declaraci\u00f3n for.</p> <p>Una variable declarada en una instrucci\u00f3n for solo se puede usar en esa instrucci\u00f3n y en el cuerpo del bucle.</p>"},{"location":"ud2/22for/#ejemplo-suma-digitos-de-un-numero","title":"Ejemplo suma d\u00edgitos de un n\u00famero","text":"<pre><code>//con un bucle while\npublic static void main(String[] args) {\nint numero = 479; //4+7+9=20\nint suma = 0;\nint digito = 0;\n\nwhile(numero &gt; 0) {\ndigito = numero % 10;//obtengo el \u00faltimo d\u00edgito, menos significativo\nsuma += digito;\nnumero /= 10;//hago el n\u00famero m\u00e1s peque\u00f1o, le quito el \u00faltimo d\u00edgito\n}\nSystem.out.println(suma);\n}\n\n//con un bucle for\npublic static void main(String[] args) {\nint suma = 0;\nint digito = 0;\nfor (int numero = 479; numero &gt; 0; numero/=10) {\ndigito = numero % 10;\nsuma+=digito;\n}\nSystem.out.println(suma);\n}\n</code></pre> <p>Note</p> <p>Si creo un bucle de la siguiente forma <code>for(int i = 0; i &lt; 10; i++);</code> ese bucle no har\u00e1 nada, porque acaba en <code>;</code>. Con el <code>;</code> estamos indicando fin de statement o sentencia, es decir, fin de bucle, cualquier l\u00ednea detr\u00e1s del ; no ser\u00e1 parte del bucle. Esto no solo se aplica para el bucle <code>for</code>, tambi\u00e9n para la sentencia <code>if</code> o <code>while</code>.</p>"},{"location":"ud2/22for/#bucle-infinito","title":"Bucle infinito","text":"<p>Un l\u00edmite de bucle es un valor que controla cu\u00e1ntas veces se repite un bucle. Un bucle se repetir\u00e1 hasta que se alcance su l\u00edmite de bucle. La condici\u00f3n del bucle debe ser una expresi\u00f3n booleana que pruebe si se ha alcanzado el l\u00edmite del bucle. De manera similar, el actualizador debe modificar el contador del bucle para que avance hacia su l\u00edmite.</p> <p>Si nunca se alcanza el l\u00edmite del bucle, la condici\u00f3n del bucle nunca se volver\u00e1 falsa y el bucle se repetir\u00e1 para siempre. Esto se conoce como bucle infinito.</p> <p>Para salir de un programa con bucle infinito presiona CONTROL+C.</p>"},{"location":"ud2/22for/#bucle-for-each","title":"Bucle for-each","text":"<p>Lo veremos m\u00e1s adelante, cuando veamos los arrays y colecciones.</p>"},{"location":"ud2/22nestedloop/","title":"Bucles anidados","text":"<p>Un bucle anidado es una estructura en la que un bucle est\u00e1 contenido dentro del cuerpo de otro bucle.</p> <p>Por ejemplo, imagina que quieres imprimir algo como la siguiente tabla de n\u00fameros, donde en la fila y columnas superiores aparecen las posiciones y dentro de las filas tenemos fila x columna.</p> <p></p> <p>Para producir esta tabla de multiplicar, podr\u00edamos usar los siguientes bucles for anidados:</p> <pre><code>1    for (int fila = 1; fila &lt;= 4; fila++) { //para cada una de las 4 filas\n2        for (int col = 1; col &lt;= 9; col ++) //para cada una de las 9 columnas\n3            System.out.print(col * fila + \"\\t\"); //muestra la multiplicaci\u00f3n\n4        System.out.println(); //Empieza una nueva fila\n5    }\n</code></pre> <p>Indentamos el c\u00f3digo para hacer que sea m\u00e1s legible. En este ejemplo, el bucle externo controla el n\u00famero de filas en la tabla, es decir, nuestra elecci\u00f3n de fila como su contador de bucle.</p> <p>La instrucci\u00f3n println() (l\u00ednea 4) se ejecuta despu\u00e9s de que el bucle interno haya terminado de iterar, lo que nos permite imprimir una nueva fila en cada iteraci\u00f3n del bucle externo.</p> <p>El bucle interno imprime los nueve valores en cada fila imprimiendo la expresi\u00f3n col * fila. Obviamente, el valor de esta expresi\u00f3n depende de ambas variables de bucle.</p> <p>Analicemos un poco el ejemplo anterior:</p> <ol> <li>\u00bfCu\u00e1ntas veces se ejecuta la instrucci\u00f3n for en la l\u00ednea 2? El bucle interno se ejecuta una vez por cada iteraci\u00f3n del bucle externo. Por lo tanto, se ejecuta cuatro veces, que es el mismo n\u00famero de veces que se ejecuta la l\u00ednea 4.</li> <li>\u00bfCu\u00e1ntas veces se ejecuta la declaraci\u00f3n de la l\u00ednea 3? El cuerpo del bucle interno se ejecuta 36 veces, 9 veces por cada ejecuci\u00f3n de la l\u00ednea 2.</li> </ol>"},{"location":"ud2/22nestedloop/#patrones-de-for-anidado","title":"Patrones de FOR anidado","text":"<p>A veces es \u00fatil usar la variable del bucle externo como l\u00edmite para el bucle interno. Por ejemplo, veamos el siguiente patr\u00f3n:</p> <p></p> <p>El n\u00famero de s\u00edmbolos # en cada fila var\u00eda inversamente con el n\u00famero de fila. En la fila 1, tenemos cinco s\u00edmbolos; en la fila 2 tenemos cuatro; y as\u00ed sucesivamente hasta la fila 5, donde tenemos un #.</p> <p>Para producir este tipo de patr\u00f3n bidimensional, necesitamos dos contadores:</p> <ul> <li>uno para contar el n\u00famero de fila y</li> <li>otro para contar el n\u00famero de s\u00edmbolos # en cada fila.</li> </ul> <p>Debido a que tenemos que imprimir los s\u00edmbolos de cada fila antes de pasar a la siguiente fila, el ciclo externo contar\u00e1 los n\u00fameros de fila y el ciclo interno contar\u00e1 los s\u00edmbolos en cada fila.</p> <p>La siguiente tabla muestra la relaci\u00f3n que queremos:</p> Fila L\u00edmite (6-i) N\u00fam. s\u00edmbolos 1 6-1 5 2 6-2 4 3 6-3 3 4 6-4 2 5 6-5 1 <p>Si dejamos que j sea el contador del bucle interno, entonces j estar\u00e1 limitado por la expresi\u00f3n 6 - i. Esto conduce a la siguiente estructura de bucle anidado:</p> <pre><code>    for (int i = 1; i &lt;= 5 ; i++) {\nfor (int j = 1; j &lt;= (6 - i); j++) {\nSystem.out.print('#');\n}\nSystem.out.println();\n}\n</code></pre> <p>Otra soluci\u00f3n si no queremos usar un literal en la condici\u00f3n del bucle interno ser\u00eda:</p> <pre><code>    for (int i = 1; i &lt;= 5 ; i++) {\nfor (int j = 5; j &gt;= i; j--) {\nSystem.out.print('#');\n}\nSystem.out.println();\n}\n</code></pre> <p>A menudo los literales que aparecen como l\u00edmites en los bucles for se denominan n\u00fameros m\u00e1gicos y pueden crear problemas de redundancia en el c\u00f3digo o c\u00f3digo no legible. Para solucionar esto utilizamos constantes:</p> <pre><code>    final int MAX_WIDTH = 5;\n\nfor (int i = 1; i &lt;= MAX_WIDTH ; i++) {\nfor (int j = MAX_WIDTH; j &gt;= i; j--) {\nSystem.out.print('#');\n}\nSystem.out.println();\n}\n</code></pre>"},{"location":"ud2/22principlesloop/","title":"Principios del dise\u00f1o de bucles","text":"<ul> <li>Un bucle de conteo se utiliza siempre que se sepa de antemano exactamente cu\u00e1ntas iteraciones se necesitan. La instrucci\u00f3n for de Java es una estructura apropiada para codificar un bucle de conteo.</li> <li>Se debe usar una estructura while cuando el problema sugiera que el cuerpo del bucle puede omitirse por completo.</li> <li>Una estructura do-while debe usarse solo cuando un bucle requiere al menos una o m\u00e1s iteraciones.</li> <li>La variable de bucle se utiliza para especificar la condici\u00f3n de entrada de bucle. Debe inicializarse a un valor inicial apropiado y debe actualizarse en cada iteraci\u00f3n del bucle.</li> <li>El l\u00edmite de un bucle puede ser un recuento, un centinela o, de manera m\u00e1s general, un l\u00edmite condicional. Debe estar correctamente especificado en la expresi\u00f3n de entrada de bucle y el progreso hacia el l\u00edmite debe realizarse en el actualizador.</li> <li>Puede producirse un bucle infinito si el inicializador, la expresi\u00f3n de entrada de bucle o la expresi\u00f3n del actualizador no se especifican correctamente.</li> </ul>"},{"location":"ud2/22while/","title":"Sentencia WHILE","text":"<p>Una estructura de repetici\u00f3n es una estructura de control que repite una declaraci\u00f3n o secuencia de declaraciones de forma controlada. Las estructuras de repetici\u00f3n tambi\u00e9n se denominan estructuras de bucle. Muchos tipos de tareas de programaci\u00f3n requieren una estructura de repetici\u00f3n. Por ejemplo:</p> <ul> <li>Sumar los cuadrados de los n\u00fameros del 1 al 100.</li> <li>Un empleado de seguridad inform\u00e1tica quiere probar todas las contrase\u00f1as posibles para entrar en la cuenta de un presunto esp\u00eda.</li> <li>Quieres que los jugadores inserten movimientos durante un turno en un juego hasta que el juego ha terminado.</li> </ul> <p></p> <p>La instrucci\u00f3n while es una instrucci\u00f3n de bucle en la que la condici\u00f3n de bucle ocurre antes que el cuerpo del bucle. Tiene la siguiente estructura:</p> <pre><code>    while (condici\u00f3n) {\n//cuerpo del bucle\n//bloque de c\u00f3digo: sentencia(s)\n}\n\n//VARIANTES: Si solo tiene una sentencia en el cuerpo \n//tambi\u00e9n se puede escribir as\u00ed\nwhile (condici\u00f3n)\n//sentencia;\n</code></pre> <p>Contiene la palabra reservada while seguida de un bloque de c\u00f3digo. Un bloque es un conjunto de sentencias encerradas entre corchetes { y }.</p> <p>Cuando se ejecuta la instrucci\u00f3n while, se eval\u00faa la condici\u00f3n del bucle, que es una expresi\u00f3n booleana y sucede alguno de los siguientes escenarios:</p> <ol> <li>Si esto se eval\u00faa como falso, la ejecuci\u00f3n contin\u00faa en la instrucci\u00f3n inmediatamente despu\u00e9s del cuerpo del bucle(fuera del bloque).</li> <li>Si la condici\u00f3n de bucle se eval\u00faa como verdadero, el cuerpo del bucle se ejecuta y luego la condici\u00f3n se eval\u00faa nuevamente y se repite el proceso.</li> </ol> <p>El cuerpo del bucle contin\u00faa ejecut\u00e1ndose hasta que la condici\u00f3n se eval\u00faa como falsa.</p> <p>Para que una declaraci\u00f3n while realice una tarea, la variable o variables en la condici\u00f3n de entrada de bucle deben inicializarse correctamente antes; y adem\u00e1s estas variables deben actualizarse correctamente al final del cuerpo de bucle. Podemos reformular las pautas anteriores como un principio de dise\u00f1o:</p> <p>Una estructura while correctamente dise\u00f1ada debe incluir 3 partes:</p> <ul> <li>un inicializador,</li> <li>una condici\u00f3n de bucle y</li> <li>un actualizador. El actualizador debe garantizar que la condici\u00f3n de entrada del bucle finalmente falle, permitiendo as\u00ed que el bucle termine.</li> </ul> <pre><code>    //inicializadores\nwhile ( condici\u00f3n ) {\n//sentencias\n//actualizador\n}\n</code></pre>"},{"location":"ud2/22while/#ejemplo-mostrar-los-3-primeros-numeros","title":"Ejemplo: Mostrar los 3 primeros n\u00fameros","text":"<pre><code>    int i = 1; //inicializador\n\nwhile (i &lt;= 3) {\nSystem.out.println(i);//Sentencia\ni = i + 1;//actualizador\n}\n</code></pre> <p>Salida</p> <pre><code>    1\n    2\n    3\n</code></pre> <p>Traza</p> Iteraci\u00f3n Variable i &lt;= 3 Acci\u00f3n 1a i = 1 true imprime 1, incrementa i=2 2a i = 2 true imprime 2, incrementa i = 3 3a i = 3 true imprime 3, incrementa i = 4 4a i = 4 false termina el bucle"},{"location":"ud2/22while/#ejemplo-sumar-los-numeros-del-0-al-10","title":"Ejemplo: Sumar los n\u00fameros del 0 al 10","text":"<pre><code>    int i = 0; //inicializador\nint suma = 0;\n\nwhile (i &lt;= 10) {\nsuma = suma + i;\ni++;//actualizador\n}\n\nSystem.out.println(suma);\n</code></pre> <p>Salida</p> <pre><code>    55\n</code></pre> <p>Traza</p> Iteraci\u00f3n Variable i &lt;= 10 Acci\u00f3n 1a suma=0, i=0 true suma=0, incrementa i(1) 2a suma=0, i=1 true suma=1, incrementa i(2) 3a suma=1, i=2 true suma=3, incrementa i(3) 4a suma=3, i=3 true suma=6, incrementa i(4) 5a suma=6, i=4 true suma=10, incrementa i(5) .. .. .. .. 12a suma=55, i=11 false termina"},{"location":"ud2/22whileif/","title":"Bucles WHILE con sentencias IF","text":"<p>Este cap\u00edtulo muestra c\u00f3mo los bucles while y las instrucciones if se usan juntas para implementar la l\u00f3gica de un programa.</p> <p>El siguiente c\u00f3digo muestra un esqueleto de un programa que suma todos los n\u00fameros enteros hasta un l\u00edmite y suma tambi\u00e9n los que son n\u00fameros pares.</p> <p></p>"},{"location":"ud2/22whileif/#step-1","title":"STEP 1","text":"<p>Primero, inicializamos la variable count. El bucle debe contar desde uno hasta el l\u00edmite(incluido). En este programa, la mayor parte de la l\u00f3gica est\u00e1 contenida dentro del cuerpo del bucle.</p> <p></p> <p>Comprobamos que el programa se puede compilar y ejecutar. Si no fuera as\u00ed, corrige los errores de sintaxis (si los hay) y busca qu\u00e9 errores tienes. Inserta algunas sentencias println temporales para ayudarte en la b\u00fasqueda de errores. (O usa un depurador).</p> <p>Tip</p> <p>Es mejor escribir un programa por etapas. Escriba y depura cada etapa antes de construir sobre el. En un programa con un bucle principal, la primera etapa es construir el bucle.</p>"},{"location":"ud2/22whileif/#step-2","title":"STEP 2","text":"<p>El bucle de momento solo cuenta n\u00fameros hasta un l\u00edmite, pero todav\u00eda no hace nada con ellos. Esto es lo que queremos que suceda:</p> <ul> <li>Sumar cada entero y asignarlo a sumaTotal.</li> <li>Sumar cada entero par y asginarlo a sumaPar.</li> </ul> <p>\u00bfC\u00f3mo decidimos cuando agregar un n\u00famero entero a sumaPar? Para ello necesitaremos la sentencia if.</p> <p>El cuerpo del bucle en este programa contiene una instrucci\u00f3n if. Una instrucci\u00f3n if dentro de un cuerpo de bucle se denomina if anidado. No tiene nada de especial funciona igual que fuera del cuerpo del bucle.</p> <p></p> <p>\u00bfC\u00f3mo calculamos los n\u00fameros que son pares? Los n\u00fameros pares son aquellos que son divisibles por 2. Podemos hacerlo usando el operador %. Si el resto al dividir entre 2 da 0, entonces obtenemos un n\u00famero par.</p> <p></p>"},{"location":"ud2/23breakcontinue/","title":"Break y continue","text":"<p>Las sentencias break y continue son las sentencias de salto que se utilizan para omitir algunas sentencias dentro del bucle o terminar el bucle inmediatamente sin comprobar la condici\u00f3n. Estas instrucciones se pueden usar dentro de cualquier bucle, como for, while, do-while.</p>"},{"location":"ud2/23breakcontinue/#break","title":"BREAK","text":"<p>Ya se ha visto la instrucci\u00f3n break utilizada en un cap\u00edtulo anterior de este tutorial. En concreto en la estructura switch.</p> <p>La sentencia break en java se usa para terminar el bucle inmediatamente.</p> <p>Cuando se encuentra una sentencia break dentro de un bucle, la iteraci\u00f3n del bucle se detiene ah\u00ed y el control vuelve a la primera sentencia despu\u00e9s del bucle, es decir, la primera sentencia que se encuentra al salir del bucle.</p> <p>B\u00e1sicamente, las instrucciones break se utilizan en situaciones en las que no estamos seguros del n\u00famero real de iteraciones del bucle o queremos terminar el bucle en funci\u00f3n de alguna condici\u00f3n.</p> <pre><code>    for (int i = 0; i &lt; 10; i++) {\nif (i == 3)\nbreak;\nSystem.out.print(i + \" \");\n}\n\nSystem.out.println(\"Fuera del bucle for\");\n</code></pre> <pre><code>Output: 0 1 2\nFuera del bucle for\n</code></pre> <p>Note</p> <p>En el caso de bucles anidados, la instrucci\u00f3n break termina el bucle m\u00e1s interno.</p>"},{"location":"ud2/23breakcontinue/#break-etiquetado","title":"Break etiquetado","text":"<p>Hasta ahora, hemos utilizado la sentencia break sin etiquetar. Sin embargo, hay otra forma de utilizar break en Java conocido como break etiquetado (labeled break).</p> <p></p> <p>En la imagen se ha utilizado un break etiquetado con el identificador label para especificar el bucle exterior. Observa c\u00f3mo se usa la declaraci\u00f3n break con etiqueta.</p> <p>La sentencia break est\u00e1 terminando la sentencia etiquetada (es decir, el bucle externo). Luego, el control del programa salta a la sentencia justo despu\u00e9s de la etiquetada.</p> <p>De esta forma, podr\u00edamos utilizar la sentencia break etiquetada para terminar el bucle m\u00e1s externo como se ve en el siguiente ejemplo:</p> <pre><code>    public static void main(String[] args) {\n\n//el primer bucle es etiquetado como primero\nprimero:\nfor( int i = 1; i &lt; 5; i++) {\n\n// el segundo bucle como segundo\nsegundo:\nfor(int j = 1; j &lt;= 2; j ++ ) {\nSystem.out.println(\"i = \" + i + \"; j = \" +j);\n\n// se realiza un break del primer bucle\nif ( i == 2)\nbreak primero;\n}\n}\n}\n</code></pre> <pre><code>Output\ni = 1; j = 1\ni = 1; j = 2\ni = 2; j = 1\n</code></pre>"},{"location":"ud2/23breakcontinue/#continue","title":"CONTINUE","text":"<p>La instrucci\u00f3n continue en Java se usa para omitir la iteraci\u00f3n actual de un bucle y continuar con la siguiente iteraci\u00f3n del bucle.</p> <p>Podemos usar la instrucci\u00f3n continue dentro de cualquier tipo de bucle, como el bucle for, while y do-while.</p> <p>B\u00e1sicamente, las sentencias continue se utilizan en situaciones en las que queremos continuar el ciclo pero no queremos la sentencia restante despu\u00e9s de la sentencia continue.</p> <pre><code>    for (int i = 0; i &lt; 5; i++) {\nif (i == 2)\ncontinue;\n\nSystem.out.print(i + \" \");\n}\n</code></pre> <pre><code>Output: 0 1 3 4\n</code></pre>"},{"location":"ud2/24exceptions/","title":"Excepciones","text":""},{"location":"ud2/24exceptions/#jerarquia-de-excepciones-en-java","title":"Jerarqu\u00eda de excepciones en Java","text":"<p>La clase Throwable es la clase base incorporada que se usa para manejar todas las excepciones en Java. El tipo m\u00e1s gen\u00e9rico de excepci\u00f3n, java.lang.Exception, se encuentra en el paquete java.lang, pero la mayor\u00eda de sus subclases est\u00e1n contenidas en otros paquetes. </p> <p>Un programa a menudo encuentra problemas mientras se ejecuta. Puede tener problemas para leer datos, puede haber caracteres ilegales en los datos o un \u00edndice puede salirse de los l\u00edmites. La clase Java que gestiona estos problemas se llama Exception.</p> <p>La entrada y la salida son especialmente propensas a errores. El manejo de excepciones es esencial para la programaci\u00f3n de I/O.</p> <p>Por ejemplo, \u00bfqu\u00e9 ha ido mal en el siguiente programa?:</p> <p></p> <p>Si hacemos un seguimiento a la pila de errores, vemos que el usuario insert\u00f3 \"hola\" y la clase Scanner, en concreto el m\u00e9todo nextInt no pudo convertir ese texto en un n\u00famero, por tanto, se lanz\u00f3 una excepci\u00f3n.</p> <p>Eso no significa que el programa est\u00e9 mal, simplemente el fallo est\u00e1 en los datos. Cuando nextInt encuentra el problema lanza la excepci\u00f3n InputMismatchException. La ejecuci\u00f3n del programa Java detecta la excepci\u00f3n y detiene el programa imprimiendo los mensajes de error.</p> <p>Es muy importante leer bien la pila de errores en la consola cuando se lanza una excepci\u00f3n para encontrar el fallo.</p> <p></p>"},{"location":"ud2/24exceptions/#que-es-un-error","title":"\u00bfQu\u00e9 es un error?","text":"<p>Un error indica que se ha producido un fallo no recuperable, del que no se puede recuperar la ejecuci\u00f3n normal del programa. Un error est\u00e1 representado por un objeto de clase Error.</p> <p>La clase Throwable tiene dos subclases: Exception y Error. Un m\u00e9todo Java puede \"lanzar\" un objeto de clase Throwable. Por ejemplo, Scanner lanz\u00f3 una excepci\u00f3n cuando intent\u00f3 convertir \"hola\" en un n\u00famero entero.</p> <p>Las excepciones son diferentes de los errores porque los programas se pueden escribir para recuperarse de las excepciones, pero los programas no se pueden escribir para recuperarse de los errores.</p>"},{"location":"ud2/24exceptions/#que-es-una-excepcion","title":"\u00bfQu\u00e9 es una excepci\u00f3n?","text":"<p>Una excepci\u00f3n es un problema que ocurre cuando se ejecuta un programa. Cuando ocurre una excepci\u00f3n, la m\u00e1quina virtual Java crea un objeto de clase Exception que contiene informaci\u00f3n sobre el problema. Cuando se lanza una excepci\u00f3n, se puede capturar la excepci\u00f3n para recuperarse del programa.</p>"},{"location":"ud2/24exceptions/#bloques-try-catch","title":"Bloques try -  catch","text":"<p>Para capturar una excepci\u00f3n realizamos los siguientes pasos:</p> <ol> <li>Colocar el c\u00f3digo que pueda lanzar una excepci\u00f3n dentro de un bloque try.</li> <li>Colocar el c\u00f3digo que maneja la excepci\u00f3n dentro de un bloque catch (captura).</li> <li>El bloque catch debe seguir inmediatamente al bloque try.</li> </ol> <p>Cada bloque catch es un manejador de excepciones que maneja el tipo de excepci\u00f3n indicado por su argumento. El tipo de argumento, ExceptionType, declara el tipo de excepci\u00f3n que el controlador puede manejar y debe ser el nombre de una clase que hereda de la clase Throwable.</p> <p>El siguiente ejemplo arroja dentro del bloque try una InputMismatchException, el bloque catch comienza a ejecutarse inmediatamente. Se omiten las sentencias restantes en el bloque try.</p> <pre><code>    Scanner sc = new Scanner(System.in);\nint numero;\n\nSystem.out.println(\"Introduzca un entero:\");\n\ntry {\nnumero = sc.nextInt();\n} catch (InputMismatchException e) {\nSystem.out.println(\"No has introducido un n\u00famero.\");\ne.printStackTrace();\n}\n\nSystem.out.println(\"Sigue ejecut\u00e1ndose el programa\");\n</code></pre> <p>El par\u00e1metro dentro de catch e se refiere al objeto de excepci\u00f3n que se lanza. Si queremos mostrar la pila de errores que genera el error usamos el m\u00e9todo e.printStackTrace();</p> <p>Despu\u00e9s de ejecutar el bloque catch, la ejecuci\u00f3n contin\u00faa con la instrucci\u00f3n que sigue al bloque catch. La ejecuci\u00f3n no vuelve al bloque try.</p>"},{"location":"ud2/24exceptions/#como-se-ejecuta-un-try-catch-paso-por-paso","title":"C\u00f3mo se ejecuta un try-catch paso por paso","text":"<ol> <li>Cuando se lanza una excepci\u00f3n dentro de un bloque try, el controlador de excepciones examina la excepci\u00f3n dentro de los bloques catch.</li> <li>Los bloques catch se examinan uno a uno empezando por el primero.</li> <li>El primer bloque catch que encaja con la excepci\u00f3n obtiene el control. Aunque haya muchas excepciones que encajen solo se ejecuta un bloque catch.</li> <li>Si ning\u00fan bloque catch encaja con la excepci\u00f3n lanzada se muestra la pila de errores y se termina la ejecuci\u00f3n del programa ya que no se ha manejado la excepci\u00f3n.</li> <li>Las clases m\u00e1s especificas deben ir primero seguidas de las m\u00e1s generales.</li> <li>Despu\u00e9s de ejecutar la \u00faltima instrucci\u00f3n dentro del catch el control del programa vuelve a la siguiente l\u00ednea fuera del try-catch (o finally si hubiera).</li> </ol>"},{"location":"ud2/24exceptions/#capturar-mas-de-una-excepcion-en-un-solo-catch","title":"Capturar m\u00e1s de una excepci\u00f3n en un solo catch","text":"<p>En Java SE 7 y posteriores, un solo bloque catch puede manejar m\u00e1s de un tipo de excepci\u00f3n. Esta funci\u00f3n puede reducir la duplicaci\u00f3n de c\u00f3digo.</p> <p>En la cl\u00e1usula catch, se especifican los tipos de excepciones que puede manejar el bloque y se separa cada tipo de excepci\u00f3n con una barra vertical (|):</p> <pre><code>catch (IOException | SQLException ex) {\n//realizar acciones\n}\n</code></pre> <p>Note</p> <p>Si un bloque catch maneja m\u00e1s de un tipo de excepci\u00f3n, el par\u00e1metro catch es impl\u00edcitamente final. En este ejemplo, la variable catch ex es final y, por lo tanto, no puede asignarle ning\u00fan valor dentro del bloque catch.</p>"},{"location":"ud2/24exceptions/#sentencia-throw","title":"Sentencia throw","text":"<p>Utilizando la palabra reservada throw podemos lanzar nosotros expl\u00edcitamente una excepci\u00f3n.</p> <p>Podemos construir una instancia de la excepci\u00f3n que queremos lanzar y a\u00f1adirle un mensaje en el constructor.</p> <p>Ejemplo:</p> <pre><code>    try {\nSystem.out.print(\"Inserta el numerador: \");\nnum = scan.nextInt();\nSystem.out.print(\"Inserta el denominador: \");\ndiv = scan.nextInt();\n\nif ( div == 0 ) throw new ArithmeticException(\"Error al intentar dividir entre cero\");\n\n....\n} catch (ArithmeticException ex) { System.out.println(\"No se puede dividir \" + num + \" entre \" + div);\nSystem.out.println(ex.getMessage());\n} </code></pre>"},{"location":"ud2/24exceptions/#bloque-finally","title":"Bloque finally","text":"<p>El bloque finally siempre se ejecuta cuando sale del bloque try-catch incluso si ocurre una excepci\u00f3n inesperada.</p> <p>Estructura:</p> <pre><code>try {\n//c\u00f3digo\n} catch () {\n//c\u00f3digo\n} finally {\n//siempre se ejecuta\n}\n</code></pre> <p>Solo puede haber un bloque finally, y debe estar despu\u00e9s de los bloques catch.</p> <ul> <li>Si el bloque try sale normalmente (no ocurrieron excepciones), entonces el control va directamente al bloque finally.</li> <li>Si el bloque try sale debido a una excepci\u00f3n que es manejada por un bloque catch, primero ese bloque se ejecuta y luego el control va al bloque finally.</li> <li>Si el bloque try sale debido a una excepci\u00f3n que NO es manejada por un bloque catch, el control va directamente al bloque finally. Despu\u00e9s de que se ejecuta el bloque finally, se lanza la excepci\u00f3n a la persona que llama y el control vuelve a la persona que llama.</li> </ul> <p></p> <p>En resumen: si el control entra en un bloque try, siempre entrar\u00e1 en el bloque finally.</p> <p>Importante</p> <p>El bloque finally es una herramienta clave para prevenir fugas de recursos. Al cerrar un archivo o recuperar recursos, coloque el c\u00f3digo en un bloque final para asegurarse de que el recurso siempre se recupere.</p>"},{"location":"ud2/24exceptions/#sentencia-try-with-resources","title":"Sentencia try-with-resources","text":"<p>Pr\u00f3ximamente.</p> <p>Tip</p> <p>M\u00e1s informaci\u00f3n en oracle-exceptions java</p>"},{"location":"ud2/25fallos/","title":"Prueba y depuraci\u00f3n de aplicaciones","text":"<p>Todo IDE ofrece un conjunto de herramientas para hacer debug.</p> <p>El debug permite supervisar la ejecuci\u00f3n de los programas, para localizar y eliminar los errores de programaci\u00f3n.</p> <p>Es necesario que un programa compile para poder depurarlo.</p> <ul> <li>Permite suspender la ejecuci\u00f3n de un programa, examinar y establecer los valores de las variables, comprobar los valores devueltos por un determinado m\u00e9todo, el resultado de una comparaci\u00f3n l\u00f3gica o relacional, etc...</li> </ul>"},{"location":"ud2/25fallos/#debug-en-intellij","title":"Debug en IntelliJ","text":"<p>Run --&gt; Debug</p>"},{"location":"ud2/25fallos/#breakpoint-punto-de-ruptura","title":"Breakpoint / Punto de ruptura","text":"<ul> <li> <p>Permite detener un programa en una l\u00ednea/parte determinada.</p> <p>1) Click sobre el n\u00famero de l\u00ednea o CTRL + F8</p> </li> <li> <p>Una vez se detiene el programa podemos:</p> <p>1) Analizar el valor de cualquier variable/propiedad</p> <p>2) Analizar el valor de una expresi\u00f3n.</p> <p>3) Ejecutar l\u00ednea a l\u00ednea y comprobar el flujo de la aplicaci\u00f3n.</p> </li> <li> <p>Tras realizar la comprobaci\u00f3n, se puede:</p> <p>1) Detener el programa.</p> <p>2) O continuar su ejecuci\u00f3n hasta el final.</p> </li> </ul>"},{"location":"ud2/25fallos/#tipos-de-ejecucion","title":"Tipos de ejecuci\u00f3n","text":"<ul> <li>Primero hemos de lanzar el Debug (ALT + SHIFT + F9)</li> <li>Step Over (F8) / Paso a paso:</li> <li>Step Into (F7) / Paso a paso entrando en el m\u00e9todo/procedimiento</li> <li>Resume (F9) / Continuar</li> <li>Step Out (SHIFT + F8) / Ejecuci\u00f3n de un programa hasta el final</li> </ul>"},{"location":"ud2/25fallos/#examinador-de-variables","title":"Examinador de variables","text":"<ul> <li>En cualquier momento podemos inspeccionar el valor y tipo de una variable</li> <li>Si queremos evaluar esas variables m\u00e1s de una vez, es mejor crear un \u201cWatchpoint\u201d sobre ellas</li> <li>Bot\u00f3n derecho + Add to Watches o pesta\u00f1a variables</li> </ul>"},{"location":"ud2/25fallos/#proceso-de-depuracion","title":"Proceso de depuraci\u00f3n","text":"<p>1) Localizar el problema</p> <p>2) Poner un breakpoint en la l\u00ednea del error o en la entrada a la llamada</p> <pre><code>\u25cf Poner watchpoint sobre los datos m\u00e1s sensibles\n</code></pre> <p>3) Lanzar el Debug y utilizar Step Over o Step Into. En cada paso, evaluar el contenido de las variables o expresiones fijadas.</p> <p>4) Una vez localizado el error, detener el debug.</p>"},{"location":"ud2/25fallos/#cambiar-codigo-en-caliente","title":"Cambiar c\u00f3digo en caliente","text":"<ul> <li>Al detener un programa mediante un breakpoint, podemos modificar el valor de cualquier variable y ver c\u00f3mo act\u00faa nuestro c\u00f3digo.</li> <li>Pesta\u00f1a Variables \u2192 campo bot\u00f3n derecho \u2192 set value...</li> </ul>"},{"location":"ud2/26methods/","title":"Introducci\u00f3n a los m\u00e9todos en Java","text":"<p>Los m\u00e9todos en Java son bloques de c\u00f3digo que realizan una tarea en concreto, se utilizan para encapsular la l\u00f3gica de un programa en funciones o procedimientos reutilizables. Los m\u00e9todos sirven para hacer nuestro c\u00f3digo m\u00e1s legible, m\u00e1s f\u00e1cil de mantener y sin c\u00f3digo duplicado.</p> <p>Todo el tiempo hemos estado usando un m\u00e9todo llamado main, dentro de \u00e9l se encuentran todas las sentencias que hemos ido ejecutando, ahora vamos a crear nuestros propios m\u00e9todos teniendo en cuenta:</p>"},{"location":"ud2/26methods/#caracteristicas-de-los-metodos","title":"Caracter\u00edsticas de los m\u00e9todos","text":"<ul> <li>Tienen que estar dentro de una clase</li> <li>Tienen una definici\u00f3n: visibilidad [static] tipoDeRetorno nombreMetodo ([par\u00e1metros])<ul> <li>tipoDeRetorno, indica el tipo de dato que devuelve el m\u00e9todo. Si no devuelve ning\u00fan valor se pone void</li> <li>nombreDelMetodo</li> <li>par\u00e1metros: lista de variables que acepta el m\u00e9todo, esto es opcional.</li> </ul> </li> <li>Invocaci\u00f3n a m\u00e9todos: los m\u00e9todos se invocan desde otros m\u00e9todos o desde el main, para llamar a un m\u00e9todo se utiliza el nombre y par\u00e9ntesis, y si tiene se a\u00f1aden los argumentos.</li> </ul> <p> Los m\u00e9todos se alinean unos debajo de otros, no se puede insertar un m\u00e9todo dentro de otro m\u00e9todo, y adem\u00e1s deben estar dentro de la clase. </p>"},{"location":"ud2/26methods/#sentencia-return-valores-devueltos","title":"Sentencia <code>Return</code> - Valores devueltos","text":"<p>Un valor devuelto es informaci\u00f3n que un m\u00e9todo devuelve al c\u00f3digo que lo llam\u00f3. Cada m\u00e9todo solo puede devolver un valor: cuando un m\u00e9todo regresa, deja de ejecutarse (y continuamos donde lo dejamos antes de llamar al m\u00e9todo). Para que el c\u00f3digo que llam\u00f3 al m\u00e9todo use el valor devuelto, el valor devuelto debe almacenarse en una variable o usarse inmediatamente.</p> <pre><code>public static type methodName(parameters) { // llamar a nombre de m\u00e9todo devuelve expresi\u00f3n\n...\nreturn expression;\n}\ntype variableName = methodName(parameters);  // variableName almacena el valor de retorno\n</code></pre> <p>Ejemplo</p> <pre><code>public class Main {\n\npublic static void main(String[] args) {\nboolean gameOver = true;\nint puntuacion = 5000;\nint nivelCompletado = 5;\nint bonus = 10;\n\nint score = calcularPuntuacion(gameOver, puntuacion, nivelCompletado, bonus);\nSystem.out.println(score);\n\n//otra forma de hacerlo es pasarle directamente el valor de las variables\nscore = calcularPuntuacion(true, 1000, 10, 30);\nSystem.out.println(score);\n\n}\n\npublic static int calcularPuntuacion(boolean gameOver, int puntuacion, int nivelCompletado, int bonus) {\nif (gameOver) {\nint puntuacionFinal = puntuacion + (nivelCompletado * bonus);\npuntuacionFinal += 100;\nreturn puntuacionFinal;\n} else {\nreturn -1;\n}\n}\n\n//OTRAS FORMAS M\u00c1S EFICIENTES DE CREAR EL M\u00c9TODO calcularPuntuaciones\n//1. M\u00e9todo m\u00e1s eficiente sin sentencia else\npublic static int calcularPuntuacion(boolean gameOver, int puntuacion, int nivelCompletado, int bonus) {\nif (gameOver) {\nint puntuacionFinal = puntuacion + (nivelCompletado * bonus);\npuntuacionFinal += 100;\nreturn puntuacionFinal;\n}\nreturn -1;\n}\n\n//2. Otra forma de realizar el m\u00e9todo calcularPuntuacion sin utilizar dos sentencias de return ser\u00eda\npublic static int calcularPuntuacion(boolean gameOver, int puntuacion, int nivelCompletado, int bonus) {\nint puntuacionFinal = -1;\nif (gameOver) {\nint puntuacionFinal = puntuacion + (nivelCompletado * bonus);\npuntuacionFinal += 100;\n}\nreturn puntuacionFinal;\n}\n\n}\n</code></pre>"},{"location":"ud2/2switch/","title":"Sentencia SWITCH","text":"<p>Otra estructura de selecci\u00f3n o alternativa para agregar a nuestro repertorio es la estructura switch.</p> <p></p> <p>La expresi\u00f3n switch se eval\u00faa una vez. El valor de la expresi\u00f3n se compara con los valores de cada caso. Si hay una coincidencia, se ejecuta el bloque de c\u00f3digo asociado. Las palabras clave break y default son opcionales. Los casos (case) suelen ser literales que no var\u00edan, y a menudo se usan constantes o el tipo de dato enum.</p> <p>Es una forma abreviada de codificar la estructura de selecci\u00f3n m\u00faltiple que vimos en el cap\u00edtulo anterior.</p> <p>De forma que el siguiente c\u00f3digo expresado con if-else m\u00faltiple:</p> <pre><code>    if (numJugadores == 1) {\nSystem.out.println(\"Single player\");\n} else if (numJugadores == 2) {\nSystem.out.println(\"Two player\");\n} else if (numJugadores == 3) {\nSystem.out.println(\"Multiplayer\");\n} else {\nSystem.out.println(\"Not possible, too many players\");\n}\n</code></pre> <p>Es equivalente a:</p> <pre><code>    switch (numJugadores) {\ncase 1:\nSystem.out.println(\"Single player\");\nbreak;\ncase 2:\nSystem.out.println(\"Two player\");\nbreak;\ncase 3:\nSystem.out.println(\"Multiplayer\");\nbreak;\ndefault:\nSystem.out.println(\"Not possible, too many players\");\n}\n</code></pre>"},{"location":"ud2/2switch/#break","title":"BREAK","text":"<p>Cuando el programa Java alcanza la palabra break, se sale del bloque switch. Es decir, ya no se sigue ejecutando m\u00e1s c\u00f3digo dentro del switch ni ning\u00fan case.</p> <p>Un break puede ahorrar mucho tiempo de ejecuci\u00f3n porque \"ignora\" la ejecuci\u00f3n de todo el resto del c\u00f3digo switch.</p>"},{"location":"ud2/2switch/#default","title":"DEFAULT","text":"<p>La palabra default se usa para ejecutar c\u00f3digo cuando no hay ninguna coincidencia con ning\u00fan caso (case). Siempre se pone al final, por tanto no necesita de la instrucci\u00f3n break.</p>"},{"location":"ud3/1metodoclase/","title":"\ud83c\udf0e Clases en Java","text":"<p>Las clases es el componente fundamental en la POO. Para entender el concepto de clase, primero necesitamos entender que son los objetos ya que son la clave en la tecnolog\u00eda orientada a objetos.</p>"},{"location":"ud3/1metodoclase/#objetos","title":"Objetos","text":"<p>Los objetos de software son una parte fundamental de la programaci\u00f3n orientada a objetos. Son muy similares a los objetos que representan cosas del mundo real. Como puede ser un micr\u00f3fono, altavoz, ordenador, etc. Como ya estudiamos en la unidad 1, los objetos del mundo real tienen tres caracter\u00edsticas, identidad, estado y comportamiento.</p> <p></p>"},{"location":"ud3/1metodoclase/#identidad","title":"\u2747\ufe0f Identidad","text":"<p>La identidad de un objeto normalmente se implementa a trav\u00e9s de un ID \u00fanico. El valor del ID no es visible para el usuario externo. Sin embargo, la JVM lo utiliza internamente para identificar cada objeto de forma \u00fanica.</p>"},{"location":"ud3/1metodoclase/#estado-campos","title":"\u2747\ufe0f Estado - Campos","text":"<p>Representa el valor de los datos. Por ejemplo, para un ordenador, el estado podr\u00eda ser la cantidad de memoria RAM que tiene, el sistema operativo que incluye, tama\u00f1o del disco duro, etc. En el caso de una persona, el estado puede ser la edad, el nombre, si est\u00e1 casada, etc.</p>"},{"location":"ud3/1metodoclase/#comportamiento-metodos","title":"\u2747\ufe0f Comportamiento - M\u00e9todos","text":"<p>Atendiendo al comportamiento de un ordenador podr\u00eda ser arrancando, apag\u00e1ndose, reiniciando, escribir en la pantalla, etc. Para una persona ser\u00e1 comer, beber, dormir, etc.</p> <p>Los objetos de software almacenan su estado en campos. Los campos es lo que conocemos como variables. Y exponen su comportamiento en lo que llamamos m\u00e9todos.</p> <p>\ud83d\udc80 Importante</p> <p>Un objeto es una instancia de la clase. Una clase es una plantilla o modelo a partir del cual se crean objetos. Entonces, un objeto es la instancia (resultado) de una clase.</p>"},{"location":"ud3/1metodoclase/#clases","title":"Clases","text":"<p>Teniendo en cuenta todo esto, podemos pasar a hablar de clase. Una clase es una plantilla para crear objetos. Para crear un clase en Java utilizamos la palabra reservada <code>class</code>.</p> <p>La nomenclatura del nombre de la clase es primera letra en may\u00fasculas y usar la regla CamelCase para palabras compuestas.</p> <pre><code>    public class Coche {\n\n}\n</code></pre> <p><code>public</code>: es un modificador de acceso, determina qu\u00e9 acceso queremos permitir a otros en la clase. Existen tres tipos de modificadores de acceso:</p> <ul> <li>public: en este caso, public especifica que no hay ninguna restricci\u00f3n de acceso.</li> <li>private: nadie puede acceder a la clase.</li> <li>protected: permite a las clases de este paquete acceder y subclases.</li> </ul> <ul> <li>class: identificador de clase.</li> </ul> <p>\u00bfDe qu\u00e9 forma nos ayudan las clases en nuestro c\u00f3digo? Bien, hasta ahora solo hemos trabajado con tipos de datos primitivos como int, short, char, etc. Este tipo de datos es bastante limitado. Por tanto, las clases se podr\u00edan considerar como un tipo de dato extra poderoso definido por el usuario que nos permite realizar acciones en las que los datos primitivos se quedan cortos.</p> <p>Una clase puede contener:</p> <ul> <li>Campos</li> <li>M\u00e9todos</li> <li>Constructores</li> <li>Bloques de c\u00f3digo</li> <li>Clases o interfaces anidadas</li> </ul>"},{"location":"ud3/1metodoclase/#miembros-de-la-clase-atributos-y-metodos","title":"Miembros de la clase : atributos y m\u00e9todos","text":""},{"location":"ud3/1metodoclase/#atributos-campos-de-la-clase-o-variables-de-instancia","title":"Atributos, campos de la clase o variables de instancia","text":"<p>Hasta ahora hemos creado variables dentro de un m\u00e9todo. A \u00e9stas se les llama variables locales porque son propias del m\u00e9todo en si. Y no puedes acceder a ellas desde fuera de ese m\u00e9todo. Tambi\u00e9n vimos esto dentro de bloques de c\u00f3digo {}, donde las variables creadas en un bloque m\u00e1s interno no eran accesibles en bloques m\u00e1s externos. Ejemplo:</p> <pre><code>    public static void sumar() {\nint contador = 0;\n\nwhile (contador &lt; 10) {\nint suma = 0;\nsuma += contador;\ncontador ++;\n}\n\nSystem.out.println(suma); // esto da error, la variable\n// suma aqu\u00ed no existe.\n}\n</code></pre> <p>A diferencia de esto, las clases nos permiten crear variables que pueden ser accesibles desde cualquier lugar dentro de la clase que estamos creando. A estas variables se les conoce con el nombre de variables miembro/instancia, o de manera m\u00e1s com\u00fan como campos o atributos de la clase.</p>"},{"location":"ud3/1metodoclase/#creacion-de-atributos-de-la-clase","title":"Creaci\u00f3n de atributos de la clase","text":"<p>Para crear un campo de la clase se debe especificar un modificador de acceso(opcional) + tipo de dato + nombre de la variable + inicializaci\u00f3n(opcional).</p> <p>Si no se pone modificador utiliza el de por defecto en el que la variable es accesible por las clases dentro del mismo paquete.</p> <p>El modificador de acceso funciona de la misma forma a como lo hemos explicado anteriormente para la creaci\u00f3n de una clase.</p> <pre><code>    public class Coche {\n\n//campos, atributos o variables de instancia\nprivate int puertas;\nprivate int ruedas;\nprivate String modelo;\nprivate String color;\n}\n</code></pre> <p>Estamos definiendo el estado del coche, es decir, sus caracter\u00edsticas.</p>"},{"location":"ud3/1metodoclase/#modificadores-de-acceso-de-atributos","title":"Modificadores de acceso de atributos","text":"<p>Un buen dise\u00f1o de software refuerza la encapsulaci\u00f3n. Aqu\u00ed es donde las variables de instancia de un objeto son visibles solo para los propios m\u00e9todos del objeto. El c\u00f3digo fuera del objeto no puede acceder directamente a estas variables. Se utiliza para hacer esto el modificador de visibilidad privada. Como regla general, cuando definimos campos para la clase el modificador de acceso ser\u00e1 privado. Es decir, usamos el concepto de encapsulaci\u00f3n que es una clave fundamental de la programaci\u00f3n orientada a objetos. Lo que hacemos es ocultar los campos de la clase del acceso p\u00fablico para que nadie pueda acceder y modificar los campos de la clase. Significa que la representaci\u00f3n del objeto se ocultar\u00e1 a la vista, es decir, el funcionamiento interno del objeto.</p> <p>Existen los siguientes tipos de modificadores, ordenados de menor a mayor restricci\u00f3n:</p> <ul> <li>public: son accesibles desde cualquier lugar. </li> <li>protected: son accesibles desde dentro del mismo paquete y en clases heredadas.</li> <li>sin modificador: son accesibles desde la propia clase y clases dentro del mismo paquete.</li> <li>private: solo son accesibles desde la propia clase, no son accesibles desde fuera.</li> </ul> <p></p> <pre><code>    //modificador p\u00fablico\npublic int speed;\n\n//modificador protegido\nprotected int speed;\n\n//sin modificador\nint speed;\n\n//modificador privado\nprivate int speed;\n</code></pre>"},{"location":"ud3/1metodoclase/#consejos-para-elegir-un-nivel-de-acceso","title":"Consejos para elegir un nivel de acceso","text":"<ul> <li>Utiliza el nivel de acceso m\u00e1s restrictivo que tenga sentido para un miembro en particular. Usa private a menos que tengas una buena raz\u00f3n para no hacerlo.</li> <li>Evita los campos p\u00fablicos a excepci\u00f3n de las constantes.</li> </ul>"},{"location":"ud3/1metodoclase/#metodos-de-instancia","title":"M\u00e9todos de instancia","text":"<p>Para actualizar los campos de la clase, como su acceso es privado se utilizan los m\u00e9todos de instancia. Estos m\u00e9todos ya no van a ser public static como hemos visto hasta ahora. Para crear los m\u00e9todos que actualizan los campos debemos usar la siguiente nomenclatura:</p> <ul> <li> <p>Setters: establecen el valor en el campo de la clase</p> <p>public void setNombreCampo(TipoDatoCampo nombreCampo), donde el par\u00e1metro del m\u00e9todo debe ser del mismo tipo ya que vamos a actualizar su valor mediante el m\u00e9todo.</p> </li> <li> <p>Getters: devuelven el campo de la clase</p> <p>public tipoDatoCampo getNombreCampo()</p> </li> </ul> <pre><code>    public class Coche {\n\nprivate int puertas;\nprivate int ruedas;\nprivate String modelo;\nprivate String color;\n\n//m\u00e9todos de instancia\npublic void setPuertas(int puertas) {\nthis.puertas = puertas;\n}\n\npublic int getPuertas() {\nreturn this.puertas;\n}\n\npublic void setRuedas() {\nthis.ruedas = ruedas;\n}\n\npublic int getRuedas() {\nreturn this.ruedas;\n}\n\npublic void setModelo(String modelo) {\nthis.modelo = modelo;\n}\n\npublic String getModelo() {\nreturn this.modelo;\n}\n\npublic void setColor(String color) {\nthis.color = color;\n}\n\npublic String getColor() {\nreturn this.color;\n}\n\n}\n</code></pre>"},{"location":"ud3/1metodoclase/#creacion-de-una-instancia-de-la-clase","title":"Creaci\u00f3n de una instancia de la clase","text":"Main.java<pre><code>public class Main {\npublic static void main(String[] args) {\n//ford es un objeto de la clase Coche, es una INSTANCIA de la clase\nCoche ford = new Coche();\n}\n}\n</code></pre>"},{"location":"ud3/1metodoclase/#palabra-reservada-this","title":"Palabra reservada this","text":"<p>En un m\u00e9todo set como el nombre del par\u00e1metro del m\u00e9todo es igual al del campo de la clase, necesitamos algo que nos permita distinguir entre uno u otro. Para esto se utiliza la palabra reservada this que hace alusi\u00f3n al campo de la clase.</p>"},{"location":"ud3/1metodoclase/#clase-object-en-java","title":"Clase Object en java","text":"<p>Es necesario conocer a grandes rasgos la clase <code>Object</code>. Tambi\u00e9n es llamada como clase c\u00f3smica, ya que la clase <code>Object</code>, es la clase que est\u00e1 por encima de todas las clases de la api de java.</p> <p>Esto quiere decir que todas las clases de java que vienen predefinidas en el lenguaje de programaci\u00f3n, como las que nosotros construimos, heredan de la clase <code>object</code>.</p> <p>Por eso cuando creamos un objeto, viene ya definido con ciertos m\u00e9todos que se han heredado de la clase <code>Object</code>.</p>"},{"location":"ud3/2constructor/","title":"\ud83c\udf0e Creaci\u00f3n e inicializaci\u00f3n de objetos de la clase","text":"<p>Para crear objetos de la clase, podemos hacerlo de dos formas:</p> <ul> <li>Creando un variable de la clase como hemos hecho hasta ahora:</li> </ul> <pre><code>Coche seat; //(Aqu\u00ed la variable no est\u00e1 inicializada y\n// puede dar errores de compilaci\u00f3n).\n</code></pre> <ul> <li>Utilizando la palabra resevada new m\u00e1s el nombre de la clase:</li> </ul> <pre><code>Coche seat = new Coche(); //En este caso la variable es creada e inicializada\n</code></pre>"},{"location":"ud3/2constructor/#constructor","title":"Constructor","text":"<p>Cuando usamos la palabra new Coche(); para crear un objeto de la clase Coche, en realidad estamos usando lo que se conoce como el constructor de la clase para crear el coche. El constructor por normal general da valor a los campos de la clase.</p>"},{"location":"ud3/2constructor/#constructor-por-defecto","title":"Constructor por defecto","text":"<p>En Java cuando creamos un objeto con la sentencia new Coche(), se lanza el llamado constructor por defecto. Si no se ha definido este en la clase, Java lo crea y lo lanza autom\u00e1ticamente e inicializa los campos de la clase con valores por defecto.</p> <p>Si queremos definirlo nosotros tenemos que usar public m\u00e1s el nombre de la clase.</p> <pre><code>public class Coche {\n\nprivate int puertas;\nprivate String modelo;\nprivate String color;\n\n//Constructor por defecto\npublic Coche() {\n\n}\n\n//getters y setters\n}\n</code></pre>"},{"location":"ud3/2constructor/#constructor-parametrizado","title":"Constructor parametrizado","text":"<p>Un constructor parametrizado tiene uno o m\u00e1s par\u00e1metros. Podemos usar un constructor parametrizado en caso de que necesitemos pasar algunos valores iniciales a la variable miembro de la clase.</p> <pre><code>public Coche(int puertas, String color) {\nthis.puertas = puertas;\nthis.color = color;\n}\n</code></pre>"},{"location":"ud3/2constructor/#constructor-sobrecargado","title":"Constructor sobrecargado","text":"<p>Ahora surge la pregunta de si una clase puede tener m\u00e1s de un constructor o si una clase solo puede tener un constructor. Podemos tener varios constructores en una clase. Los constructores pueden ser sobrecargados al igual que los m\u00e9todos, es decir, podemos tener m\u00e1s de un constructor en nuestra clase siempre que cambiemos el n\u00famero de par\u00e1metros. Por ejemplo:</p> <pre><code>public Coche(String modelo) {\nthis.modelo = modelo;\n}\n\npublic Coche(int puertas, String color) {\nthis.puertas = puertas;\nthis.color = color;\n}\n\npublic Coche(int puertas, String modelo, String color) {\nthis.puertas = puertas;\nthis.color = color;\nthis.modelo = modelo;\n}\n</code></pre> <p>Estos ser\u00edan dos constructores diferentes para el objeto Coche, donde en uno se construye usando el modelo y en el otro el n\u00famero de puertas.</p> <p>A estos constructores tambi\u00e9n se les conoce como constructor parametrizado.</p> <p>Warning</p> <p>Si se define un constructor con par\u00e1metros en la clase, Java entiende que la clase tiene una forma de construirse y no crear\u00e1 de forma autom\u00e1tica el constructor por defecto Coche(). Por tanto si tenemos c\u00f3digo como Coche coche = new Coche(); nos lanzar\u00e1 un error de compilaci\u00f3n.</p>"},{"location":"ud3/2constructor/#llamar-a-un-constructor-desde-otro-dentro-de-la-misma-clase","title":"Llamar a un constructor desde otro dentro de la misma clase","text":"<p>Hemos comentado que podemos tener m\u00e1s de un constructor en nuestra clase gracias a la sobrecarga. En corcondancia con esto, tambi\u00e9n podemos llamar a un constructor desde otro constructor.</p> <p>Por ejemplo, el constructor por defecto es llamado cuando hacemos new Coche(); pero dentro de este constructor no se inicializa ning\u00fan campo, y tal vez nosotros queramos crear el objeto con algunos valores predeterminados. Entonces llamar\u00edamos desde dentro del constructor por defecto a un constructor parametrizado.</p> <pre><code>public Coche() {\nthis(5, \"blanco\");//invoco al constructor con 2 par\u00e1metros\n}\n\npublic Coche(int puertas, String color) {\nthis(puertas, \"desconocido\", color);//invoco al constructor con 3 par\u00e1metros\n}\n\npublic Coche(int puertas, String modelo, String color) {\nthis.puertas = puertas;\nthis.color = color;\nthis.modelo = modelo;\n}\n</code></pre> <p>En el c\u00f3digo anterior, cada vez que creamos un coche vac\u00edo, le asignamos por defecto 5 puertas y color blanco como valores predeterminados.</p> <p>Con esto te aseguras que el objeto se crea con todos los campos inicializados.</p>"},{"location":"ud3/2constructor/#constructor-copia-en-java","title":"Constructor copia en Java","text":"<p>Cuando igualamos dos objetos, no estamos haciendo una copia del objeto, lo que hacemos es apuntar a ese mismo objeto en memoria. En el siguiente ejemplo tenemos dos variables <code>book</code> y <code>book2</code> apuntando al mismo objeto en memoria, es decir, cualquier cambio que realice alguna de las variables, afectar\u00e1 al objeto en s\u00ed apuntado por las mismas.</p> <pre><code>    Book book = new Book(\"1234ASICK\", \"War and Fire\", \"David Haig\");\nBook book2 = book;\nbook2.setIsbn(\"9000ISBN234\");\nSystem.out.println(book.getIsbn());//imprimir\u00e1 9000ISBN234\n</code></pre> Variables <code>book</code> y <code>book2</code> apuntando a un mismo objeto Modificaci\u00f3n del isbn por la variable <code>book2</code>, pero <code>book</code> tambi\u00e9n se ve reflejada <p>Si queremos realizar una copia de un objeto, es decir, traspasar los valores que tiene a un nuevo objeto, necesitamos invocar al constructor copia.</p> <p>El constructor copia es un tipo de constructor que recibe como par\u00e1metro un objeto de la misma clase. Es decir, en este caso estamos creando objetos de tipo coche, por lo que el constructor recibir\u00e1 por par\u00e1metro un objeto de este tipo. Veamos entonces un ejemplo donde se muestra este tipo de constructor:</p> <pre><code>public class Coche {\n\nprivate int puertas;\nprivate String modelo;\nprivate String color;\n\n//Constructor copia\npublic Coche(Coche objCoche) {\nthis.puertas = objCoche.puertas;\nthis.color = objCoche.color;\nthis.modelo = objCoche.modelo;\n}\n\n}\n</code></pre>"},{"location":"ud3/2constructor/#destructor","title":"Destructor","text":"<p>En algunos lenguajes de programaci\u00f3n, para destruir un objeto, existen varios m\u00e9todos o funciones que se ejecutan de forma autom\u00e1tica para destruirlo. Esta funci\u00f3n no devuelve ning\u00fan valor, (por lo tanto es de tipo void), y no recibe ning\u00fan par\u00e1metro.</p> <p>Por otro lado, es importante destacar que en java no existen destructores. Java es un lenguaje que posee un recolector de basura (garbage collector). Este recolector de basura, ejecuta autom\u00e1ticamente un m\u00e9todo llamado finalize(). Por lo tanto, cuando un programa java ya no est\u00e1 utilizando un objeto se realizan dos acciones:</p> <ul> <li>Por un lado entra en acci\u00f3n de forma autom\u00e1tica el garbage collector.</li> <li>Este recolector de basura llama al m\u00e9todo finalize() y lo ejecuta.</li> <li>Para finalizar, se destruye el objeto y se liberan los recursos utilizados en la memoria RAM del ordenador.</li> </ul>"},{"location":"ud3/3sobrecargametodos/","title":"\ud83c\udf0e M\u00e9todos y sobrecarga de m\u00e9todos","text":"<p>En el punto 2.6 del curso vimos una introducci\u00f3n a los m\u00e9todos, qu\u00e9 son, c\u00f3mo definirlos y sus partes. En los siguientes puntos vamos estudiar conceptos relacionados con los m\u00e9todos.</p>"},{"location":"ud3/3sobrecargametodos/#sobrecarga-de-metodos","title":"Sobrecarga de m\u00e9todos","text":"<p>La sobrecarga de m\u00e9todos es una caracter\u00edstica que nos permite tener m\u00e1s de un m\u00e9todo con el mismo nombre, siempre que usemos diferentes par\u00e1metros. Es la capacidad de crear m\u00faltiples m\u00e9todos con el mismo nombre pero diferentes implementaciones</p> <p>Esto tambi\u00e9n se aplica a los constructores como ya hemos visto, ten\u00edamos m\u00e1s de un constructor con el mismo nombre pero diferente n\u00famero de argumentos.</p> <p></p> <p>No hay l\u00edmite en la cantidad de sobrecarga que se puede hacer al dise\u00f1ar constructores y m\u00e9todos, la \u00fanica restricci\u00f3n es que cada m\u00e9todo debe tener una signature distinta con el mismo nombre.</p> <p>La signature(firma) de un m\u00e9todo consta del nombre del m\u00e9todo, m\u00e1s el n\u00famero, los tipos y el orden de sus par\u00e1metros formales. Una clase no puede contener dos m\u00e9todos con la misma signature.</p> <p></p>"},{"location":"ud3/3sobrecargametodos/#ambito-de-variables-locales-y-argumentos","title":"\u00c1mbito de variables locales y argumentos","text":"<p>El estado de un objeto consta de los datos que contiene en sus variables de instancia(campos o atributos). Las variables de instancia mantienen sus valores hasta que se cambian expl\u00edcitamente o hasta que se destruye el objeto.</p> <p>Los m\u00e9todos de un objeto suelen trabajar con otros valores que no se mantienen en las variables de instancia. Estos valores se mantienen en variables y par\u00e1metros locales.</p> <p>En el ejemplo de la clase Cuenta.java ten\u00edamos:</p> <pre><code>public class Cuenta {\n\nprivate double balance;\n...\n\npublic void ingresar(double cantidad) {\nthis.balance = this.balance + cantidad;\nSystem.out.println(\"Balance actual \" + this.balance);\n}\n}\n</code></pre> <p>La persona que llama al m\u00e9todo ingresar utiliza el par\u00e1metro cantidad para enviar un valor al m\u00e9todo. A esto se le llama pasar un valor al m\u00e9todo.</p> <p>Desde el m\u00e9todo main() llamamos al m\u00e9todo ingresar que usa el par\u00e1metro para pasar un valor al m\u00e9todo:</p> <pre><code>public static void main( String[] args ) {\nCuenta patriCuenta = new Cuenta(\"1234567\", 0.0, \"Patricia\");\nc.ingresar(50);\n}\n</code></pre> <p>Cuando se ejecuta al m\u00e9todo ingresar(50), al par\u00e1metro cantidad se le da el valor 50, luego se ejecuta el interior del m\u00e9todo, y el valor se suma a la variable de instancia o campo balance. El m\u00e9todo termina y el control vuelve al m\u00e9todo main(), pero el balance del objeto patriCuenta ha cambiado.</p> <p>Las variables de instancia se utilizan para almacenar el estado de un objeto. Mantienen los valores mientras exista el objeto.</p> <p>Si intent\u00e1ramos usar la variable cantidad en otro m\u00e9todo, nos dar\u00eda error de compilaci\u00f3n, puesto que esa variable no existe fuera del m\u00e9todo ingresar, es lo que se conoce como una variable local.</p> <p></p> <p>Podr\u00edamos tener otro m\u00e9todo que definiera o usara otra variable llamada cantidad.</p> <pre><code>public class Cuenta {\n\nprivate double balance;\n...\n\npublic void ingresar(double cantidad) {\nthis.balance = this.balance + cantidad;\nSystem.out.println(\"Balance actual \" + this.balance);\n}\n\npublic void retirar(double cantidad) {\nthis.balance = this.balance - cantidad;\n}\n}\n</code></pre> <p>En el m\u00e9todo retirar la variable cantidad es una variable diferente a la que usamos en el m\u00e9todo ingresar, aunque tengan el mismo nombre ya que est\u00e1n en \u00e1mbitos diferentes, no pueden verse entre ellas.</p>"},{"location":"ud3/4referencevalue/","title":"\ud83c\udf0e Paso de argumentos por valor y referencia","text":""},{"location":"ud3/4referencevalue/#argumentos-paso-por-valor","title":"Argumentos paso por valor","text":"<p>Un par\u00e1metro es un \"mensaje unidireccional\" que la persona que llama usa para enviar valores a un m\u00e9todo.</p> <p>Dentro del cuerpo de un m\u00e9todo, un par\u00e1metro se usa como cualquier variable. Se puede utilizar en expresiones aritm\u00e9ticas, en sentencias de asignaci\u00f3n, etc.</p> <p>Sin embargo, los cambios realizados en el par\u00e1metro no tienen ning\u00fan efecto fuera del cuerpo del m\u00e9todo. Un par\u00e1metro es una copia local de cualquier valor que la persona que llama haya pasado al m\u00e9todo. Cualquier cambio realizado afectar\u00e1 solo a esta copia local.</p> <p>Esto ocurre cuando se pasa una dato de tipo primitivo.</p> <p>Por ejemplo:</p> <pre><code>------Clase Cuenta\npublic void cambiarCantidad(double cantidad) {\ncantidad -= 20;\n}\n------------------Clase Main\npublic static void main() {\nCuenta cuenta = new Cuenta(\"Pepe\", \"pepe@gmail.com\", \"873463774\");\nint cantidad = 50;\n\ncuenta.ingresar(cantidad);\nSystem.out.println(cantidad);//imprime 50\ncuenta.cambiarCantidad(cantidad);\nSystem.out.println(cantidad);//imprime 50\n}\n</code></pre> <p>cantidad es el nombre de la variable para el valor 50 que se ha enviado al m\u00e9todo cambiarCantidad(). Ese m\u00e9todo cambia el valor de la cantidad, pero esto no tiene ning\u00fan efecto sobre ninguna otra variable fuera del m\u00e9todo.</p> <p>Cuando el m\u00e9todo regresa a su llamador (main), el valor del par\u00e1metro cantidad se olvida.</p> <p>Una variable local es una variable que se declara dentro del cuerpo de un m\u00e9todo.</p> <p>El alcance de una variable local comienza desde donde se declara y termina al final del bloque en el que se encuentra. Recuerde que un bloque es un grupo de declaraciones entre llaves, {}.</p> <p>As\u00ed es como funciona el paso de par\u00e1metros por valor:</p> <ol> <li>Cuando la persona invoca un m\u00e9todo, es persona proporciona una lista de valores (los par\u00e1metros) en la lista de par\u00e1metros del m\u00e9todo.</li> <li>Cuando el m\u00e9todo invocado comienza a ejecutarse, estos valores se copian en los par\u00e1metros formales o argumentos.</li> <li>El m\u00e9todo invocado utiliza los par\u00e1metros formales para acceder a estos valores copiados.</li> <li>Cualquier cambio que realice el m\u00e9todo en el valor contenido en un par\u00e1metro formal cambia solo esa copia.</li> <li>El m\u00e9todo invocado no puede utilizar un par\u00e1metro formal para enviar un valor a la persona que ha invocado el m\u00e9todo.</li> </ol> <p>Como hemos visto un cambio en un par\u00e1metro dentro del m\u00e9todo no afecta a ninguna variable desde donde se invoc\u00f3. Entonces, \u00bfc\u00f3mo puede un m\u00e9todo enviar un valor a la persona que lo invoca?</p> <p>Para devolver un valor \u00fanico a la persona que invoca, un m\u00e9todo invocado puede utilizar la declaraci\u00f3n de retorno return junto con el valor que se devolver\u00e1.</p>"},{"location":"ud3/4referencevalue/#paso-por-referencia","title":"Paso por referencia","text":"<p>Las referencias a objetos o variable de referencia pueden ser par\u00e1metros. Esto sigue siendo una llamada por valor, pero ahora el valor es una referencia de objeto. Esta referencia se puede utilizar para acceder al objeto y posiblemente cambiarlo.</p> <pre><code>public class Test {\n\npublic static void ingresarCienEuros(Cuenta cuenta) {\nSystem.out.println(\"El balance es \" + cuenta.getBalance());\ncuenta.ingresar(100);\nSystem.out.println(\"El balance es \" + cuenta.getBalance());\n}\n\npublic static void main(String[] args) {\nCuenta c = new Cuenta();\nSystem.out.println(\"El balance es \" + cuenta.getBalance());\ningresarCienEuros(c);\nSystem.out.println(\"El balance es \" + cuenta.getBalance());\n}\n}\n</code></pre> <p>Las variables de instancia p\u00fablica de los objetos se pueden cambiar mediante cualquier m\u00e9todo que tenga una referencia al objeto. Como se ha hecho en el ejemplo anterior en la variable de instancia balance.</p>"},{"location":"ud3/4referencevalue/#resumen","title":"Resumen","text":"<p>Un par\u00e1metro formal es una variable en una declaraci\u00f3n de m\u00e9todo. Siempre consta de un tipo seguido de un identificador de variable. Un argumento es un valor que se pasa a un m\u00e9todo a trav\u00e9s de un par\u00e1metro formal cuando se invoca el m\u00e9todo. Los par\u00e1metros de un m\u00e9todo limitan el tipo de informaci\u00f3n que se puede pasar a un m\u00e9todo.</p> <ol> <li> <p>El paso de par\u00e1metros siempre se realiza por valor.</p> </li> <li> <p>Si el par\u00e1metro de un m\u00e9todo es un tipo de datos primitivo, el m\u00e9todo puede cambiar el valor contenido en su par\u00e1metro, pero ese cambio no tiene ning\u00fan efecto en otros lugares.</p> </li> <li> <p>Sin embargo, si el par\u00e1metro de un m\u00e9todo es una referencia a un objeto, el m\u00e9todo puede usar la referencia para acceder al objeto y luego cambiar las variables de instancia del objeto (a menos que sean privadas o en un paquete diferente).</p> </li> <li> <p>Por supuesto, incluso si un m\u00e9todo tiene una referencia a un objeto, el objeto se puede cambiar solo si el objeto permite que se realicen cambios.</p> </li> </ol>"},{"location":"ud3/5static/","title":"\ud83c\udf0e Variables, m\u00e9todos y clases est\u00e1ticas","text":"<p>Una clase, m\u00e9todo o campo declarado como est\u00e1tico puede ser accedido o invocado sin la necesidad de tener que instanciar un objeto de la clase.</p> <p>Para entender mejor que son las variables y m\u00e9todos est\u00e1ticos vamos a ver las diferencias de cada uno de ellos con variables y m\u00e9todos de instancia.</p>"},{"location":"ud3/5static/#variables-estaticas","title":"Variables est\u00e1ticas","text":"<p>Si una variable se declara est\u00e1tica, hay exactamente una copia de esa variable creada sin importar cu\u00e1ntas veces se instancia su clase.</p> <ul> <li>Se declaran usando la palabra reservada static.</li> <li>Cada instancia de la clase comparte la misma variable est\u00e1tica, por lo que si se realizan cambios en esa variable est\u00e1tica todas las dem\u00e1s instancias de esa clase ver\u00e1 el efecto de ese cambio.</li> <li>No se usan muy amenudo.</li> </ul> <pre><code>class Persona {\nprivate static String name;\n\npublic Persona(String name) {\nPersona.name = name;\n}\n\npublic void printName() {\nSystem.out.println(name);\n}\n}\n\npublic class Main {\npublic static void main(String[] args) {\nPersona p1 = new Persona(\"Patricia\");\nPersona p2 = new Persona(\"Maxi\");\np1.printName();//imprime Maxi\np2.printName();//imprime Maxi\n}\n}\n</code></pre>"},{"location":"ud3/5static/#variables-constantes-estaticas","title":"Variables constantes est\u00e1ticas","text":"<p>Tambi\u00e9n se puede declarar un variable constante (final) como est\u00e1tica, esto significa que solo habr\u00e1 una copia de la constante aunque hayan muchas instancias de esa clase. Son tambi\u00e9n llamadas constantes de clase:</p> <pre><code>private static final int NUMERO_JUGADORES = 2;\n</code></pre> <p>No todas las constantes son constantes de clase. Es decir, no todas las constantes se declaran est\u00e1ticas. Sin embargo, la idea de asociar constantes con una clase tiene sentido. Ya que te permite ahorrar recursos de memoria, al crear una \u00fanica copia de la constante.</p> <p>Otra ventaja de las constantes de clase es que se pueden usar antes de que existan instancias de la clase. Por ejemplo, una constante de clase (a diferencia de una constante de instancia) se puede usar durante la instanciaci\u00f3n de objetos:</p> <pre><code>public class Game {\n\npublic static final int MULTIPLAYER = 2;\npublic static final int ONE_PLAYER = 1;\n\nprivate int numeroJugadores;\n\npublic Game(int jugadores) {\nthis.numeroJugadores = jugadores;\n}\n\npublic static void main(String[] args) {\nGame game = new Game(Game.MULTIPLAYER);\n}\n}\n</code></pre>"},{"location":"ud3/5static/#variables-de-instancia","title":"Variables de instancia","text":"<ul> <li>Las variables de instancia tambi\u00e9n son conocidas como campos o atributos.</li> <li>Las variables de instancia pertenecen a una instancia de la clase.</li> <li>Cada instancia tiene su propia copia de una variable de instancia, as\u00ed que cada instancia puede tener un valor(estado) diferente.</li> <li>Las variables de instancia representan el estado de una instancia.</li> </ul> <pre><code>class Persona {\nprivate String name;\n\npublic Persona(String name) {\nthis.name = name;\n}\n\npublic void printName() {\nSystem.out.println(name);\n}\n}\n\npublic class Main {\npublic static void main(String[] args) {\nPersona p1 = new Persona(\"Patricia\");\nPersona p2 = new Persona(\"Maxi\");\np1.printName();//imprime Patricia\np2.printName();//imprime Maxi\n}\n}\n</code></pre>"},{"location":"ud3/5static/#metodos-estaticos","title":"M\u00e9todos est\u00e1ticos","text":"<ul> <li>Los m\u00e9todos est\u00e1ticos son declarados usando el modificador static.</li> <li>No se puede acceder desde los m\u00e9todos est\u00e1ticos a m\u00e9todos de instancia o variables de instancia directamente.</li> <li>Para invocar a un m\u00e9todo est\u00e1tico se utiliza el nombre de la clase + \".\" + el nombre del m\u00e9todo, o solamente el nombre del m\u00e9todo si est\u00e1 en la misma clase.(VEASE EJEMPLO)</li> <li>Normalmente se usan para operaciones que no requieren ning\u00fan dato de instancia de la clase, es decir, nada que venga de this.</li> <li>Dentro de un m\u00e9todo est\u00e1tico no podemos usar la palabra this.</li> <li>Cada vez que veas un m\u00e9todo que no utilice variables de instancia, significa que ese m\u00e9todo deber\u00eda declararse como est\u00e1tico.</li> <li>Por ejemplo, el main es declarado como est\u00e1tico y es llamado por la JVM cuando se lanza la aplicaci\u00f3n.</li> </ul> <pre><code>public class Calculadora {\npublic static void printSuma(int a, int b) {\nSystem.out.println(a+b);\n}\n}\n\npublic class Main {\npublic static void main(String[] args) {\nCalculadora.printSuma(5, 6);\nprintHolaMundo();\n}\n\npublic static void printHolaMundo() {\nSystem.out.println(\"Hola mundo.\");\n}\n}\n</code></pre>"},{"location":"ud3/5static/#metodos-de-instancia","title":"M\u00e9todos de instancia","text":"<ul> <li>Los m\u00e9todos de instancia pertenecen a una instancia espec\u00edfica de la clase.</li> <li>Para usar un m\u00e9todo de instancia tenemos que instanciar un objeto de la clase primero, normalmente utilizando la palabra resevada new.</li> <li>Los m\u00e9todos de instancia pueden acceder a otros m\u00e9todos de instancia y variables de instancia directamente.</li> <li>Los m\u00e9todos de instancia pueden tambi\u00e9n acceder a m\u00e9todos est\u00e1ticos y variables est\u00e1ticas.</li> </ul>"},{"location":"ud3/5static/#metodo-estatico-o-metodo-de-instancia","title":"\u00bfM\u00e9todo est\u00e1tico o m\u00e9todo de instancia?","text":"<p>Cuando voy a crear un m\u00e9todo y tengo dudas sobre si crearlo est\u00e1tico o de instancia debo seguir la siguiente l\u00f3gica:</p> <p>\u00bfEl m\u00e9todo usa alg\u00fan campo o variable de instancia o invoca en su interior a alg\u00fan m\u00e9todo de instancia?</p> <ul> <li>SI --&gt; Entonces deber\u00eda crear un m\u00e9todo de instancia.</li> <li>NO --&gt; Deber\u00eda crear un m\u00e9todo est\u00e1tico.</li> </ul>"},{"location":"ud3/5static/#clases-estaticas","title":"Clases est\u00e1ticas","text":"<p>En el lenguaje Java, no podemos crear una clase externa como una clase est\u00e1tica, pero existe el privilegio de crear una clase interna anidada como una clase est\u00e1tica.</p> <ul> <li>Una clase interna est\u00e1tica nunca puede acceder a un miembro no est\u00e1tico de la clase externa.</li> <li>Una clase interna est\u00e1tica no necesita ninguna referencia de clase externa para acceder a las variables miembro.</li> <li>La clase est\u00e1tica nunca se puede instanciar. Por lo tanto, los m\u00e9todos son directamente accesibles por el nombre de la clase.</li> </ul> <pre><code>public class Estatica {\nstatic int i = 1;\nint j = 9;\n\npublic static void main(String[] args) {\nEstatica s = new Estatica();\n//s.ClaseInterna.printNum(); NO ES CORRECTO\n//Estatica.ClaseInterna.printNum(); SI se podr\u00eda hacer\nClaseInterna.printNum();\n}\n\npublic static class ClaseInterna {\npublic static void printNum() {\nSystem.out.println(i);\n//System.out.println(j); //NO PODEMOS ACCEDER A ATRIBUTOS NO EST\u00c1TICOS\n}\n}\n}\n</code></pre>"},{"location":"ud3/5static/#bloques-estaticos","title":"Bloques est\u00e1ticos","text":"<p>Es posible declarar bloques de c\u00f3digo como est\u00e1ticos, de tal manera que sean ejecutados cuando se cargue la clase. Este tipo de bloques se conocen como bloques de inicializaci\u00f3n est\u00e1ticos (static initializer block). Si no se declara un bloque de este tipo de forma expl\u00edcita, el compilador Just-in-Time combina todos los campos est\u00e1ticos en un bloque y los ejecuta durante la carga de clases.</p> <pre><code>public class Objeto {\n\nprivate static int campo1;\n\nstatic {\ncampo1 = 10;\n}\n}\n</code></pre>"},{"location":"ud3/5static/#imports-estaticos","title":"Imports est\u00e1ticos","text":"<p>Una de las caracter\u00edsticas incluidas en Java 5 fu\u00e9 la capacidad de importar los m\u00e9todos y variables est\u00e1ticas de un m\u00f3dulo y acceder a ellos como si hubieran sido declarados en la propia clase. Es especialmente \u00fatil, y mejora la legibilidad, cuando se est\u00e1n definiendo test unitarios, ya que la mayor\u00eda de los m\u00e9todos de aserci\u00f3n de JUnit son est\u00e1ticos.</p> <pre><code>import static java.lang.Math.PI;\n\npublic static void main(String[] args) {\ndouble a = PI;\n}\n</code></pre>"},{"location":"ud3/6recursion/","title":"\u267e\ufe0f Recursividad","text":"<p>Un m\u00e9todo recursivo es un m\u00e9todo que se llama a s\u00ed mismo. Un m\u00e9todo iterativo es un m\u00e9todo que usa un bucle para repetir una acci\u00f3n. En cierto sentido, la recursividad es una alternativa a las estructuras de control iterativas (en bucle).</p> <p>Por ejemplo, tenemos el siguiente m\u00e9todo iterativo:</p> <pre><code>public void hola(int n) {\nfor (int k = 0; k &lt; n; k++) {\nSystem.out.println(\"Hola\");\n}\n} </code></pre> <p>Una versi\u00f3n recursiva de ese m\u00e9todo ser\u00eda:</p> <pre><code>public void hola(int n) {\nif(n &gt; 0 ) {\nSystem.out.println(\"Hola\");\nhola(n \u2212 1); //Llamada recursiva\n}\n}\n</code></pre> <p>Este m\u00e9todo es recursivo porque se llama a s\u00ed mismo cuando n es mayor que 0. Sin embargo, ten en cuenta que cuando se llama a s\u00ed mismo, pasa n - 1 como el valor de su par\u00e1metro. Si este m\u00e9todo se llama inicialmente con n igual a 5, lo siguiente es una pila de lo que sucede. Las indentaciones indican cada vez que el m\u00e9todo se llama a s\u00ed mismo:</p> <pre><code>hola(5)\n    imprime \"Hola\"\n    hola(4)\n        imprime \"Hola\"\n        hola(3)\n            imprime \"Hola\"\n            hola(2)\n                imprime \"Hola\"\n                hola(1)\n                    imprime \"Hola\"\n                    hola(0)\n</code></pre> <p>En el ejemplo anterior, es mucho menos eficiente llamar a un m\u00e9todo cinco veces que repetir un bucle for cinco veces. Las llamadas a m\u00e9todos ocupan m\u00e1s memoria que los bucles e implican m\u00e1s sobrecarga computacional, en tareas como pasar par\u00e1metros, asignar almacenamiento para las variables locales del m\u00e9todo y devolver los resultados del m\u00e9todo.</p> <p>Note</p> <p>Los algoritmos y m\u00e9todos iterativos son generalmente m\u00e1s eficientes que los algoritmos recursivos que hacen lo mismo.</p>"},{"location":"ud3/6recursion/#recursividad-como-un-enfoque-de-resolucion-de-problemas","title":"Recursividad como un enfoque de resoluci\u00f3n de problemas","text":"<p>Dado que la recursividad no es realmente necesaria, si un lenguaje de programaci\u00f3n tiene bucles, y no es m\u00e1s eficiente que los bucles, \u00bfpor qu\u00e9 es tan importante?</p> <p>Porque la recursividad es un enfoque eficaz para la resoluci\u00f3n de problemas. Es una forma de ver un problema.</p> <p>La recursividad se basa en dos conceptos clave de resoluci\u00f3n de problemas: divide y vencer\u00e1s y auto-similaridad. En la resoluci\u00f3n de problemas recursivos, utilizamos la estrategia de divide y vencer\u00e1s repetidamente para dividir un gran problema en una secuencia de problemas cada vez m\u00e1s peque\u00f1os hasta que llegamos a un problema que es pr\u00e1cticamente trivial de resolver. Lo que nos permite crear esta serie de subproblemas es que cada subproblema es similar al problema original, es decir, cada subproblema es solo una versi\u00f3n m\u00e1s peque\u00f1a del problema original.</p> <p>La capacidad de ver un problema, por uno compuesto por problemas m\u00e1s peque\u00f1os y similares es el n\u00facleo del enfoque recursivo.</p>"},{"location":"ud3/6recursion/#parte-recursiva-y-caso-base","title":"Parte recursiva y caso base","text":"<p>Una definici\u00f3n recursiva consta de dos partes: una parte recursiva que se repite y reduce el problema en una versi\u00f3n m\u00e1s peque\u00f1a del problema original, y un caso base o l\u00edmite no recursivo, que define una condici\u00f3n l\u00edmite y se utiliza para detener la recursividad.</p> <p>Veamos esto con un ejemplo:</p>"},{"location":"ud3/6recursion/#ejemplo-1-factorial-n","title":"EJEMPLO 1: Factorial: N!","text":"<p>Recordamos como se hac\u00eda el c\u00e1lculo de n!:</p> <p>n! = n * (n-1) * n(n-2) * .... mientras n &gt; 0</p> <p>Adem\u00e1s, 0! se define como 1.</p> <p>Ejemplos:</p> <ul> <li>4! = 4 * 3 * 2 * 1 = 24</li> <li>3! = 3 * 2 * 1 = 6</li> <li>1! = 1</li> <li>0! = 1</li> </ul> <p>Como vemos en el ejemplo, podemos deducir que el factorial se repite en t\u00e9rminos de (n-1) y el \u00fanico caso donde no se calcula el factorial es 0!, esto nos lleva a que:</p> <p>n! = 1             --&gt; if n = 0 //caso base</p> <p>n! = n * (n-1)     --&gt; if n &gt; 0 //caso recursivo</p> <p>De forma que el factorial de un n\u00famero quedar\u00eda codificado de la siguiente forma:</p> <pre><code>    public static int factorial(int n) {\nif (n &lt;= 0) {\nreturn 1;\n} else {\nreturn n * factorial(n-1);\n}\n}\n</code></pre>"},{"location":"ud3/6recursion/#traza","title":"Traza","text":"<pre><code>factorial(4)\n    4 * factorial(3)\n        3 * factorial(2)\n            2 * factorial(1)\n                1 * factorial(0)\n                    return 1\n                return 1 * 1 --&gt; 1   \n            return 2 * 1 --&gt; 2\n        return 3 * 2 --&gt; 6 \n    return 4 * 6 --&gt; 24\nreturn 24\n</code></pre>"},{"location":"ud3/6recursion/#ejemplo-2-verificar-si-un-numero-es-palindromo","title":"EJEMPLO 2: Verificar si un n\u00famero es pal\u00edndromo","text":"<p>Un n\u00famero es pal\u00edndromo si al leerse en ambos sentidos, tanto de izquierda a derecha como de derecha a izquierda, se obtiene el mismo n\u00famero. Por ejemplo: 121, 1001, etc.</p> <pre><code>public static int revertir(int n, int reverso) {\nif (n &gt; 0) {\nint ud = n % 10;\nreverso = reverso * 10;\nreturn revertir(n/10, ud+reverso);\n} else {\nreturn reverso;\n}\n}\n\npublic static void main (String[] args) {\nint reverso = revertir(121, 0);\n\nif (reverso == n)\nSystem.out.println(\"Son pal\u00edndromos.\");\nelse\nSystem.out.println(\"No lo son\" );\n}\n</code></pre>"},{"location":"ud3/6recursion/#ejemplo-3-revertir-un-string","title":"EJEMPLO 3: Revertir un String","text":"<p>Para revertir un String, nos quedamos con el primer car\u00e1cter que iremos a\u00f1adiendo al final de la recursividad, y vamos acortando el String para llegar al caso base.</p> <pre><code>public static String reverseRecursive(String str) {\nif (str.isEmpty()) { //caso base\nreturn \"\";\n}\nreturn reverseRecursive(str.substring(1)) + str.charAt(0);\n}\n</code></pre>"},{"location":"ud3/7nullvalue/","title":"\ud83c\udf0e Valor nulo","text":"<p>Una variable de referencia contiene informaci\u00f3n sobre la ubicaci\u00f3n de un objeto. No contiene el objeto en s\u00ed.</p> <p>Por ejemplo el siguiente c\u00f3digo:</p> <pre><code> String str;\nPersona p;\n</code></pre> <p>declara dos variables de referencia pero no construye ning\u00fan objeto. Con el siguiente c\u00f3digo:</p> <pre><code> str = \"Programaci\u00f3n\";\np = new Persona(\"Patricia\");\n</code></pre> <p>se construyen los objetos y se colocan referencias en las variables.</p> <p>null es un valor especial que significa \"sin objeto\". Se establece una variable de referencia a null cuando no se refiere a ning\u00fan objeto. Las variables a menudo se asignan en nulas cuando se declaran:</p> <pre><code> String str = null;\nPersona p = null;\n</code></pre> <p>str y p todav\u00eda no son objetos, son variables que en un futuro pueden referenciar a objetos.</p> <p>Podemos asignar el valor null a cualquier variable de tipo referencia, ya sea un objeto, string, array, etc.</p> <p>Una variable de referencia a veces hace referencia a un objeto y otras veces no, y puede referirse a diferentes objetos en diferentes momentos. Por tanto, necesitamos una forma de decir que una variable ahora no se refiere a un objeto. Para ello, se le asigna un valor null a la variable.</p> <p></p> <p>El objeto Persona con el nombre de Patricia se destruir\u00e1 eventualmente por el garbage collector ya que no es referenciado por nadie.</p>"},{"location":"ud3/8pojo/","title":"\ud83c\udf0e POJO, Record","text":""},{"location":"ud3/8pojo/#pojo","title":"POJO","text":"<p>Un Plain old Java object (POJO) o objeto simple de Java es una clase que generalmente solo tiene campos o variables de instancia.</p> <p>Se utiliza para alojar datos y pasar datos entre clases funcionales. Normalmente tiene pocos m\u00e9todos o ninguno, adem\u00e1s de los getters y setters. Se utiliza mayoritariamente para leer o escribir datos a partir de bases de datos, flujos o ficheros. Se podr\u00eda decir que es un tipo de datos.</p>"},{"location":"ud3/8pojo/#ejemplos-de-pojos","title":"Ejemplos de POJOS","text":"<ul> <li>A veces pueden ser llamados bean, o JavaBean. JavaBean es un POJO con extra reglas aplicadas a ellos.</li> <li>Otras veces un POJO puede ser un Entity, relacionado con base de datos porque contiene los datos de las entidades de base de datos.</li> <li>Otro acr\u00f3nimo usando con los POJOS puede ser un DTO (data transfer object), objeto de transferencia de datos, que es una descripci\u00f3n de un objeto, que puede modelarse como simples datos.</li> </ul> <p>Ejemplo de POJO que contiene el c\u00f3digo necesario para manipular datos de un estudiante:</p> Student.java<pre><code>public class Student {\nprivate String id;\nprivate String name;\nprivate String dateOfBirth;\n\npublic Student(String id, String name, String dateOfBirth) {\nthis.id = id;\nthis.name = name;\nthis.dateOfBirth = dateOfBirth;\n}\n\npublic String getId() {\nreturn id;\n}\n\npublic void setId(String id) {\nthis.id = id;\n}\n\npublic String getName() {\nreturn name;\n}\n\npublic void setName(String name) {\nthis.name = name;\n}\n\npublic String getDateOfBirth() {\nreturn dateOfBirth;\n}\n\npublic void setDateOfBirth(String dateOfBirth) {\nthis.dateOfBirth = dateOfBirth;\n}\n\n@Override\npublic String toString() {\nreturn \"Student{\" +\n\"id='\" + id + '\\'' +\n\", name='\" + name + '\\'' +\n\", dateOfBirth='\" + dateOfBirth + '\\'' +\n'}';\n}\n}\n</code></pre> <p>Note</p> <p>Casi todo el c\u00f3digo es generado con el IDE, es este caso, IntelliJ, que hace gran parte del trabajo por nosotros. Este tipo de c\u00f3digo tiene un nombre, es lo que se conoce como boilerplate code, o c\u00f3digo repetitivo que sigue un patr\u00f3n.</p>"},{"location":"ud3/8pojo/#record","title":"Record","text":"<p>Java introdujo un nuevo tipo llamado Record (registro) que pas\u00f3 a formar parte oficialmente en el JDK 16. Su prop\u00f3sito es reemplazar el c\u00f3digo boilerplate del POJO y ser m\u00e1s restrictivo.</p> <p>Java llama a los Record, \"plain data carriers\", soporte de datos simples.</p> <p>Record es una clase especial que contiene datos y no est\u00e1 pensada para ser alterada. S\u00f3lo contiene los m\u00e9todos m\u00e1s fundamentales, como constructores y getters. El desarrollador no tiene que escribir nada de este c\u00f3digo.</p>"},{"location":"ud3/8pojo/#como-crear-un-record","title":"C\u00f3mo crear un Record","text":"<p>Vamos a crear un record de estudiante como hicimos en el POJO anterior. Para ello, En el IntelliJ, dentro del proyecto, en un directorio hacemos bot\u00f3n derecho del rat\u00f3n, \"New -&gt; Java class\".</p> <p></p> <p>Seleccionamos la opci\u00f3n \"Record\" (Necesito tener instalado JDK 16 o superiores)</p> <p></p> <p></p> <p>Si nos fijamos en el c\u00f3digo generado tenemos, el modificador de acceso <code>public</code> m\u00e1s la palabra <code>record</code> y luego el nombre que le hemos dado seguido de unos par\u00e9ntesis. \u00c9stos par\u00e9ntesis es similar a un constructor, podemos configurar par\u00e1metros dentro de los par\u00e9ntesis. A la parte de par\u00e9ntesis se le conoce como record header.</p> <p>Copiamos los mismos que ten\u00edamos en Student.java:</p> JavaStudent.java<pre><code>public record JavaStudent(String id, String name, String dateOfBirth) {\n}\n</code></pre> <p>Hemos modificado todo el c\u00f3digo anterior, por estas dos l\u00edneas. Teniendo en cuenta, que Record no soporta modificaciones, por tanto, no hay setters.</p>"},{"location":"ud3/8pojo/#record-header","title":"Record header","text":"<p>A los par\u00e1metros que est\u00e1n dentro de la record header se les llama componentes. Por cada componente Java genera el siguiente c\u00f3digo impl\u00edcito:</p> <ul> <li>Un campo o atributo con el mismo nombre <code>private</code> y <code>final</code>. A este atributo se le conoce como component field.</li> <li>Un m\u00e9todo de acceso p\u00fablico que tiene el mismo nombre y tipo del componente. Lo que ser\u00eda un getter, pero no tiene ning\u00fan prefijo tipo get o is delante.</li> <li>Un constructor con los mismos argumentos y en el mismo orden descritos dentro de la cabecera de record.</li> <li>Java genera un m\u00e9todo toString que imprime cada atributo formateado.</li> </ul>"},{"location":"ud3/8pojo/#constructores-de-un-record","title":"Constructores de un Record","text":"<p>Si queremos generar un constructor, dentro de la clase record podemos hacer click bot\u00f3n derecho del rat\u00f3n -&gt; constructor:</p> <p></p> <p>IntelliJ me ofrece tres opciones para generar un constructor:</p> <p></p> <p>Los constructores de Record pueden ser de tres tipos:</p> <ol> <li>Constructor can\u00f3nico o largo (canonical constructor): es el constructor impl\u00edcito generado con los mismos componentes que hay en la cabecera. Se puede crear uno expl\u00edcitamente, por lo que no se generar\u00e1 entonces el impl\u00edcito. Si se declara uno expl\u00edcito, se debe asignar a todos los campos un valor.</li> <li>Constructor personalizado (custom constructor): es un constructor sobrecargado. Su primera sentencia debe ser una llamada al can\u00f3nico.</li> <li>Constructor compacto o corto (compact constructor): solo se utiliza en los records. Es una forma concisa de declarar un constructor can\u00f3nico.</li> </ol>"},{"location":"ud3/8pojo/#canonical-constructor-constructor-canonico","title":"Canonical constructor - Constructor can\u00f3nico","text":"<p>Es el constructor con todos los par\u00e1metros o componentes. Este constructor est\u00e1 impl\u00edcitamente creado, pero podemos sobreescribirlo.</p> <p>En el siguiente ejemplo se ha creado un constructor can\u00f3nico que NO es necesario crear porque ya se crea de manera impl\u00edcita. Crearlo es redundante ya que no hace nada nuevo. </p> <p>El constructor can\u00f3nico solo tiene sentido crearlo cuado quiero a\u00f1adir alguna validaci\u00f3n en alg\u00fan campo o dar un comportamiento diferente al de por defecto.</p> JavaStudent.java<pre><code>public record JavaStudent(String id, String name, String dateOfBirth) {\n//Canonical constructor\n//Hacer esto no tiene sentido, porque ya est\u00e1 impl\u00edcito cuando poner los componentes en la cabecera\npublic JavaStudent(String id, String name, String dateOfBirth) {\nthis.id = id;\nthis.name = name;\nthis.dateOfBirth = dateOfBirth;\n}\n\n//Canonical constructor\n//En este caso, SI tiene sentido, porque queremos hacer algunas validaciones antes de asignar los valores\npublic JavaStudent(String id, String name, String dateOfBirth) {\nthis.id = (id.isEmpty()) ? \"Unknown\": id;\nthis.name = name;\nthis.dateOfBirth = dateOfBirth;\n}\n}\n</code></pre>"},{"location":"ud3/8pojo/#constructor-personalizado","title":"Constructor personalizado","text":"<p>Es lo que conocemos como constructor sobrecargado. Creamos constructores personalizados con un n\u00famero menor de elementos que el constructor can\u00f3nico. El \u00fanico requisito con este constructor es, que la primera l\u00ednea tiene que ser una llamada al constructor can\u00f3nico para que se inicialicen los campos o componentes.</p> <pre><code>public record JavaStudent(String id, String name, String dateOfBirth) {\npublic JavaStudent(String id, String name) {\nthis(id, name, null);\n}\n\npublic JavaStudent(String id, String dateOfBirth) {\nthis(id, null, dateOfBirth);\n}\n}\n</code></pre>"},{"location":"ud3/8pojo/#compact-constructor","title":"Compact constructor","text":"<ul> <li>No se pueden tener ambos constructores, el compact m\u00e1s el can\u00f3nico expl\u00edcito.</li> <li>El compact constructor se declara sin par\u00e9ntesis y sin par\u00e1metros o argumentos.</li> <li>Tiene acceso a todos los argumentos o par\u00e1metros del constructor can\u00f3nico, no confundir con los campos de la clase o variables de instancia de la clase.</li> <li>No se pueden hacer asignaciones a los campos de instancia de la clase en este constructor.</li> <li>Todas las asignaciones impl\u00edcitas del constructor can\u00f3nico ocurren despu\u00e9s de la ejecuci\u00f3n del c\u00f3digo del constructor compacto.</li> </ul> <p>Este constructor est\u00e1 entrelazado con el constructor can\u00f3nico. El c\u00f3digo que se inserte en este constructor ser\u00e1 llamado antes que el c\u00f3digo en el constructor impl\u00edcito(can\u00f3nico), es decir, antes de asignar cualquier valor a las variables de isntancia finales. Por eso este constructor tiene acceso a todos los argumentos o componentes del constructor can\u00f3nico. Este constructor se utiliza para realizar validaciones en los argumentos o componentes antes de asignarlos a las variables de instancia de la clase.</p> <p>Warning</p> <p>Si se ha definido un constructor compacto, no se puede crear o definir expl\u00edcitamente el constructor can\u00f3nico.</p> <p>Ejemplo:</p> <pre><code>    //Compact constructor\npublic JavaStudent {\nif (id.isEmpty())  id =\"Unknown\";\n//id = this.id; //NO podr\u00eda hacer esto, porque this.id todav\u00eda no se ha inicializado\n//this.id = id; //TAMPOCO podr\u00eda hacer esto porque se har\u00e1 m\u00e1s tarde en el constructor\n//impl\u00edcito (can\u00f3nico), y como las variables de instancia son finales, no \n//puedo reasignarles valores.\n}\n</code></pre>"},{"location":"ud3/8pojo/#campos-estaticos-y-metodos-estaticos","title":"Campos est\u00e1ticos y m\u00e9todos est\u00e1ticos","text":"<p>Los record pueden tener campos y m\u00e9todos est\u00e1ticos. Pero s\u00f3lo se permiten campos est\u00e1ticos. Los record no pueden declarar campos de instancia.</p> <pre><code>public record Vehicle(int price) {\nprivate static int wheels;\nprivate static final int ZERO = 0;\n\nstatic {\nwheels = 4;\n}\n\npublic Vehicle() {\nthis(ZERO);\n}\n\npublic static void printWheels() {\nSystem.out.println(wheels);\n}\n\n//tambi\u00e9n podemos tener m\u00e9todos de instancia\npublic double calculate(int x) {\nreturn x * 9.99;\n}\n}\n</code></pre>"},{"location":"ud3/8pojo/#record-immutable","title":"Record immutable","text":"<p>Con Record no tenemos setters, ni forma de modificar nuestros datos. Esto es debido a que, Record ha sido dise\u00f1ado para ser inmutable, para que los datos se mantengan encapsulados y protegidos de mutaciones involuntarias. Por tanto, si necesitas modificar los datos de tu clase, nunca usaremos un Record, sino que crearemos un POJO como hicimos anteriormente.</p>"},{"location":"ud4/1arrays/","title":"Arrays de datos primitivos","text":"<p>Los arrays es una estructura de datos que te permite almacenar una secuencia de valores todos del mismo tipo.</p> <p>Un array est\u00e1 hecho de bloques contiguos de memoria que se divide en varias celdas. Cada celda tiene un valor y todos los valores son del mismo tipo. A veces, las celdas de un array se denominan slots. En el array de la imagen cada celda contiene un int.</p> <p>En el ejemplo de la imagen hemos creado un array de enteros. Tambi\u00e9n se podr\u00eda crear un array de caracteres, de String, etc. Esto se podr\u00eda hacer tanto para tipos de datos primitivos como para objetos.</p> <ul> <li>Las celdas est\u00e1n numeradas secuencialmente empezando por cero.</li> <li>Si hay N celdas en un array, entonces los \u00edndices van del 0 hasta N-1.</li> <li>La longitud de un array es el n\u00famero de celdas.</li> </ul> <p>Al valor almacenado en la celda de un array se le suele llamar elemento.</p> <p>Es muy importante tener en cuenta que los arrays empiezan siempre en la posici\u00f3n cero. Por tanto, si se desea acceder al primer elemento del array, estar\u00e1 almacenado en la posici\u00f3n 0.</p>"},{"location":"ud4/1arrays/#declaracion-y-reseva-de-memoria","title":"Declaraci\u00f3n y reseva de memoria","text":"<p>Para declarar un array, se hace de la misma forma que har\u00edamos si quisi\u00e9ramos declarar una variable pero a\u00f1adiendo [ ]:</p> <pre><code>    int miVariable; //declaramos una variable normal\nint[] miArray; //declaramos una variable array\n</code></pre> <p>Si usamos la declaraci\u00f3n tipo[] arrayName crea una referencia a una variable de tipo de array, pero no construye el objeto.</p> <p>Los arrays en Java se crean como objetos, y como cualquier otro objeto en Java, para construirlo utilizamos la palabra reservada new. Para inicializar un array usaremos la palabra new + tipo de dato + tama\u00f1o del array entre corchetes[]:</p> <pre><code>    int[] miArray = new int[10]; //creamos y reservamos memoria para el array con 10 elementos\n// y valores 0 en cada posici\u00f3n\n\ndouble[] dArray = new double[5];\n</code></pre> <p>Una vez ha sido construido no es posible cambiar su tama\u00f1o. La variable miArray va a ser un array con espacio para 10 elementos de tipo entero.</p>"},{"location":"ud4/1arrays/#acceso-a-los-elementos-del-array","title":"Acceso a los elementos del array","text":"<p>Para guardar un valor dentro de una celda del array tenemos que acceder a su posici\u00f3n dentro del array.</p> <pre><code>    int[] miArray = new int[10];\nmiArray[2] = 5; //guardamos en la posici\u00f3n 2 del array el valor 5\n</code></pre> <p>Warning</p> <p>Recuerda que los elementos del array empiezan con \u00edndice 0, por tanto, en realidad la posici\u00f3n 2 ser\u00eda la 3.</p> <p>Para acceder a un valor de una determinada posici\u00f3n del array y mostrarlo lo har\u00edamos de la siguiente forma:</p> <pre><code>    int elemento = miArray[2]; //almacenamos el valor 5 en la variable entera elemento\nSystem.out.println(elemento);\n\n// o tambi\u00e9n podemos hacer directamente\nSystem.out.println(miArray[2]);\n</code></pre>"},{"location":"ud4/1arrays/#inicializacion-del-array","title":"Inicializaci\u00f3n del array","text":"<p>Hay varias formas de inicializar un array. Por ejemplo, si quisi\u00e9ramos darle valor a todas las posiciones del array podr\u00edamos hacerlo de la forma:</p> <pre><code>    miArray[0] = 2;\nmiArray[1] = 31;\nmiArray[2] = 5;\n....\nmiArray[10] = 4;\n</code></pre> <p>Lo cual es una forma muy pesada y tediosa. Java nos ofrece otras formas de inicializar los arrays en una sola l\u00ednea de c\u00f3digo que solo es aplicable a la vez que definimos la variable:</p> <pre><code>    int[] miArray = {2,31,5,7,12,89,6,11,50,4};//correcto\n\n//no puedo inicializar el array despu\u00e9s de haberlo creado\nmiArray = {2,31,5,7,12,89,6,11,50,4};//eso da ERROR\n</code></pre> <p>De esa forma, tambi\u00e9n le indicamos indirectamente el tama\u00f1o del array. Java cuenta el n\u00famero de elementos que hay entre {} y crea un array de ese tama\u00f1o y adem\u00e1s los asigna en posiciones consecutivas dentro del array.</p> <p>Los \u00edndices en un array son enteros que especifican la posici\u00f3n que ocupa el elemento dentro del array. Por tanto podemos manejar los \u00edndices con variables enteras.</p> <p>Una tercera forma ser\u00eda utilizando la estructura de bucle for, para esto, debemos saber con antelaci\u00f3n el valor de los elementos del array:</p> <pre><code>    int[] miArray = new int[10];\n\nfor(int i = 0; i &lt; 10; i++) {\nmiArray[i] = i * 10;\n}\n</code></pre> <p>Lo que hacemos es inicializar cada posici\u00f3n del array utilizando el bucle. Estamos almacenando dentro del array el valor del \u00edndice multiplicado por 10, de forma que tendremos, {0, 10, 20, ...., 90}.</p> <p>La estructura for tambi\u00e9n es de gran ayuda si queremos imprimir los valores que est\u00e1n guardados en cada posici\u00f3n del array:</p> <pre><code>    for(int i = 0; i &lt; 10; i++) {\nSystem.out.println(\"Elemento \" + i + \" valor \" + miArray[i]);\n}\n</code></pre> <p>A falta de cualquier otra informaci\u00f3n, las celdas de un array se inicializan con el valor predeterminado para su tipo. Cada celda de un array de tipo num\u00e9rico se inicializa a cero.</p> <p>Y cada celda de un array de referencias a objetos se inicializa en nulo (null).</p>"},{"location":"ud4/1arrays/#longitud-del-array","title":"Longitud del array","text":"<p>Una buena pr\u00e1ctica, es utilizar una propiedad integrada dentro de array, en vez de hardcodear literales de tama\u00f1o dentro del bucle. Esta propiedad es length:</p> <pre><code>    for(int i = 0; i &lt; miArray.length; i++) {\nSystem.out.println(\"Elemento \" + i + \" valor \" + miArray[i]);\n}\n</code></pre> <p>Si ahora cambiamos la longitud del array en su definici\u00f3n, no se ver\u00eda afectado ning\u00fan bucle o lugar donde se utilizara miArray.length.</p>"},{"location":"ud4/1arrays/#pasar-un-array-como-argumento-en-un-metodo","title":"Pasar un array como argumento en un m\u00e9todo","text":"<p>Al igual que hac\u00edamos con las variables simples, tambi\u00e9n podemos pasar arrays a los m\u00e9todos.</p> <pre><code>public static void imprimirArray(int[] array) {\nfor(int i = 0; i &lt; array.length; i++) {\nSystem.out.println(\"Elemento \" + i + \" valor \" + array[i]);\n}\n}\n\npublic static void main() {\nint[] miArray = new int[10];\nimprimirArray(miArray);\n}\n</code></pre>"},{"location":"ud4/1arrays/#devolver-un-array-en-un-metodo","title":"Devolver un array en un m\u00e9todo","text":"<p>Para devolver un objeto de tipo array en un m\u00e9todo simplemente a\u00f1adiremos []:</p> <pre><code>public static int[] calcular() {\nint[] miArray = new int[10];\n....//realizo calculos con el array\nreturn miArray;\n}\n</code></pre>"},{"location":"ud4/1arrays/#caso-practico-real-uso-de-un-array","title":"Caso pr\u00e1ctico real uso de un array","text":"<p>Vamos a presentar un ejemplo de un caso real para el que los arrays son muy efectivos. Por ejemplo pedir al usuario que inserte n\u00fameros y mostrar la media de los n\u00fameros insertados.</p> <pre><code>public class MiArray {\n\nprivate static Scanner sc = new Scanner(System.in);\n\npublic static void main(String[] args) {\nint[] enteros = leerEnteros(5);\n\n//imprimimos los valores\nfor (int i = 0; i &lt; enteros.length; i++) {\nSystem.out.println(\"Elemento en posici\u00f3n \" + i + \" valor \" + enteros[i]);\n}\nSystem.out.println(\"La media del array es \" + calcularMedia(enteros));\n}\n\npublic static int[] leerEnteros(int elementos) {\nSystem.out.println(\"Inserta \" + elementos + \" de tipo entero.\");\nint[] array = new int[elementos];\n\nfor (int i = 0; i &lt; array.length; i++) {\narray[i] = sc.nextInt();\n}\n\nreturn array;\n}\n\npublic static double calcularMedia(int[] array) {\nint suma = 0;\nfor (int i = 0; i &lt; array.length; i++) {\nsuma += array[i];\n}\nreturn (double) suma / (double) array.length;\n}\n}\n</code></pre>"},{"location":"ud4/2usefularrays/","title":"Algoritmos de arrays \u00fatiles","text":"<p>Un array que utiliza un solo \u00edndice para acceder a sus valores se denomina array unidimensional, ya que utilizamos el \u00edndice para acceder a todas las celdas del array. \u00c9stas celdas est\u00e1n alineadas de forma secuencial.</p> <p>Un array bidimensional necesita dos \u00edndices para acceder a los valores. En este caso las celdas est\u00e1n dispuestas en forma de matriz, como una estructura rectangular.</p> <p>Es posible crear arrays de mayores dimensiones aunque rara vez se utilizan.</p>"},{"location":"ud4/2usefularrays/#contar-los-elementos-que-contiene-un-array","title":"Contar los elementos que contiene un array","text":"<p>Cuando utilizamos arrays, es muy molesto contar los elementos de un array para saber su tama\u00f1o. Afortunadamente, todo objeto de tipo array tiene una variable de instancia llamada length que contiene el tama\u00f1o del array, es decir, el n\u00famero de celdas.</p>"},{"location":"ud4/2usefularrays/#imprimir-los-elementos-de-un-array","title":"Imprimir los elementos de un array","text":"<p>Un algoritmo muy utilizado cuando trabajamos con arrays es mostrar los valores que contiene el array en cada una de sus celdas. Para ello nos ayudamos del campo length que nos devuelve la longitud del array.</p> <pre><code>public static void imprimirArray(int[] array) {\nfor(int i = 0; i &lt; array.length; i++) {\nSystem.out.println(\"Elemento \" + i + \" valor \" + array[i]);\n}\n}\n</code></pre>"},{"location":"ud4/2usefularrays/#leer-y-rellenar-los-elementos-de-un-array-por-teclado","title":"Leer y rellenar los elementos de un array por teclado","text":"<p>Es muy com\u00fan que los elementos de un array sean valores introducidos de alguna forma por el usuario. El ejemplo m\u00e1s sencillo es leerlos directamente desde la entrada de flujo, a la vez que leemos el valor insertado por el usuario se lo asignamos al array.</p> <pre><code>    int[] array = new int[elementos];\n\nfor (int i = 0; i &lt; array.length; i++) {\narray[i] = sc.nextInt();\n}\n</code></pre>"},{"location":"ud4/2usefularrays/#algoritmo","title":"Algoritmo","text":"<p>Cualquier procedimiento sistem\u00e1tico utilizado para calcular algo se llama algoritmo. Por ejemplo si queremos sumar todos los elementos de un array realizaremos un algoritmo. Un algoritmo es una descripci\u00f3n de c\u00f3mo hacer algo. No est\u00e1 vinculado a ning\u00fan idioma en particular. Un algoritmo se puede implementar en cualquier lenguaje de programaci\u00f3n de computadoras.</p> <p>El programa siguiente muestra un ejemplo de un algoritmo. Aqu\u00ed la variable suma juega el papel de almacenar la suma de los elementos que se van leyendo. El programa recorre elementos del array comenzando en el \u00edndice 0 y yendo hasta el final.</p> <pre><code>    public static int suma(int[] array) {\nint suma = 0;\nfor (int i = 0; i &lt; array.length; i++) {\nsuma += array[i];\n}\nreturn suma;\n}\n</code></pre>"},{"location":"ud4/2usefularrays/#clasico-error-1-no-testear-los-limites-del-array","title":"Cl\u00e1sico error 1: no testear los l\u00edmites del array","text":"<p>Cuando trabajamos con arrays, a menudo nos puede ocurrir que olvidamos el \u00faltimo elemento del array, si cambiamos la condici\u00f3n del bucle por i &lt; array.length -1, o olvidamos el primer elemento si establecemos el \u00edndice en  int i = 1 porque creemos que el primer elemento est\u00e1 en la posici\u00f3n 1 del array.</p> <p>Estos son errores cl\u00e1sicos: no probar los l\u00edmites de los arrays, es decir, el primer elemento o el \u00faltimo.</p> <p>Por ejemplo, en el siguiente c\u00f3digo no quiero tener n\u00fameros de una cifra en mi array.</p> <pre><code>    int[] array =  {2, 19, 1, 5, 1, 27, 9, 5};\n\nfor (int i = 0; i &lt; array.length-1; i++) {\nif (array[i] &lt; 10)\narray[i] = array[i] * 10;\n}\n</code></pre> <p>Cuando recorro el array, el \u00faltimo elemento no ser\u00eda testeado por tanto me devolver\u00eda un 5 en vez de 50. El programa ser\u00eda incorrecto.</p>"},{"location":"ud4/2usefularrays/#clasico-error-2-exceder-los-limites-del-array","title":"Cl\u00e1sico error 2: exceder los l\u00edmites del array","text":"<p>Al contrario que, en el apartado anterior, si intentamos acceder a una celda del array que no existe, se lanzar\u00e1 una ArrayIndexOutOfBoundsException y el programa se detendr\u00e1.</p> <p>Los errores de acceso a la \u00faltima posici\u00f3n del array + 1 son muy comunes. Un ejemplo ser\u00eda:</p> <pre><code>    int[] array =  {2, 19, 1, 5, 1, 27, 9, 5};\n\nfor (int i = 0; i &lt;= array.length; i++) {\nif (array[i] &lt; 10)\narray[i] = array[i] * 10;\n}\n</code></pre>"},{"location":"ud4/2usefularrays/#bucle-foreach-enhanced-for-loop","title":"Bucle foreach (enhanced for loop)","text":"<p>Para evitar que los errores mencionados anteriormente ocurran, Java dispone de un bucle mejorado que visita cada elemento del array en orden sin necesidad de establecer un \u00edndice. Por tanto, los errores de exceder los l\u00edmites del array se eliminan autom\u00e1ticamente con este bucle.</p> <p>La sintaxis es la siguiente:</p> <p></p> <p>Este bucle de lee en voz alta de la siguiente manera: \"para cada valor del array...\" (for each value in array...)</p> <p>El tipo de dato de la variable que se crea en el bucle es igual al de cada una de las celdas del array, y va a contener los valores de ellas. En la primera iteraci\u00f3n contrendr\u00e1 el valor de la primera celda del array, y as\u00ed sucesivamente hasta llegar a la \u00faltima celda del array.</p> <p>Ejemplo:</p> <pre><code>    int[] array =  {2, 19, 1, 5, 1, 27, 9, 5};\nint suma = 0;\nfor (int numero : array) {\nsuma += numero;\n}\n</code></pre>"},{"location":"ud4/2usefularrays/#comparar-si-dos-arrays-son-iguales","title":"Comparar si dos arrays son iguales","text":"<p>Es muy usual utilizar el operador \"==\" cuando queremos comparar si dos arrays son iguales, es decir, si contienen los mismos elementos. Pero si ejecutamos el siguiente c\u00f3digo:</p> <pre><code>    int[] array1 =  {1, 2, 3};\nint[] array2 =  {1, 2, 3};\n\nSystem.out.println(array1 == array2); //imprime false\n</code></pre> <p>Obtenemos false, esta situaci\u00f3n es parecida a cuando intent\u00e1bamos comparar dos String. Recordar que utilizar el operador \"==\" era incorrecto ya que son objetos diferentes aunque tuvieran el mismo contenido.</p> <p>Si utilizamos el m\u00e9todo equals() para arrays, devolver\u00eda el mismo valor booleano que el operador \"==\".</p> <pre><code>    System.out.println(array1.equals(array2)); //imprime false\n</code></pre> <p>Para comprobar que dos arrays contienen los mismos elementos se utiliza la clase Arrays.</p> <p>La clase Arrays contiene muchos m\u00e9todos est\u00e1ticos para manipular matrices. Dado que los m\u00e9todos son est\u00e1ticos, los invoca utilizando el nombre de la clase.</p> <pre><code>    int[] array1 =  {1, 2, 3};\nint[] array2 =  {1, 2, 3};\n\nSystem.out.println(Arrays.equals(array1, array2)); //imprime true\n</code></pre> <p>El m\u00e9todo Arrays.equals comprueba que dos arrays son iguales si tienen la misma longitud y contienen los mismos elementos en el mismo orden.</p>"},{"location":"ud4/3referencetypearrays/","title":"Tipos de referencia vs tipos de valor","text":"<p>Sabemos que los tipos de datos primitivos como int, double, etc. son tipos de datos primitivos, es decir, son tipos de valor ya que almacenan valores.</p> <p>A diferencia de \u00e9stos, los arrays son tipos de referencia como tambi\u00e9n los son los String.</p> <p>Cuando creamos una variable de tipo valor, se asigna un solo espacio en la memoria para almacenar su valor y esa variable contiene directamente el valor.</p> <p>Si creamos otra variable y le asignamos esa variable como se ve en el siguiente c\u00f3digo:</p> <pre><code>    int variable = 2;\nint otraVariable = variable;//asignamos un 2 a otraVariable\n\notraVariable = 5;\n\nSystem.out.println(variable);//imprime 2\nSystem.out.println(otraVariable);//imprime 5\n</code></pre> <p>El valor es copiado directamente y ambas variables trabajan independientemente. Cada una tiene su propia copia del valor espec\u00edfico, en este caso 2.</p> <p>Ahora bien, tipos de referencia, como clases o arrays trabajan de forma diferente. Utilizamos la palabra new para crear un nuevo objeto.</p> <pre><code>    int[] array = new int[5];\n</code></pre> <p>En este caso, tenemos una referencia a un array. Los tipos de referencia son usados por una referencia. Por lo tanto, una referencia contiene una referencia o una direcci\u00f3n de objeto pero no el objeto en s\u00ed.</p> <p>En el ejemplo anterior, la variable array contiene una referencia o direcci\u00f3n al array en la memoria.</p> <p>Con los tipos de referencia, usamos una referencia para controlar el objeto en memoria, no podemos acceder al objeto directamente.</p> <p>Una referencia es como una direcci\u00f3n de alg\u00fan objeto en memoria.</p> <pre><code>    int[] array = new int[5];\nint[] otroArray = array;\n</code></pre> <p>En el c\u00f3digo anterior, hemos declarado otroArray que es una referencia al mismo array en memoria. Es decir, ahora tenemos dos referencias apuntando al mismo array en memoria. O dicho de otra forma, tanto array como otroArray contienen la misma direcci\u00f3n en memoria.</p> <p>Como se puede observar, una forma de saber si es de tipo de referencia es con el operador new, ya que este crea un nuevo objeto en memoria.</p> <p>Para imprimir el contenido de un array, podemos usar un m\u00e9todo integrado en Java en la clase <code>Arrays.toString</code>. Este m\u00e9todo imprime el contenido del array en una sola l\u00ednea separando los elementos con comas.</p> <pre><code>    int[] array = new int[5];\nint[] otroArray = array;\n\nSystem.out.println(Arrays.toString(array));\nSystem.out.println(Arrays.toString(otroArray));\n</code></pre> <p>Ahora mismo, los arrays est\u00e1n vac\u00edos por tanto se imprime todo con valores 0. Vamos a ver que ocurre si modificamos un valor en el array otroArray.</p> <pre><code>    int[] array = new int[5];\nint[] otroArray = array;\n\nSystem.out.println(Arrays.toString(array));\nSystem.out.println(Arrays.toString(otroArray));\n\notroArray[0] = 3;\n\nSystem.out.println(Arrays.toString(array));\nSystem.out.println(Arrays.toString(otroArray));\n</code></pre> <p>Si ejecutamos el c\u00f3digo, veremos que ambos arrays han cambiado. Esto ocurre porque las dos variables apuntan al mismo array en memoria. Solo hay una copia del array en la memoria. Las dos variables contienen la direcci\u00f3n que apunta al array en memoria.</p> <p></p> <p>Para desreferenciar un array y que apunte a otro array en memoria tenemos que usar el operador new:</p> <pre><code>    int[] array = new int[5];\nint[] otroArray = array;\n\nSystem.out.println(Arrays.toString(array));\nSystem.out.println(Arrays.toString(otroArray));\n\narray = new int[]{1, 2, 3};\notroArray[0] = 3;\n\nSystem.out.println(Arrays.toString(array));\nSystem.out.println(Arrays.toString(otroArray));\n</code></pre>"},{"location":"ud4/3referencetypearrays/#metodos-paso-por-referencia","title":"M\u00e9todos: paso por referencia","text":"<p>Recuerda que Java usa llamada por valor para pasar datos a m\u00e9todos, esto es que env\u00eda una copia del dato, por tanto cualquier modificaci\u00f3n de la copia dentro del m\u00e9todo no afecta al original. Con par\u00e1metros de tipo array es diferente. Si pasamos a un m\u00e9todo el array, ya que le estamos pasando la referencia al array, crear\u00eda una nueva variable dentro del m\u00e9todo pero \u00e9sta apuntar\u00eda al mismo array en memoria. Cualquier modificaci\u00f3n dentro del m\u00e9todo en el array se ver\u00eda fuera del m\u00e9todo puesto que solo hay un objeto array en memoria.</p>"},{"location":"ud4/4arrayobjects/","title":"Array de objetos","text":"<p>Una caracter\u00edstica importante de los arrays, es que todos los elementos deben ser del mismo tipo.</p> <p>Hasta ahora, hemos estudiado arrays con elementos de tipos primitivos. Sin embargo, tambi\u00e9n se puede crear arrays con elementos de cualquier tipo de datos, incluidas las referencias a objetos.</p> <p>Recordemos que, cuando hacemos <code>String str;</code>, se declara una variable llamada <code>str</code> que almacena la referencia a un objeto de tipo String, pero el objeto todav\u00eda no ha sido creado.</p> <p>Un objeto existe solo despu\u00e9s de haber sido construido. Los objetos se construyen solo mientras se ejecuta un programa cuando se invoca el constructor.</p> <p>Una vez construido, se accede a un objeto siguiendo una referencia al objeto. A menudo, la referencia se mantiene en una variable de referencia como <code>str</code>.</p> <p>En el siguiente ejemplo, se declara una variable de referencia, se construye un objeto y luego la referencia al objeto se coloca en la variable de referencia:</p> <pre><code>String str;             // declara una variable de tipo referencia\nstr = \"Hello World\" ;   // construye el objeto y \n// almacena su referencia\n</code></pre> <p></p>"},{"location":"ud4/4arrayobjects/#array-de-strings","title":"Array de Strings","text":"<p>Para declarar un array de Strings ser realizar\u00eda de la siguiente forma:</p> <pre><code>String[] array = new String[5];\n\narray[0] = \"Hello\";\narray[1] = \"World\";\n...\n</code></pre> <p></p> <p>Cada objeto String del ejemplo es un String normal. Nada en \u00e9l ha cambiado porque su referencia se mantiene en el array. Cada cadena puede tener cualquier n\u00famero de caracteres.</p>"},{"location":"ud4/4arrayobjects/#argumentos-de-linea-de-comandos","title":"Argumentos de l\u00ednea de comandos","text":"<p>Como ya sabemos el m\u00e9todo <code>main</code> recibe un array de Strings como par\u00e1metro:</p> <pre><code>    public static void main(String[] args) {\n}\n</code></pre> <p>Es decir, main recibe una referencia a un array de referencias de String. Este array es construido por el sistema Java justo antes de que <code>main()</code> obtenga el control. Los elementos que contiene el array son cadenas de texto que se pasan en la l\u00ednea de comando que inicia el programa. Por ejemplo, digamos que un programa se inicia con esta l\u00ednea de comando:</p> <p>java Demo cadena1 cadena1</p> <p>Donde <code>Demo</code> es el nombre del programa, <code>cadena1</code> es el primer argumento y <code>cadena2</code> el segudno.</p> <p>Por tanto <code>args[0]</code> contendr\u00e1 cadena1 y <code>args[1]</code> cadena2.</p> <p>Puede haber cualquier n\u00famero de argumentos en la l\u00ednea de comandos. Los argumentos son siempre cadenas de caracteres. Cada argumento est\u00e1 separado del resto por espacios.</p> <p>A veces, se quieren enviar n\u00famero por l\u00ednea de comandos. Por tanto necesitaremos convertir las cadenas de d\u00edgitos en n\u00fameros. Para ello, utilizaremos el m\u00e9todo <code>Integer.parseInt(String)</code> o <code>Double.parseDouble(String)</code>.</p>"},{"location":"ud4/4arrayobjects/#espacio-de-memoria-en-arrays-de-objetos","title":"Espacio de memoria en arrays de objetos","text":"<p>Como hemos comentado, en arrays de objetos, Java almacena solo la referencia al objeto en el propio array, en lugar de todo el objeto. Esto conserva la memoria, ya que las referencias requieren solo 4 bytes cada una, mientras que cada objeto puede requerir cientos de bytes.</p> <p>Ejemplo, para un array de 15 enteros, sabiendo que cada entero requiere 4 bytes de almacenamiento, se almacenar\u00e1 60 bytes contiguos de memoria.</p>"},{"location":"ud4/5sortarrays/","title":"Algoritmos de ordenaci\u00f3n","text":"<p>La ordenaci\u00f3n es una de las t\u00e9cnicas fundamentales que se utilizan en la resoluci\u00f3n de problemas, especialmente en los relacionados con la escritura y la implementaci\u00f3n de algoritmos eficientes.</p> <p>Por lo general, la ordenaci\u00f3n se combina con la b\u00fasqueda, lo que significa que primero ordenamos los elementos de la colecci\u00f3n dada, luego buscamos algo dentro de ella, ya que generalmente es m\u00e1s f\u00e1cil buscar algo en una colecci\u00f3n ordenada, en lugar de sin ordenar.</p> <p>Ordenar un array es el proceso de ordenar sus elementos en orden ascendente o descendente. Los algoritmos de ordenaci\u00f3n se encuentran entre los algoritmos m\u00e1s utilizados en computaci\u00f3n.</p>"},{"location":"ud4/5sortarrays/#bubble-sort-burbuja","title":"Bubble sort (Burbuja)","text":"<p>Funciona intercambiando elementos adyacentes si no est\u00e1n en el orden deseado. Este proceso se repite desde el principio del array hasta que todos los elementos est\u00e1n en orden.</p> <p>Sabemos que todos los elementos est\u00e1n en orden cuando logramos hacer toda la iteraci\u00f3n del array sin intercambiar ning\u00fan elemento en absoluto; entonces, todos los elementos que comparamos estaban en el orden deseado con sus elementos adyacentes y, por extensi\u00f3n, todo el array.</p> <p>Ejemplo:</p> <pre><code>[4, 2, 1, 5, 3] - Paso 1: como 4 &gt; 2, los intercambiamos \n[2, 4, 1, 5, 3] - Paso 2: como 4 &gt; 1, los intercambiamos\n[2, 1, 4, 5, 3] - Paso 3: como no se cumple 4 &gt; 5, los dejamos igual\n[2, 1, 4, 5, 3] - Paso 4: como 5 &gt; 3, los intercambiamos\n[2, 1, 4, 3, 5] - Este es el resultado del array despu\u00e9s de la primera iteraci\u00f3n del bucle externo.\n</code></pre> <p>Como al menos se produjo un intercambio durante la primera iteraci\u00f3n (en realidad hubo tres), debemos revisar todo el array otra vez y repetir el mismo proceso.</p> <p>Repetiremos este proceso, hasta que no se realicen m\u00e1s intercambios, que ser\u00e1 cuando tengamos el array ordenado.</p> <p>La raz\u00f3n por la que este algoritmo se llama Bubble sort es porque los n\u00fameros \"burbujean\" hasta la \"superficie\".</p> <p>Si seguimos haciendo trazas en el ejemplo, siguiendo un n\u00famero en particular (4 es un gran ejemplo), ver\u00e1s que se mueve lentamente hacia la derecha durante el proceso.</p>"},{"location":"ud4/5sortarrays/#complejidad-temporal","title":"Complejidad temporal","text":"<p>Para calcular la complejidad temporal de Bubble Sort, necesitamos mirar el peor escenario posible. \u00bfCu\u00e1l es la cantidad m\u00e1xima de veces que necesitamos pasar por todo el array antes de ordenarlo?</p> <p>El peor escenario ser\u00eda <code>[5, 4, 3, 2, 1]</code>. En la primera iteraci\u00f3n, 5 \"burbujear\u00e1 hasta la superficie\", pero el resto de los elementos permanecer\u00e1n en orden descendente. Tendr\u00edamos que hacer una iteraci\u00f3n para cada elemento excepto 1, y luego otra iteraci\u00f3n para verificar que todo est\u00e9 en orden, por lo que un total de 5 iteraciones.</p> <p>Si pensamos en un array de n elementos, eso significa que necesitamos hacer n iteraciones.</p> <p>Cada una de esas n veces estamos iterando a trav\u00e9s de todo el array, lo que significa que la complejidad temporal en el peor de los casos ser\u00eda Big-O: O(n^2).</p>"},{"location":"ud4/5sortarrays/#counting-sort","title":"Counting sort","text":"<p>El ordenamiento por conteo es un algoritmo de ordenamiento que ordena los elementos de un array contando el n\u00famero de apariciones de cada elemento \u00fanico en el array. El recuento se almacena en un array auxiliar y la ordenaci\u00f3n se realiza mapeando la cuenta como un \u00edndice del array auxiliar.</p>"},{"location":"ud4/5sortarrays/#como-funciona","title":"\u00bfC\u00f3mo funciona?","text":"<ol> <li>Encuentra el elemento m\u00e1ximo <code>max</code> del array dado. </li> <li>Crea un array de longitud <code>max + 1</code> con todos los elementos a 0. Este array se utiliza para almacenar el recuento de los elementos del array. </li> <li>Almacena el recuento de cada elemento en su \u00edndice respectivo en el array de recuento. Por ejemplo: si el elemento 3 aparece 2 veces en el array, entonces 2 se almacena en la tercera posici\u00f3n del array de recuentos. Si el elemento \"5\" no est\u00e1 presente en el array, entonces 0 se almacena en la quinta posici\u00f3n. </li> <li>Almacena la suma acumulativa de los elementos del array de recuentos. Es \u00fatil colocar los elementos en el \u00edndice correcto del array ordenado. </li> <li>Encuentra el \u00edndice de cada elemento del array original en el array de conteo. Esto da el recuento acumulativo. Coloca el elemento en el \u00edndice calculado como se muestra en la figura siguiente. </li> <li>Despu\u00e9s de colocar el elemento en la posici\u00f3n correcta del array ordenado, disminuye el array de recuento para ese \u00edndice en uno.</li> </ol>"},{"location":"ud4/5sortarrays/#complejidad","title":"Complejidad","text":"<p>La complejidad temporal en el peor caso es Big-O: O(n).</p>"},{"location":"ud4/6searcharrays/","title":"Algoritmos de b\u00fasqueda","text":"<p>Supongamos que tenemos un array de grandes dimensiones y necesitamos encontrar uno de sus elementos. Necesitamos un algoritmo para buscar en el array un valor particular, generalmente llamado <code>clave</code>. Si los elementos del array no est\u00e1n organizados en ning\u00fan orden en particular, la \u00fanica forma en que podemos estar seguros de encontrar la clave, asumiendo que est\u00e1 en el array, es buscar cada elemento, comenzando por el primer elemento, hasta encontrarlo. Este algoritmo es conocido como b\u00fasqueda lineal o secuencial.</p>"},{"location":"ud4/6searcharrays/#busqueda-secuencial","title":"B\u00fasqueda secuencial","text":"<p>En la b\u00fasqueda secuencial, cada elemento del array se examinar\u00e1 en secuencia hasta que se encuentre la clave (o se llegue al final del array).</p>"},{"location":"ud4/6searcharrays/#algoritmo-busqueda-secuencial","title":"Algoritmo b\u00fasqueda secuencial","text":"<p>Este algoritmo se puede implementar f\u00e1cilmente en un m\u00e9todo que busca un array de enteros, que se pasa como par\u00e1metro del m\u00e9todo y la <code>clave</code> a buscar. Si la <code>clave</code> se encuentra en el array, se devuelve su ubicaci\u00f3n. Si no se encuentra, se devuelve <code>\u22121</code> para indicar fallo.</p> <pre><code>public class Search {\n\npublic static int sequentialSearch(int[] array, int key) {\nfor (int i = 0; i &lt; array.length; i++) {\nif (array[i] == key) {\nreturn i;\n}\n}\nreturn -1; //no lo ha encontrado\n}\n\n}\n</code></pre> <p>Big O notation es una notaci\u00f3n para representar la complejidad temporal de un algoritmo, su rendimiento. Generalmente describe el peor escenario, es decir, el m\u00e1ximo tiempo en la mayor cantidad de repeticiones que el algoritmo tiene que ejecutar.</p> <ul> <li>Big-O de una b\u00fasqueda secuencial es O(n) en el peor de los casos y O(1) en el mejor.</li> </ul>"},{"location":"ud4/6searcharrays/#busqueda-binaria","title":"B\u00fasqueda binaria","text":"<p>La b\u00fasqueda binaria es un algoritmo de b\u00fasqueda para encontrar la posici\u00f3n de un elemento en un array ordenado.</p> <p>La b\u00fasqueda binaria solo se puede implementar en una lista ordenada de elementos. Si los elementos no est\u00e1n ordenados, primero debemos ordenarlos.</p> <p>El algoritmo de b\u00fasqueda binaria se puede implementar de dos formas diferentes:</p> <ol> <li>M\u00e9todo iterativo</li> <li>M\u00e9todo recursivo. El m\u00e9todo recursivo sigue el enfoque de divide y vencer\u00e1s.</li> </ol>"},{"location":"ud4/6searcharrays/#como-se-hace","title":"\u00bfC\u00f3mo se hace?","text":"<ol> <li>El array en el que se va a realizar la b\u00fasqueda es. Sea <code>x = 4</code> el elemento a buscar. </li> <li>Establezce dos punteros <code>low</code> y <code>high</code> en las posiciones m\u00e1s baja y m\u00e1s alta, respectivamente. </li> <li>Encuentra el elemento del medio <code>mid</code> en la mitad del array, es decir, <code>mid = (low + high)/2; array[mid] = 6</code>. </li> <li>Si <code>x == array[mid]</code>, devuelve <code>mid</code>. De lo contrario, compara el elemento que se va a buscar con <code>m</code>.</li> <li>Si <code>x &gt; array[mid]</code>, comparamos <code>x</code> con el elemento medio de los elementos en el lado derecho de <code>mid</code>. Esto se hace estableciendo <code>low</code> a <code>low = mid + 1</code>.</li> <li>De lo contrario, comparamos <code>x</code> con el elemento central de los elementos en el lado izquierdo de <code>mid</code>. Esto se hace estableciendo <code>high</code> a <code>high = mid - 1</code>. </li> <li>Repetimos los pasos 3 a 6 mientras que <code>low</code> sea menor igual que <code>high</code>. </li> <li><code>x = 4</code> se ha encontrado.</li> </ol> <p>Al m\u00e9todo se le pasa el <code>array</code>, la <code>clave</code>, y las posiciones <code>low</code> y <code>high</code>.</p> <ul> <li>Big-O para la b\u00fasqueda binaria es O(log N) en el peor de los casos y O(1) en el mejor caso.</li> </ul>"},{"location":"ud4/7twodimensionarray/","title":"Arrays multidimensionales","text":"<p>Un array bidimensional o matriz, es un array cuyos componentes son ellos mismos arrays, y es necesario o \u00fatil para ciertos tipos de problemas. Por ejemplo, imagina una clase de 7 estudiantes que tienen un examen cada semana durante 5 semanas. El profesor registra las calificaciones en una tabla. Una celda particular de la tabla se designa por n\u00famero de estudiante y n\u00famero de semana.</p> <p>En Java, una tabla se puede implementar como una matriz 2D. Cada celda de la matriz es una variable que puede contener un valor y funciona como cualquier variable. Al igual que con los arrays unidimensionales, todas las celdas de una matriz 2D son del mismo tipo. El tipo puede ser un tipo primitivo o un tipo de referencia de objeto.</p> <p>Importante: cada celda de la matriz se especifica con un n\u00famero de fila y columna, en ese orden.</p> <p><code>matriz[fila][col]</code></p> <p>Al igual que con los arrays unidimensionales, los \u00edndices comienzan en cero.</p> <p></p> <p>Para acceder a la posici\u00f3n 0,2 lo har\u00edamos con <code>matriz[0][2]</code> y esto devuelve el entero 4.</p> <p>Al igual que con una matriz 1D o un arrar, un \u00edndice de matriz puede ser un literal entero, una variable de tipo entero, un m\u00e9todo que se eval\u00faa como un n\u00famero entero o una expresi\u00f3n aritm\u00e9tica que involucra todas estas cosas:</p> <pre><code>matriz[3][j] = 34;\n\nsuma = matriz[i][j] + suma[i][j + 1];\n\nvalue = matriz[2][someFunction()];\n\nmatriz[1][0] = matriz[i + 3][algunaFunci\u00f3n() - 2];\n</code></pre>"},{"location":"ud4/7twodimensionarray/#declaracion-de-un-array-2d-o-matriz-2d","title":"Declaraci\u00f3n de un array 2D o matriz 2D","text":"<p>Recordamos que al igual que los arrays unidimensionales, las matrices bidimensionales son objetos. Para declara un array bidimensional se puede crear una lista. La lista debe contener las filas cada una separada por una coma; y cada fila es una lista de valores.</p> <p>Ejemplo:</p> <pre><code>int[][] myArray = { {8,1,2,2,9}, {1,9,4,0,3}, {0,3,0,0,7} };\n\n//tambi\u00e9n se puede hacer as\u00ed\nint[][] matriz = new int[5][7];//inicializa todo a 0s\n</code></pre> <p>Cada fila de una matriz 2D puede tener un n\u00famero diferente de celdas.</p> <p>Si un programa intenta acceder a una celda que no existe, se lanzar\u00e1 una excepci\u00f3n (que generalmente detendr\u00e1 su programa). Hacer una asignaci\u00f3n a una celda que no existe es un error.</p>"},{"location":"ud4/7twodimensionarray/#longitud-de-una-matriz-2d","title":"Longitud de una matriz 2D","text":"<p>La longitud de una matriz 2D es el n\u00famero de filas que tiene. Se puede adivinar que \"longitud\" podr\u00eda definirse como un par de n\u00fameros (filas, columnas). Pero el n\u00famero de columnas puede variar de una fila a otra, por lo que esto no funcionar\u00e1. Sin embargo, el n\u00famero de filas no cambia, por lo que funciona como una longitud.</p> <p>Cada fila de una matriz 2D puede tener un n\u00famero diferente de celdas (columnas), por lo que cada fila tiene su propia longitud.</p>"},{"location":"ud4/7twodimensionarray/#entender-mejor-los-arrays-o-matrices-2d","title":"Entender mejor los arrays o matrices 2D","text":"<p>Un array bidimensional se implementa como un array unidimensionales. La declaracion</p> <p><code>int [][] myArray;</code> // 1.</p> <p></p> <p>declara una variable llamada <code>myArray</code> que en el futuro puede hacer referencia a un objeto de matriz. En este punto, no se ha dicho nada sobre el n\u00famero de filas o columnas.</p> <p>Para crear una matriz de 3 filas, har\u00edamos:</p> <p><code>myArray = new int [3][];</code> // 2.</p> <p></p> <p>Ahora <code>myArray</code> hace referencia a un objeto de matriz. El objeto de matriz tiene 3 celdas. Cada celda puede hacer referencia (en el futuro) a una matriz de int, un objeto int []. Sin embargo, ninguna de las celdas se refiere todav\u00eda a un objeto. Se inicializan a nulo.</p> <p>Una forma de crear la fila 0 es esta:</p> <p><code>myArray[0] = new int [3];</code> // 3.</p> <p></p> <p>Esto crea un objeto array 1D y coloca su referencia en la celda 0 de myArray. Las celdas del array 1D se inicializan a 0.</p> <p>Una matriz o array 1D construida previamente se puede asignar a una fila:</p> <pre><code>int[] x = {0, 2};\nint[] y = {0, 1, 2, 3, 4};\n\nmyArray [1] = x;\nmyArray [2] = y; // 4.\n</code></pre> <p></p> <p>No es necesario que las filas tengan el mismo n\u00famero de celdas.</p> <p>Las declaraciones anteriores construyen la matriz 2D paso a paso.</p>"},{"location":"ud4/7twodimensionarray/#como-se-podrian-reemplazar-las-celdas-individuales-de-cada-fila-dentro-de-una-matriz","title":"\u00bfC\u00f3mo se podr\u00edan reemplazar las celdas individuales de cada fila dentro de una matriz?","text":"<p>Si quisieras reemplazar la fila uno del ejemplo anterior con la siguiente sentencia:</p> <p><code>myArray [0] = {1, 9, 4};</code> No funcionar\u00e1.</p> <p>Una lista de inicializadores entre llaves { } solo se puede usar para inicializar una matriz, no para asignarle valores despu\u00e9s de que ya se ha creado y existe.</p> <p>Si has pensado en hacer algo as\u00ed:</p> <pre><code>int[] x = {1, 9, 4}; // declarar e iniciar x\nmyArray [0] = x; // asignar a myArray\n</code></pre> <p>Esto si funcionar\u00eda, pero no har\u00edamos exactamente lo que se pidi\u00f3 en la pregunta. Es decir, de esta forma reemplazar\u00edamos la antigua fila 0 con una nueva fila. Lo que hacemos es construir un nuevo objeto de matriz 1D (un array) que contiene los valores deseados en sus celdas y luego asigna ese objeto a la fila 0 de <code>myArray</code>. La fila 0 anterior ahora es basura.</p> <p>Lo correcto ser\u00eda recorrer la fila 0 y reemplazar el valor de cada celda.</p> <p></p>"},{"location":"ud5/1herencia/","title":"Herencia","text":"<p>Cuando tenemos una clase con una serie de caracter\u00edsticas  y nuestro programa se actualiza o amplia, tal vez se necesita de una clase con unas caracter\u00edsticas similares, como por ejemplo, Ordenador, posee un ram, cpu, tama\u00f1o de disco, etc.</p> <p>Si ahora queremos a\u00f1adir la clase Tablet Android en nuestro sistema, como posee todas esas caracter\u00edsticas de ordenador adem\u00e1s de algunas espec\u00edficas, copiar\u00edamos todo lo que hay en ordenador y agregar\u00edamos lo que fuera espec\u00edfico para Tablet. Lo mismo tendr\u00edamos que realizar si a\u00f1adi\u00e9ramos P\u00f3rtatil Mac. Como te habr\u00e1s dado cuenta, este proceso genera mucho c\u00f3digo repetido. Y arreglar un error en \u00e9l puede ser tambi\u00e9n complicado. Para ello utilizamos la herencia.</p> <p>\u00bfC\u00f3mo se relacionan las clases entre s\u00ed? En Java, y en cualquier otro lenguaje orientado a objetos, las clases se organizan en una jerarqu\u00eda de clases. Una jerarqu\u00eda de clases es como un \u00e1rbol al rev\u00e9s. En lo m\u00e1s alto de la jerarqu\u00eda se encuentra la clase m\u00e1s general, en Java, la clase <code>Object</code>. Las clases debajo de <code>Object</code> en la jerarqu\u00eda se conocen como sus subclases. Dado que todos los objetos que usamos en nuestros programas pertenecen a una clase u otra, esto es como decir que todos los objetos son <code>Object</code>.</p> <p></p> <p>En Java, todas las clases heredan de la clase <code>java.lang.Object</code>. La Figura muestra el concepto de jerarqu\u00eda de clases. Observa que la clase <code>Object</code> se encuentra en la parte superior de la jerarqu\u00eda. Es la clase m\u00e1s generalizada. Tiene caracter\u00edsticas que son comunes a todos los objetos Java. A medida que desciende en la jerarqu\u00eda, las clases se vuelven cada vez m\u00e1s espec\u00edficas. Un rect\u00e1ngulo es un objeto, pero contiene atributos (largo y ancho) que son comunes a todos los rect\u00e1ngulos, pero no a otros objetos de la jerarqu\u00eda. Por ejemplo, un objeto <code>Vehicle</code> no tiene necesariamente una longitud y una anchura.</p> <p>Tambi\u00e9n est\u00e1 la clase <code>Square</code> en la jerarqu\u00eda. Un <code>Square</code> (cuadrado) es un tipo especial de rect\u00e1ngulo, es decir, uno cuyo largo es igual a su ancho.</p> <p>Usando la terminolog\u00eda asociada con este tipo de jerarqu\u00eda, decimos que la clase <code>Rectangle</code> es una subclase de la clase <code>Object</code>. La clase <code>Square</code> es una subclase de <code>Rectangle</code> y <code>Object</code>. Se dice que las clases que se encuentran por encima de una clase dada en la jerarqu\u00eda son sus superclases.</p> <p>Por lo tanto, la clase <code>Rectangle</code> y tambi\u00e9n <code>Object</code> es una superclase de la clase <code>Square</code>.</p> <p>En general, decimos que una subclase extiende una superclase, lo que significa que agrega elementos adicionales (atributos y / o m\u00e9todos) a los contenidos en sus superclases. Como el caso de la clase <code>Square</code> que agrega la caracter\u00edstica de que su largo y ancho son siempre iguales.</p> <p>Hay tres conjuntos de terminolog\u00eda para describir las relaciones de herencia:</p> <ul> <li>padre / hijo</li> <li>clase base / clase derivada</li> <li>superclase / subclase</li> </ul> <p></p> <p>El concepto importante asociado con una jerarqu\u00eda de clases es la noci\u00f3n de herencia de clases, mediante la cual una subclase hereda elementos (atributos y / o m\u00e9todos, excepto el constructor) de sus superclases.</p> <p>Nota</p> <p>Los atributos y m\u00e9todos declarados como <code>private</code> se dice que no se heredan porque su visibilidad es privada y no se puede acceder desde la clase hija, pero si son heredados.</p> <p>Un t\u00e9rmino muy usado en herencia es reutilizaci\u00f3n. Como el propio nombre dice, reutilizar el c\u00f3digo repetido en los programas. Es un mecanismo para reutilizar el c\u00f3digo existente cuando creamos clases heredadas.</p> <p>Para ilustrar c\u00f3mo funciona la herencia pensemos en un ajedrez. Hay varios tipos diferentes de piezas de ajedrez. Hay peones, caballeros, reinas y reyes. Un par de atributos que todas las piezas de ajedrez tienen en com\u00fan es su posici\u00f3n de fila y columna en el tablero de ajedrez. Debido a que todas las piezas de ajedrez tienen estos atributos en com\u00fan, habr\u00e1 una clase en la jerarqu\u00eda superior llamada <code>PiezaAjedrez</code> con estos atributos que ser\u00e1n heredados por todas las subclases de <code>PiezaAjedrez</code>.</p> <p>Una de las acciones que todas las piezas de ajedrez tienen en com\u00fan es que pueden moverse a una casilla determinada del tablero de ajedrez. Pero los diferentes tipos de piezas de ajedrez tienen diferentes formas de moverse. Por ejemplo, un alfil solo puede moverse a lo largo de diagonales en el tablero de ajedrez, mientras que una torre solo puede moverse a lo largo de una fila o columna en el tablero de ajedrez. Entonces, claramente, no podemos describir un m\u00e9todo <code>moveTo()</code> que funcione para todas las piezas de ajedrez. Es por eso que colocamos el m\u00e9todo <code>moveTo()</code> en todas las subclases de <code>PiezaAjedrez</code>. La clase <code>PiezaAjedrez</code> tambi\u00e9n tiene un m\u00e9todo <code>moveTo()</code>, pero tenga en cuenta que su nombre est\u00e1 en cursiva. Esto indica que no se puede definir completamente a ese nivel.</p> <p>En el ajedrez, el rey tiene ciertos atributos y acciones especiales. Por tanto, s\u00f3lo el rey puede ser puesto bajo control. Esto significa que el rey est\u00e1 siendo atacado y en peligro de ser capturado, poniendo fin al juego. Del mismo modo, solo el rey tiene la capacidad de enrocar. Este es un movimiento especial que un rey puede realizar junto con una de sus torres bajo ciertas condiciones. Por lo tanto, la clase <code>Rey</code> tiene ciertas caracter\u00edsticas particulares.</p> <p></p> <p>En los diagramas, la flecha apunta del hijo al padre y muestra la relaci\u00f3n \"es-un\". La flecha apunta a la clase principal de la clase secundaria. La imagen se puede leer como \"un rey es una pieza de ajedrez\".</p> <p>Como vemos, una jerarqu\u00eda de clases representa una especializaci\u00f3n de clases a medida que avanza de arriba hacia abajo. La clase m\u00e1s general, <code>PiezaAjedrez</code>, est\u00e1 en la parte superior de la jerarqu\u00eda. Sus atributos y m\u00e9todos se transmiten (heredan) sus subclases. Sin embargo, adem\u00e1s de los atributos y m\u00e9todos que heredan de sus superclases, las subclases definen sus propios atributos y m\u00e9todos especiales. Cada una de las subclases, Pe\u00f3n, Alfil, etc., representa alg\u00fan tipo de especializaci\u00f3n de la superclase.</p>"},{"location":"ud5/1herencia/#herencia-simple","title":"Herencia simple","text":"<p>En Java, (a diferencia de los humanos) los hijos heredan caracter\u00edsticas de un solo padre. A esto se le llama herencia simple. Aunque algunos lenguajes de programaci\u00f3n permiten que una clase hija herede de m\u00e1s de una clase padre. A esto se le llama herencia m\u00faltiple. Con la herencia m\u00faltiple, a veces es dif\u00edcil saber qu\u00e9 padre contribuy\u00f3 con qu\u00e9 caracter\u00edsticas al hijo. Java evita estos problemas mediante el uso de herencia simple.</p> <p>Una clase padre puede tener m\u00faltiples hijos.</p> <p>La herencia es entre clases, no entre objetos.</p>"},{"location":"ud5/1herencia/#sintaxis-herencia-en-java-extends","title":"Sintaxis herencia en Java - extends","text":"<p>La sintaxis para heredar de una superclase es:</p> <pre><code>public class Child extends Parent {\n// los nuevos miembros y constructores de la clase hija van aqu\u00ed\n}\n</code></pre> <p>Los miembros (variables y m\u00e9todos) de la clase padre se incluyen autom\u00e1ticamente en el hijo por herencia. Si se quieren agregar miembros adicionales en la clase hija se hace en su definici\u00f3n de clase.</p> <p>Las clases declaradas como <code>final</code> no pueden ser extendidas.</p>"},{"location":"ud5/1herencia/#ejemplo-clase-animal","title":"Ejemplo clase Animal","text":"<p>Vamos a crear una clase base <code>Animal</code> que tendr\u00e1 una serie de caracter\u00edsticas comunes para todos los animales como puede ser, nombre, peso, tama\u00f1o, etc.</p> <pre><code>public class Animal {\n\nprivate String name;\nprivate int size;\nprivate int weight;\n\npublic Animal(String name, int size, int weight) {\nthis.name = name;\nthis.size = size;\nthis.weight = weight;\n}\n\n//getters y setters\n}\n</code></pre> <p>Ahora queremos crear un tipo de animal <code>Dog</code> que contendr\u00e1 todas las caracter\u00edsticas (atributos y m\u00e9todos) de la clase <code>Animal</code>:</p> <pre><code>public class Dog extends Animal {\n\n}\n</code></pre> <p>Cuando creamos una subclase, necesitamos llamar al constructor de la superclase para inicializarla, ya que hereda de ella. As\u00ed que tendremos que crear el constructor en la clase <code>Dog</code> que llame dentro al constructor de la superclase (<code>Animal</code>):</p> <pre><code>public class Dog extends Animal {\n\npublic Dog(String name, int size, int weight) {\nsuper(name, size, weight);\n}\n}\n</code></pre> <p>Al crear una clase hija <code>Dog</code> que hereda de la clase padre <code>Animal</code>, lo que estamos haciendo es heredar todo su comportamiento (atributos y m\u00e9todos) y adem\u00e1s nos permite a\u00f1adir atributos espec\u00edficos y \u00fanicos para esa clase hija que son particulares de los perros y no comunes o aplicables a todos los animales.</p>"},{"location":"ud5/1herencia/#super-keyword","title":"Super keyword","text":"<p>La palabra reservada <code>super</code> se utiliza para llamar al constructor de la clase de la que estamos heredando, es decir, llamar a la clase padre o superclase. En nuestro caso, para invocar al constructor de la superclase <code>Animal</code>. Esto nos permite inicializar la clase <code>Animal</code>, ya que <code>Dog</code> es una clase derivada que se basa en ella.</p> <p>La primera l\u00ednea dentro del constructor de la clase hija debe ser la llamada al constructor padre con <code>super()</code>. Si no se especifica expl\u00edcitamente entonces el compilador Java llama por defecto a <code>super();</code>, es decir, al constructor por defecto (sin argumentos) de la clase padre. Si el padre no tiene un constructor sin argumentos, entonces provoca un error.</p> <p>Note</p> <p>Si se proporciona un constructor con par\u00e1metros en una clase, el compilador de Java no crear\u00e1 autom\u00e1ticamente el constructor sin par\u00e1metros.</p> <p>En la clase hija vamos a crear algunos campos espec\u00edficos para los perros como ojos, piernas, etc. Porque recuerda que no todos los animales tienen piernas u ojos pero si todos los perros.</p> <pre><code>public class Dog extends Animal {\n\nprivate int eyes;\nprivate int legs;\nprivate int tail;\n\npublic Dog(String name, int size, int weight) {\nsuper(name, size, weight);\n}\n}\n</code></pre> <p>Adem\u00e1s de los campos que se necesitan para crear un objeto <code>Animal</code>, tambi\u00e9n hay que inicializar los campos propios de la clase <code>Dog</code> en el constructor:</p> <pre><code>public class Dog extends Animal {\n\nprivate int eyes;\nprivate int legs;\nprivate int tail;\n\npublic Dog(String name, int size, int weight, int eyes, int legs, int tail) {\nsuper(name, size, weight);\nthis.eyes = eyes;\nthis.legs = legs;\nthis.tail = tail;\n}\n}\n</code></pre> <p>En la clase base, vamos a a\u00f1adir comportamiento, que ser\u00e1 com\u00fan para todos los animales, comer y moverse:</p> <pre><code>public class Animal {\n\nprivate String name;\nprivate int size;\nprivate int weight;\n\npublic Animal(String name, int size, int weight) {\nthis.name = name;\nthis.size = size;\nthis.weight = weight;\n}\n\npublic void eat() {\n//c\u00f3digo\n}\n\npublic void move() {\n//c\u00f3digo\n}\n}\n</code></pre> <p>Al hacer esto, y crearlos como <code>public</code> (<code>protected</code> tambi\u00e9n servir\u00eda), significa que ahora est\u00e1n disponibles en la clase <code>Dog</code> autom\u00e1ticamente. Es decir, el m\u00e9todo <code>eat</code> y <code>move</code> se hereda a la clase <code>Dog</code>.</p>"},{"location":"ud5/1herencia/#probar-funcionamiento","title":"Probar funcionamiento","text":"<p>Vamos a probar c\u00f3mo funciona la herencia, para ello creamos un clase <code>Main</code> con un m\u00e9todo <code>main</code>.</p> <pre><code>public static void main(String[] args) {\nAnimal animal = new Animal(\"\", 0, 1);\n\nDog dog = new Dog(\"Maxi\", 2, 5, 2, 4, 1);\n\n}\n</code></pre> <p>Vemos que crear un animal no tiene mucho sentido, puesto que no sabemos mucho sobre \u00e9l. Cuando creamos un perro, podemos ser m\u00e1s espec\u00edficos en nuestra definici\u00f3n y dar valores relativos solo para perros. Adem\u00e1s, desde perro tenemos acceso a los m\u00e9todos definidos en la clase padre (<code>Animal</code>) como p\u00fablicos o protected. Por ejemplo, <code>dog.eat()</code> invocar\u00e1 al m\u00e9todo comer que se encuentra en la clase padre, ya que la clase <code>Dog</code> no tiene ning\u00fan m\u00e9todo <code>eat</code>.</p>"},{"location":"ud5/1herencia/#sobreescribir-metodos-de-la-clase-padre-en-los-hijos","title":"Sobreescribir m\u00e9todos de la clase padre en los hijos","text":"<p>La herencia nos aporta la opci\u00f3n de la sobreescritura de m\u00e9todos. Es decir, redefinir los m\u00e9todos de una clase padre en las clases hijas.</p> <p>Por ejemplo, en la clase <code>Dog</code> podemos sobreescribir el m\u00e9todo <code>eat()</code> con una funcionalidad m\u00e1s espec\u00edfica.</p> <p>El IntelliJ nos ofrece un atajo para sobreescritura de m\u00e9todos. Bot\u00f3n derecho --&gt; Generate...</p> <p></p> <p></p> <p>IntelliJ nos muestra todos los m\u00e9todos que est\u00e1n en la clase <code>Animal</code> y podemos sobreescribir:</p> <p></p> <p>Si seleccionamos el m\u00e9todo <code>eat()</code>, tenemos:</p> <pre><code>public class Dog extends Animal {\n\nprivate int eyes;\nprivate int legs;\nprivate int tail;\n\npublic Dog(String name, int size, int weight, int eyes, int legs, int tail) {\nsuper(name, size, weight);\nthis.eyes = eyes;\nthis.legs = legs;\nthis.tail = tail;\n}\n\n@Override\npublic void eat() {\nsuper.eat();//C\u00f3digo que se crea autom\u00e1ticamente y llama al m\u00e9todo eat de la clase padre\n}\n}\n</code></pre> <p>Ahora la clase hija <code>Dog</code> tiene su propio m\u00e9todo <code>eat()</code> con c\u00f3digo espec\u00edfico para esta clase.</p> <pre><code>public class Dog extends Animal {\n\nprivate int eyes;\nprivate int legs;\nprivate int tail;\n\npublic Dog(String name, int years, int weight, int eyes, int legs, int tail) {\nsuper(name, years, weight);\nthis.eyes = eyes;\nthis.legs = legs;\nthis.tail = tail;\n}\n\n//M\u00e9todo privado solo de la clase Dog\nprivate void chew() {\n\n}\n\n@Override\npublic void eat() {\nSystem.out.println(\"Dog eat\");\nchew();\nsuper.eat();\n}\n}\n</code></pre> <p>En t\u00e9rminos de sobreescritura, debemos de llevar cuidado con el m\u00e9todo que se invoca:</p> <pre><code>public class Dog extends Animal {\n\nprivate int eyes;\nprivate int legs;\nprivate int tail;\n\npublic Dog(String name, int years, int weight, int eyes, int legs, int tail) {\nsuper(name, years, weight);\nthis.eyes = eyes;\nthis.legs = legs;\nthis.tail = tail;\n}\n\n//M\u00e9todo privado solo de la clase Dog\nprivate void chew() {\n\n}\n\n@Override\npublic void eat() {\nSystem.out.println(\"Dog eat\");\nchew();\nsuper.eat();\n}\n\npublic void walk() {\nmove();\n}\n\n}\n</code></pre> <p>Si no sobreescribimos el m\u00e9todo <code>move()</code> en la clase <code>Dog</code>, cuando lo invocamos dentro del m\u00e9todo <code>walk()</code> se llamar\u00eda al m\u00e9todo de la clase <code>Animal</code>.</p> <p>Warning</p> <p>Los m\u00e9todos est\u00e1ticos se heredan pero no se pueden sobreescribir.</p>"},{"location":"ud5/1thisvssuper/","title":"This vs Super","text":"<ul> <li> <p>La palabra reservada super se usa para acceder a los miembros (atributos y m\u00e9todos) de la clase padre.</p> </li> <li> <p>La palabra reservada this se utiliza para acceder a los miembros (atributos y m\u00e9todos) de la clase actual en la que se usa.</p> </li> </ul> <p>Las dos palabras pueden usarse en cualquier lugar excepto en bloques de c\u00f3digo est\u00e1tico.</p>"},{"location":"ud5/1thisvssuper/#this","title":"This","text":"<p><code>this</code> es generalmente usada en constructores y en los m\u00e9todos setters, y opcionalmente en los getters ya que no tenemos par\u00e1metro de entrada con el mismo nombre:</p> <pre><code>public class Coche {\n\nprivate int ruedas;\n\npublic Coche(int ruedas) {\nthis.ruedas = ruedas;\n}\n\npublic void setRuedas(int ruedas) {\nthis.ruedas = ruedas;\n}\n\npublic int getRuedas() {\nreturn ruedas;\n}\n}\n</code></pre>"},{"location":"ud5/1thisvssuper/#super","title":"Super","text":"<p><code>super</code> es generalmente usada en sobreescritura de m\u00e9todos al usar herencia. Es decir, se utiliza para llamar desde las clases hijas al m\u00e9todo con el mismo nombre en la clase padre.</p> <pre><code>    @Override\npublic void eat() {\nSystem.out.println(\"Dog eat\");\nchew();\nsuper.eat();\n}\n</code></pre> <p>Sin la palabra reservada <code>super</code>, se producir\u00eda una llamada recursiva al mismo m\u00e9todo de forma infinita.</p>"},{"location":"ud5/1thisvssuper/#this_1","title":"this()","text":"<p>Usamos <code>this()</code> en forma de m\u00e9todo dentro del cuerpo de un constructor cuando queremos invocar a otro constructor sobrecargado dentro de la misma clase. <code>this()</code> solo puede usarse en un constructor; y debe de ser la primera sentencia que aparece en el constructor.</p>"},{"location":"ud5/1thisvssuper/#super_1","title":"super()","text":"<p>Usamos <code>super()</code> en forma de m\u00e9todo dentro del cuerpo de un constructor cuando queremos invocar a un constructor de la clase padre. <code>super()</code> solo puede usarse en un constructor; y debe de ser la primera sentencia que aparece en el constructor.</p> <p>Recordemos que el compilador de Java agrega de forma autom\u00e1tica la sentencia <code>super()</code> en el constructor de la clase hija si nosotros no lo a\u00f1adimos.</p> <p>Note</p> <p>Un constructor puede tener las sentencias <code>this()</code> o <code>super()</code> pero nunca ambas.</p> <p></p> <p>En el siguiente ejemplo, usamos las dos sentencias:</p> <pre><code>class Transporte {\n\nprivate int puertas;\nprivate int precio;\n\npublic Transporte(int puertas, int precio) {\nthis.puertas = puertas;\nthis.precio = precio;\n}\n}\n\npublic class Coche extends Transporte {\n\nprivate String modelo;\nprivate String marca;\n\npublic Coche(String modelo, String marca) {\nthis(0,0,modelo,marca);\n}\n\npublic Coche(int puertas, int precio, String modelo, String marca) {\nsuper(puertas, precio);\nthis.modelo = modelo;\nthis.marca = marca;\n}\n}\n</code></pre>"},{"location":"ud5/2composicion/","title":"Composici\u00f3n","text":"<p>La composici\u00f3n es otro componente de la programaci\u00f3n orientada a objetos y es muy utilizada.</p> <p>Es el mecanismo en el cual una clase se construye a partir de otros objetos de igual o distinto tipo, pudi\u00e9ndolos combinar para obtener la funcionalidad deseada. En la composici\u00f3n la nueva clase, mantiene una relaci\u00f3n \u201cUsa/Tiene un\u201d, con los objetos que son parte de la clase.</p> <p>Vamos a ver un ejemplo de la clase <code>Car</code> que extiende <code>Vehicle</code>:</p> <pre><code>public class Vehicle {\n\nprivate String name;\n}\n\npublic class Car extends Vehicle {\n\nprivate int doors;\nprivate int seats;\n\npublic Car(int doors, int seats) {\nthis.doors = doors;\nthis.seats = seats;\n}\n}\n</code></pre> <p>Estas dos clases tienen una relaci\u00f3n de herencia, el significado es que un coche es un veh\u00edculo.</p> <p>Pero la composici\u00f3n es diferente a la herencia tambi\u00e9n es un tipo de relaci\u00f3n. Por ejemplo, pensemos en un ordenador. Un ordenador se compone de una CPU, pantalla, rat\u00f3n y teclado. Pero una pantalla no es un ordenador, un rat\u00f3n no es un ordenador. Decimos que un ordenador tiene una pantalla, un ordenador tiene un teclado, etc. Eso es la composici\u00f3n, un todo que se construye con partes.</p> <p>Vamos a ver como se implementa esto:</p> <pre><code>public class Procesador {\n\nprivate String modelo;\nprivate int ramSlots;\nprivate int cardSlots;\n\npublic Procesador(String modelo, int ramSlots, int cardSlots) {\nthis.modelo = modelo;\nthis.ramSlots = ramSlots;\nthis.cardSlots = cardSlots;\n}\n\npublic void presionarBotonEncendido() {\nSystem.out.println(\"Iniciando el pc\");\n}\n\npublic void cargarPrograma(String nombre) {\nSystem.out.println(nombre);\n}\n\npublic String getModelo() {\nreturn modelo;\n}\n\npublic void setModelo(String modelo) {\nthis.modelo = modelo;\n}\n\npublic int getRamSlots() {\nreturn ramSlots;\n}\n\npublic void setRamSlots(int ramSlots) {\nthis.ramSlots = ramSlots;\n}\n\npublic int getCardSlots() {\nreturn cardSlots;\n}\n\npublic void setCardSlots(int cardSlots) {\nthis.cardSlots = cardSlots;\n}\n}\n\npublic class Monitor {\n\nprivate String modelo;\nprivate String resolucion;\nprivate int tam;\n\npublic Monitor(String modelo, String resolucion, int tam) {\nthis.modelo = modelo;\nthis.resolucion = resolucion;\nthis.tam = tam;\n}\n\npublic void dibujarPixel(int x, int y) {\nSystem.out.println(\"Pixel en \" + x + y);\n}\n\npublic String getModelo() {\nreturn modelo;\n}\n\npublic void setModelo(String modelo) {\nthis.modelo = modelo;\n}\n\npublic String getResolucion() {\nreturn resolucion;\n}\n\npublic void setResolucion(String resolucion) {\nthis.resolucion = resolucion;\n}\n\npublic int getTam() {\nreturn tam;\n}\n\npublic void setTam(int tam) {\nthis.tam = tam;\n}\n}\n\npublic class Teclado {\n\nprivate String color;\nprivate int teclas;\n\npublic Teclado(String color, int teclas) {\nthis.color = color;\nthis.teclas = teclas;\n}\n\npublic void pushKey(char key) {\nSystem.out.println(\"Se ha presionado la tecla \" + key);\n}\n\npublic String getColor() {\nreturn color;\n}\n\npublic void setColor(String color) {\nthis.color = color;\n}\n\npublic int getTeclas() {\nreturn teclas;\n}\n\npublic void setTeclas(int teclas) {\nthis.teclas = teclas;\n}\n}\n</code></pre> <p>Hemos creado las clases <code>Monitor</code>, <code>Teclado</code> y <code>Procesador</code>. Ahora vamos a crear una clase <code>Ordenador</code> que se compondr\u00e1n de las otras tres clases de la forma:</p> <pre><code>public class Ordenador {\n\nprivate Procesador procesador;\nprivate Teclado teclado;\nprivate Monitor monitor;\n\npublic Ordenador(Procesador procesador, Teclado teclado, Monitor monitor) {\nthis.procesador = procesador;\nthis.teclado = teclado;\nthis.monitor = monitor;\n}\n\npublic Procesador getProcesador() {\nreturn procesador;\n}\n\npublic void setProcesador(Procesador procesador) {\nthis.procesador = procesador;\n}\n\npublic Teclado getTeclado() {\nreturn teclado;\n}\n\npublic void setTeclado(Teclado teclado) {\nthis.teclado = teclado;\n}\n\npublic Monitor getMonitor() {\nreturn monitor;\n}\n\npublic void setMonitor(Monitor monitor) {\nthis.monitor = monitor;\n}\n}\n</code></pre> <p>Ya hemos implementado nuestras clases que componen un <code>Ordenador</code>. Ahora vamos a ver como utilizarlas:</p> <pre><code>public class Main {\n\npublic static void main(String[] args) {\nProcesador procesador = new Procesador(\"Intel\", 2, 3);\nMonitor monitor = new Monitor(\"Philips\", \"1024x900\", 24);\nTeclado teclado = new Teclado(\"Negror\",90);\n\nOrdenador ordenador = new Ordenador(procesador, teclado, monitor);\n}\n}\n</code></pre> <p>Se ha creado un objeto de la clase <code>Ordenador</code> a partir de las otras clases. En herencia ten\u00edamos acceso a los atributos de la clase padre, pero ahora con composici\u00f3n para acceder a los m\u00e9todos o atributos de las partes a partir de <code>Ordenador</code> lo haremos usando los m\u00e9todos getters que tenemos en la clase y nos permite acceder a <code>Teclado</code>, <code>Monitor</code> y <code>Procesador</code>.</p> <pre><code>    public static void main(String[] args) {\nProcesador procesador = new Procesador(\"Intel\", 2, 3);\nMonitor monitor = new Monitor(\"Philips\", \"1024x900\", 24);\nTeclado teclado = new Teclado(\"Negror\",90);\n\nOrdenador ordenador = new Ordenador(procesador, teclado, monitor);\nordenador.getMonitor().dibujarPixel(34, 56);\nordenador.getProcesador().cargarPrograma(\"Demo\");\nordenador.getTeclado().pushKey('X');\n}\n</code></pre>"},{"location":"ud5/2composicion/#ocultar-funcionalidad-de-los-objetos-parte","title":"Ocultar funcionalidad de los objetos parte","text":"<p>Otro escenario viable es el cual nos permita ocultar la funcionalidad, y no le permitamos al programa acceder directamente a los objetos que componen el todo. Para ello, lo primero que haremos ser\u00e1 modificar la visibilidad de los getters y ponerlos <code>private</code>, de manera que no se pueda acceder desde fuera a <code>Teclado</code>, <code>Monitor</code> o <code>Procesador</code> pero si podamos acceder internamente.</p> <pre><code>public class Ordenador {\n\nprivate Procesador procesador;\nprivate Teclado teclado;\nprivate Monitor monitor;\n\npublic Ordenador(Procesador procesador, Teclado teclado, Monitor monitor) {\nthis.procesador = procesador;\nthis.teclado = teclado;\nthis.monitor = monitor;\n}\n\nprivate Procesador getProcesador() {\nreturn procesador;\n}\n\nprivate Teclado getTeclado() {\nreturn teclado;\n}\n\nprivate Monitor getMonitor() {\nreturn monitor;\n}\n}\n</code></pre> <p>Una vez oculta la informaci\u00f3n veamos como podemos acceder a ella en el main. Creamos un m\u00e9todo en la clase <code>Ordenador</code> que acceder\u00e1 a las distintas partes.</p> <pre><code>public class Ordenador {\n\nprivate Procesador procesador;\nprivate Teclado teclado;\nprivate Monitor monitor;\n\npublic Ordenador(Procesador procesador, Teclado teclado, Monitor monitor) {\nthis.procesador = procesador;\nthis.teclado = teclado;\nthis.monitor = monitor;\n}\n\npublic void encender() {\ngetProcesador().presionarBotonEncendido();\ndibujarLogo();\n}\n\nprivate void dibujarLogo() {\nmonitor.dibujarPixel(12, 23);\n}\n\nprivate Procesador getProcesador() {\nreturn procesador;\n}\n\nprivate Teclado getTeclado() {\nreturn teclado;\n}\n\nprivate Monitor getMonitor() {\nreturn monitor;\n}\n}\n</code></pre> <p>En el <code>main</code> accederemos a este m\u00e9todo:</p> <pre><code>    public static void main(String[] args) {\nProcesador procesador = new Procesador(\"Intel\", 2, 3);\nMonitor monitor = new Monitor(\"Philips\", \"1024x900\", 24);\nTeclado teclado = new Teclado(\"Negror\",90);\n\nOrdenador ordenador = new Ordenador(procesador, teclado, monitor);\nordenador.encender();\n}\n</code></pre>"},{"location":"ud5/3encapsulacion/","title":"Encapsulaci\u00f3n","text":"<p>El mecanismo que permite restringir el acceso a componentes en los objetos, es decir, ofrece protecci\u00f3n a los miembros de la clase de cualquier acceso externo no autorizado es la encapsulaci\u00f3n. No estamos hablando de seguridad, hablamos m\u00e1s bien, de restringir el acceso desde fuera al funcionamiento interno de una clase, es decir, ocultar el trabajo interno que se realiza en una clase.</p> <p>Veamos un ejemplo de una clase que no usa encapsulaci\u00f3n y as\u00ed nos permitir\u00e1 entender mejor porqu\u00e9 la encapsulaci\u00f3n en algo positivo. Luego veremos c\u00f3mo se har\u00eda con encapsulaci\u00f3n.</p>"},{"location":"ud5/3encapsulacion/#ejemplo-de-programa-sin-encapsulacion","title":"Ejemplo de programa SIN encapsulaci\u00f3n","text":""},{"location":"ud5/3encapsulacion/#acceso-a-la-clase-y-modificacion-de-funcionalidad","title":"Acceso a la clase y modificacion de funcionalidad","text":"<p>Primero creamos una clase <code>Player</code> con los siguiente campos:</p> <pre><code>public class Player {\n\npublic String name;\npublic int health;\npublic String weapon;\n\npublic void applyDamage(int damage) {\nthis.health -= damage;\nif (this.health &lt;= 0 ) {\nSystem.out.println(\"Player died\");\n}\n}\n\npublic int getActualHealth() {\nreturn health;\n}\n}\n</code></pre> <p>Ahora implementamos el <code>main</code> en otra clase:</p> <pre><code>public class Main {\n\npublic static void main(String[] args) {\nPlayer player = new Player();\nplayer.name = \"Patricia\";\nplayer.health = 50;\nplayer.weapon = \"flamethrower\";\n\nint damage = 30;\nplayer.applyDamage(damage);\nSystem.out.println(\"The actual health is \" + player.getActualHealth());\n\ndamage = 10;\nplayer.health = 100;\nplayer.applyDamage(damage);\nSystem.out.println(\"The actual health is \" + player.getActualHealth());\n}\n}\n</code></pre> <p>Observamos que podemos inicializar directamente los campos del objeto <code>Player</code> a trav\u00e9s de clase externa porque hemos establecido la visibilidad como <code>public</code>. Adem\u00e1s, vemos que podemos causar da\u00f1o al jugador, pero seguidamente podemos darle m\u00e1s vida puesto que tenemos control sobre los atributos del jugador. Por lo que, al poder acceder a esos campos directamente potencialmente estamos abriendo la aplicaci\u00f3n y permitiendo cambiar el comportamiento. Ya que nosotros no queremos que se le pueda dar vida. Solo aplicar da\u00f1o.</p>"},{"location":"ud5/3encapsulacion/#consecuencias-de-cambios-internos-de-la-clase","title":"Consecuencias de cambios internos de la clase","text":"<p>Imaginar que la aplicaci\u00f3n evoluciona y queremos modificar un atributo de la clase <code>Player</code>, por ejemplo, ya no queremos el nombre, ahora vamos a tener en cuenta el <code>nickname</code> del jugador.</p> <p></p> <p>Al hacer este cambio, el m\u00e9todo <code>main</code> que acced\u00eda a este campo, genera un error. Lo que significa que cualquier campo que hagamos en la clase de <code>Player</code> afectar\u00e1 a cualquier clase que lo haya usado. Sabiendo que, es un cambio interno de la clase y en teor\u00eda no deber\u00eda afectar a ninguna otra clase, porque hemos decidido que es se entiende mejor si el atributo se llama <code>nickname</code> que si se llama <code>name</code>.</p>"},{"location":"ud5/3encapsulacion/#garantizar-la-clase-se-crea-con-los-valores-correctos","title":"Garantizar la clase se crea con los valores correctos","text":"<p>Como no hemos definido un constructor, puede ser que la clase externa que usa <code>Player</code> no defina las variables de forma v\u00e1lida. Por tanto, no podemos garantizar que el uso del objeto jugador sera correcto.</p> <p>Imagina que al crear un objeto de la clase <code>Player</code> nos olvidamos de darle valor al campo de <code>health</code>:</p> <p></p> <p>Al intentar aplicar da\u00f1o no se aplicar\u00e1 de forma correcta. Por tanto, es conveniente definir un constructor para garantizar que el objeto se construye de forma correcta y adem\u00e1s si queremos agregar alg\u00fan tipo de validaci\u00f3n tambi\u00e9n podr\u00edamos realizarla en el constructor.</p>"},{"location":"ud5/3encapsulacion/#ejemplo-de-programa-con-encapsulacion","title":"Ejemplo de programa CON encapsulaci\u00f3n","text":"<p>Vamos a ver cu\u00e1l es la forma correcta realizar el ejemplo anterior usando encapsulaci\u00f3n.</p> <pre><code>public class PlayerOk {\n\nprivate String name;\nprivate int health = 100;\nprivate String weapon;\n\npublic PlayerOk(String name, int health, String weapon) {\nthis.name = name;\nif (health &gt; 0 &amp;&amp; health &lt;= 100) {\nthis.health = health;\n}\nthis.weapon = weapon;\n}\n\npublic void applyDamage(int damage) {\nthis.health -= damage;\nif (this.health &lt;= 0 ) {\nSystem.out.println(\"Player died\");\n}\n}\n\npublic int getActualHealth() {\nreturn health;\n}\n}\n</code></pre> <pre><code>public class Main {\n\npublic static void main(String[] args) {\nPlayerOk playerOk = new PlayerOk(\"Patri\", 50, \"flamethrower\");\nPlayerOk playerOk2 = new PlayerOk(\"Manu\", 150, \"sword\");\n}\n}\n</code></pre>"},{"location":"ud5/4polimorfismo/","title":"Polimorfismo","text":"<p>El Polimorfismo es uno de los 4 pilares de la programaci\u00f3n orientada a objetos (POO) junto con la Abstracci\u00f3n, Encapsulaci\u00f3n y Herencia. Para entender que es el polimorfismo es muy importante que teng\u00e1is bastante claro el concepto de la Herencia.</p> <p>Polimorfismo significa \"que tiene muchas formas\", es la capacidad que tienen los objetos de una clase en ofrecer respuesta distinta e independiente en funci\u00f3n de los par\u00e1metros (diferentes implementaciones) utilizados durante su invocaci\u00f3n.</p> <p>Veamos un ejemplo para entender de forma m\u00e1s clara c\u00f3mo funciona el polimorfismo.</p> <p>Crearemos unas clases que heredan de la clase padre <code>Pelicula</code>:</p> <pre><code>class Pelicula {\nprivate String titulo;\n\npublic Pelicula(String titulo) {\nthis.titulo = titulo;\n}\n\npublic String trama() {\nreturn \"No hay trama\";\n}\n}\n\nclass Spiderman extends Pelicula {\npublic Spiderman() {\nsuper(\"Spiderman\");\n}\n\n@Override\npublic String trama() {\nreturn \"Un hombre que le muerde una ara\u00f1a y adquiere sus poderes.\";\n}\n}\n\nclass Batman extends Pelicula {\npublic Batman() {\nsuper(\"Batman\");\n}\n\n@Override\npublic String trama() {\nreturn \"Un hombre que le muerde un murci\u00e9lago y adquiere sus poderes.\";\n}\n}\n\nclass Zombieland extends Pelicula {\npublic Zombieland() {\nsuper(\"Zombieland\");\n}\n\n@Override\npublic String trama() {\nreturn \"Un pu\u00f1ado de humanos convertidos en zombies tratan de hacerse con el mundo\";\n}\n}\n\nclass StarWars extends Pelicula {\npublic StarWars() {\nsuper(\"StarWars\");\n}\n\n@Override\npublic String trama() {\nreturn \"Las fuerzas imperiales tratan de hacerse con control del mundo\";\n}\n}\n\nclass PeliRandom extends Pelicula {\npublic PeliRandom() {\nsuper(\"PeliRandom\");\n}\n}\n</code></pre> <p>Ahora vamos a crear un m\u00e9todo est\u00e1tico que nos va a devolver un objeto de tipo <code>Pelicula</code> en la clase <code>Main</code>, es decir, nos devolver\u00e1 una pel\u00edcula de manera aleatoria:</p> <pre><code>    public static Pelicula peliculaAleatoria() {\nint numero = (int) (Math.random()*5) + 1; //genera un n\u00famero aleatorio entre 1 - 5\nSystem.out.println(numero);\nswitch (numero) {\ncase 1:\nreturn new Spiderman();\ncase 2:\nreturn new Batman();\ncase 3:\nreturn new Zombieland();\ncase 4:\nreturn new StarWars();\ncase 5:\nreturn new PeliRandom();\n}\nreturn null;\n}\n</code></pre> <p>Gracias a la herencia, podemos devolver un tipo de la clase padre <code>Pelicula</code> aunque en realidad hayamos creado un objeto de una clase hija.</p> <p>Ahora vamos a ver el polimorfismo, para ello vamos a crear un bucle en el main de la siguiente forma:</p> <pre><code>    public static void main(String[] args) {\nfor (int i = 0; i &lt; 10; i ++) {\nPelicula pelicula = peliculaAleatoria();\nSystem.out.println(\"Pelicula \" + i + \" \" + pelicula.getTitulo() + \" \\n\" + pelicula.trama());\n}\n}\n</code></pre> <p>Gracias al polimorfismo tenemos la capacidad de llamar al m\u00e9todo <code>trama</code> con el mismo tipo de objeto, en este caso de tipo <code>Pelicula</code> y obtener diferentes resultados, ya que Java autom\u00e1ticamente ve qu\u00e9 tipo de hijo es e imprime el correspondiente m\u00e9todo <code>trama</code>. Para el caso de que no se haya sobreescrito el m\u00e9todo llamar\u00e1 al de la clase padre Es decir, dependiendo del tipo de objeto invocado se realizan acciones diferentes, teniendo en cuenta, que todas las clases heredan de <code>Pelicula</code> eso es el polimorfismo.</p>"},{"location":"ud5/4polimorfismo/#importante","title":"Importante","text":"<p>Una variable puede contener una referencia a un objeto cuya clase es descendiente de la clase de la variable. Ejemplo:</p> <pre><code>    //La variable a es una referencia a un objeto Perro que es descendiente de Animal. \nAnimal a = new Perro();\n</code></pre> <p>Un descendiente de una clase es un hijo de esa clase, o un hijo de un hijo de esa clase, y as\u00ed sucesivamente. Los hermanos no son descendientes entre s\u00ed.</p> <p>NO podemos asignar un objeto de referencia de padre a una variable de clase hijo (Perro p = new Animal()). Si queremos convertir un padre en hijo, la variable tiene que ser creada de tipo hijo. Si queremos convertir un hijo en padre tendremos que hacer un Upcasting, y al rev\u00e9s tendr\u00edamos un Downcasting:</p> <p></p> <p>Ejemplo</p> <pre><code>    //NO SE PUEDE HACER\nPerro p = new Animal(); //no compila\nPerro p = (Perro) new Animal(); // compila pero da error de ejecuci\u00f3n\n\n//DOWNCASTING, convertir padre en hijo\nAnimal a = new Perro();\nPerro pe = (Perro)a;\n\n//UPCASTING, convertir hijo en padre\nAnimal a = (Animal) new Perro();\n</code></pre>"},{"location":"ud5/5interfaces/","title":"\u2695\ufe0fInterfaces","text":""},{"location":"ud5/5interfaces/#definicion","title":"\u2747\ufe0f Definici\u00f3n","text":"<p>Una interfaz es una clase que define m\u00e9todos pero no los implementa. La idea es proporcionar un comportamiento com\u00fan que pueda ser utilizado por varias clases que implemente una interfaz. No se pueden instanciar.</p> <p>Una interfaz es una lista de constantes y signaturas de m\u00e9todos. Los m\u00e9todos no est\u00e1n implementados en la interfaz (no hay cuerpo de m\u00e9todo).</p>"},{"location":"ud5/5interfaces/#por-que-se-utilizan-las-interfaces","title":"\u2747\ufe0f \u00bfPor qu\u00e9 se utilizan las interfaces?","text":"<p>Hay principalmente tres razones para usar la interfaz.</p> <ul> <li>Para lograr la abstracci\u00f3n.</li> <li>Dan algunas ventajas de herencia m\u00faltiple, sin las desventajas de la herencia.</li> <li>Para obtener un mayor desacoplamiento del c\u00f3digo.</li> </ul> <p>Las interfaces son muy usadas, de hecho, muchas de las librer\u00edas de Java hacen un uso extensivo de las interfaces.</p> <p>Sabemos que Java tiene herencia \u00fanica, es decir, una clase hija hereda solo de una clase padre. Esto, por lo general, es suficiente para codificar nuestras aplicaciones. Aunque a veces ser\u00eda conveniente la herencia m\u00faltiple, donde una clase hija pudiera heredar caracter\u00edsticas de varias clases padres. Pero esto puede llegar a ser confuso. \u00bfQu\u00e9 sucede cuando dos padres tienen diferentes versiones del mismo m\u00e9todo?</p> <p>Una interfaz describe aspectos de una clase distintos de los que hereda de su padre. Una interfaz es un conjunto de requisitos que la clase debe implementar.</p>"},{"location":"ud5/5interfaces/#interfaz-vs-herencia","title":"\u2747\ufe0f Interfaz vs Herencia","text":"<p>Una clase puede extender de una clase padre para heredar los m\u00e9todos y las variables de instancia de ese padre. </p> <p>Una clase tambi\u00e9n puede implementar una interfaz al incluir m\u00e9todos y constantes adicionales. Sin embargo, los m\u00e9todos en la interfaz deben escribirse expl\u00edcitamente como parte de la definici\u00f3n de la clase. La interfaz es una lista de requisitos que debe incluir la definici\u00f3n de clase (a trav\u00e9s de c\u00f3digo expl\u00edcito, no a trav\u00e9s de herencia).</p> <p>Por ejemplo, una clase <code>Coche</code> podr\u00eda extender de la clase <code>Vehiculo</code>. La herencia le da todos los m\u00e9todos y variables de instancia. Pero si <code>Coche</code> tambi\u00e9n implementa la interfaz <code>Impuestos</code>, entonces su definici\u00f3n debe contener c\u00f3digo para TODOS los m\u00e9todos enumerados en <code>Impuestos</code>.</p> <p>En Java las interfaces tambi\u00e9n representan una relaci\u00f3n ES-UN.</p> <p>Una clase extiende de un solo padre, pero puede implementar varias interfaces.</p>"},{"location":"ud5/5interfaces/#como-crear-una-interfaz","title":"\u2747\ufe0f C\u00f3mo crear una interfaz","text":"<p>Para crear una interfaz en IntelliJ, haremos lo siguiente:</p> <ol> <li>Bot\u00f3n derecho en el paquete de nuestra aplicaci\u00f3n --&gt; New ---&gt; Java class y seleccionamos Interface.</li> </ol> <p></p> <p></p> <p>En Java, los nombres de las interfaces, por lo general, deber\u00edan ser adjetivos o nombres que describen el concepto abstracto que representa la interfaz. La primera letra de cada palabra separada en may\u00fascula. En algunos casos, las interfaces tambi\u00e9n pueden ser sustantivos cuando presentan una familia de clases, p. <code>List</code> o <code>Map</code>.</p> <p></p> <p>Una vez creada la interfaz definiremos los m\u00e9todos que desarrollar\u00e1n las clases que implementen esta interfaz teniendo en cuenta que, el compilador de Java agrega las palabras clave:</p> <ul> <li><code>public abstract</code> cuando se define un m\u00e9todo, por lo que se puede omitir en los encabezados de los m\u00e9todos. </li> <li><code>public static final</code> en el caso de las constantes.</li> </ul> <p></p> <p>Warning</p> <p>Los m\u00e9todos abstractos NO pueden ser PRIVATE ni PROTECTED.</p> <p>Se estructura de forma que primero se sit\u00faan las constantes y luego los m\u00e9todos.</p> <p>Si ponemos <code>public</code> IntelliJ nos avisa:</p> <p></p> <p></p>"},{"location":"ud5/5interfaces/#relaciones-entre-interfaces-y-clases","title":"\u2747\ufe0f Relaciones entre interfaces y clases","text":"<p>Tenemos tres tipos de relaciones:</p> <ul> <li><code>classB</code> extends <code>classA</code>: una clase B hereda de una clase A.</li> <li><code>class</code> implements <code>interface1</code>, <code>interface2</code>, ...: una clase puede implementar una o varias interfaces, para ello usaremos la palabra reservada implements.</li> <li><code>interfaceB</code> extends <code>interfaceA</code>, <code>interfaceC</code>, ...: una interfaz B puede heredar los m\u00e9todos de una o varias interfaces. Una interfaz NO PUEDE heredar de una clase.</li> </ul> <p>Tambi\u00e9n podemos combinar algunas relaciones:</p> <ul> <li><code>classB</code> extends <code>classA</code> implements <code>interface1</code>, <code>interface2</code>, ...:  una clase B hereda de una clase A y tambi\u00e9n implementa los m\u00e9todos definidos en las interfaces. (Simulaci\u00f3n de la herencia m\u00faltiple)</li> </ul>"},{"location":"ud5/5interfaces/#ejemplo-de-codigo","title":"\u2747\ufe0f Ejemplo de c\u00f3digo","text":"<p>Por ejemplo, vamos a crear la clase TelefonoMovil:</p> <p></p> <p>Observamos que IntelliJ nos genera un error, ya que debemos definir o implementar los m\u00e9todos que hab\u00edamos declarado en la interfaz. Si hacemos click en el error, IntelliJ nos ofrece crearlos:</p> <p></p> <p></p> <p>IntelliJ nos ha creado TODOS los m\u00e9todos que hab\u00edamos definido en la interfaz, como vemos con la anotaci\u00f3n <code>@Override</code>, ya que los est\u00e1 sobreescribiendo puesto que estaban declarados en la interfaz.</p> <p>Note</p> <p>TODOS los m\u00e9todos definidos en la interfaz se han de implementar en la clase, no podr\u00edamos implementar solo algunos.</p> <p>Veamos como probar el c\u00f3digo en nuestra clase <code>Main</code>:</p> <pre><code>public class MainTelefono {\n\npublic static void main(String[] args) {\nImpuesto impuesto = new TelefonoMovil(123456789);\nimpuesto.imprimirImpuesto();\n}\n}\n</code></pre> <p>Warning</p> <p>Las interfaces NO PUEDEN INSTANCIARSE, es decir, no podemos crear objetos de interfaces. Hay que usar una clase que haya implementado la funcionalidad definida por la interfaz.</p>"},{"location":"ud5/5interfaces/#novedades","title":"\u2747\ufe0f Novedades","text":"<p>Desde Java 8 podemos incluir en una interfaz:</p> <ul> <li> <p>m\u00e9todos con cuerpo o implementaci\u00f3n: se denominan default methods. Estos m\u00e9todos se heredan como cualquier m\u00e9todo ordinario m\u00e1s y se pueden sobreescribir en la clase que implementa esa interfaz o sobreescribir en la interfaz que hereda de esa interfaz.</p> </li> <li> <p>m\u00e9todos est\u00e1ticos con cuerpo o implementaci\u00f3n. Estos m\u00e9todos no pueden ser sobreescritos o cambiar en ninguna clase que implemente la interfaz. Aunque si se heredan.</p> </li> </ul> Impuesto.java<pre><code>public interface Impuesto {\n\n//constantes\ndouble TASA_DE_IMPUESTO = 0.06;\n\n//m\u00e9todos abstractos\ndouble calcularImpuestoAnual();\n\nvoid imprimirImpuesto();\n\n//default methods\ndefault void imprimirTasa() {\nSystem.out.println(\"La tasa de impuesto es \" + TASA_DE_IMPUESTO);\n}\n\n//m\u00e9todos est\u00e1ticos\nstatic double tax(int precio) {\nreturn TASA_DE_IMPUESTO * precio;\n}\n}\n</code></pre>"},{"location":"ud5/5interfaces/#por-que-el-uso-de-default-o-static-methods-en-el-interior-de-una-interfaz","title":"\u269c\ufe0f \u00bfPor qu\u00e9 el uso de default o static methods en el interior de una interfaz?","text":"<p>Imagina que creamos una interfaz en el proyecto. Pasado un tiempo, un gran n\u00famero de clases implementan esa interfaz.</p> <p>Si ahora a\u00f1adimos un nuevo m\u00e9todo a esta interfaz, desencadena en que, todas las clases que implementen esa interfaz se ver\u00e1n afectadas con errores, hasta que implementen o le den cuerpo a ese nuevo m\u00e9todo. Aunque no es una tarea complicada puede llegar a ser tediosa, o que no sepamos todav\u00eda como implementarlo en todas las clases.</p> <p>Para solventar esto, Java introdujo los default methods y m\u00e9todos est\u00e1ticos.</p> <ul> <li>Desde Java 9, podemos tener m\u00e9todos privados en una interfaz.</li> </ul> <p>Los m\u00e9todos privados se pueden implementar est\u00e1ticos o no. </p> <p>\u00bfCu\u00e1les son las ventajas de tener m\u00e9todos privados?</p> <p>Las interfaces pueden usar m\u00e9todos privados para ocultar detalles sobre la implementaci\u00f3n de las clases que implementan la interfaz. Como resultado, uno de los principales beneficios de tenerlos en las interfaces es la encapsulaci\u00f3n.</p> Impuesto.java<pre><code>public interface Impuesto {\n\n//constantes\ndouble TASA_DE_IMPUESTO = 0.06;\n\n//m\u00e9todos abstractos\ndouble calcularImpuestoAnual();\n\nvoid imprimirImpuesto();\n\n//default methods\ndefault void imprimirTasa() {\nSystem.out.println(\"La tasa de impuesto es \" + TASA_DE_IMPUESTO);\n}\n\ndefault void aumentarTasa() {\nduplicarTasa();\n}\n\n//m\u00e9todos privados de instancia\nprivate double duplicarTasa() {\nreturn TASA_DE_IMPUESTO * 2;\n}\n\n//m\u00e9todos est\u00e1ticos\nstatic double tax(int precio) {\nmostrarPrecio(precio);\nreturn TASA_DE_IMPUESTO * precio;\n}\n\n//m\u00e9todos privados est\u00e1ticos\nprivate static void mostrarPrecio(int precio) {\nSystem.out.println(\"El precio es \" + precio);\n}\n\n}\n</code></pre>"},{"location":"ud5/6abstraccion/","title":"Abstracci\u00f3n","text":"<p>La abstracci\u00f3n es un proceso de ocultar los detalles de implementaci\u00f3n y mostrar solo la funcionalidad al usuario.</p> <p>De otra manera, muestra solo las cosas esenciales para el usuario y oculta los detalles internos.</p> <p>Una clase abstracta es una clase que no se puede instanciar pero que puede ser el padre de otras clases. Esto es \u00fatil, por ejemplo, cuando tenemos un concepto abstracto o amplio como Veh\u00edculo o Animal pero en realidad los objetos reales ser\u00edan tipos espec\u00edficos como Coche, Avi\u00f3n, Perro, etc.</p> <p>Aunque no se puede instanciar, una clase abstracta define m\u00e9todos y variables que heredan las clases hijas.</p>"},{"location":"ud5/6abstraccion/#como-crear-una-clase-abstracta","title":"C\u00f3mo crear una clase abstracta","text":"<p>Para crear una clase abstracta en IntelliJ, haremos lo siguiente:</p> <ol> <li>Bot\u00f3n derecho en el paquete de nuestra aplicaci\u00f3n --&gt; New ---&gt; Java class y a\u00f1adimos la palabra reservada <code>abstract</code>:</li> </ol> <p></p>"},{"location":"ud5/6abstraccion/#metodos-abstractos","title":"M\u00e9todos abstractos","text":"<p>Las clases abstractas pueden opcionalmente contener m\u00e9todos abstractos. Tambi\u00e9n pueden contener m\u00e9todos no abstractos, que ser\u00e1n heredados por los hijos.</p> <p>Un m\u00e9todo abstracto no tiene cuerpo. (No tiene c\u00f3digo). Solo se escribe la signatura del m\u00e9todo con la palabra reservada abstract.</p> <p>Vamos a crear una clase abstracta <code>Animal</code>:</p> <p></p> <p>Si ahora creamos una clase hija que herede de <code>Animal</code> obtendremos un error:</p> <p></p> <p>Esto es debido a que una clase hija no abstracta hereda el m\u00e9todo o los m\u00e9todos abstractos del padre y debe desarrollarlos como m\u00e9todos no abstractos, es decir, con c\u00f3digo. Si no lo hace debe declararse como abstracta.</p> <p>Un hijo abstracto de un padre abstracto no tiene que definir m\u00e9todos no abstractos para los m\u00e9todos abstractas que hereda. Esto significa que puede haber varios pasos entre una clase base abstracta y una clase secundaria que no es completamente abstracta.</p> <p></p> <p></p> <p>No todo lo definido en una clase abstracta debe ser abstracto. Sin embargo, si una clase contiene incluso un m\u00e9todo abstracto, entonces la clase en s\u00ed debe declararse abstracta.</p> <p>Si a\u00f1adimos otra clase hija <code>Ave</code> que hereda de <code>Animal</code> y le agregamos un m\u00e9todo abstracto. El IntelliJ nos muestra un error.</p> <p></p> <p>Tenemos que crear la clase como abstracta, ya que contiene un m\u00e9todo abstracto.</p> <p>Una vez creada la clase <code>Ave</code> como abstracta podr\u00edamos heredar de ella y crear clases hijas que implementar\u00e1n el m\u00e9todo abstracto volar:</p> <p></p> <p>Las clases abstractas se utilizan para organizar programas. Agrupar las clases es importante para mantener un programa organizado y comprensible.</p> <p>La ventaja de usar una clase abstracta es que puede agrupar varias clases relacionadas como hermanas.</p> <p>Aunque no se puedan instanciar las clases abstractas tambi\u00e9n poseen constructores. La mayor\u00eda de las veces se utilizan cuando quieres realizar alguna inicializaci\u00f3n de los campos de la clase abstracta antes de la instanciaci\u00f3n de una clase hija.</p> <p>Warning</p> <p>Cuando se invoca un m\u00e9todo, es la clase del objeto (no de la variable) la que determina qu\u00e9 m\u00e9todo se ejecuta.</p>"},{"location":"ud5/6abstraccion/#interfaces-vs-clases-abstractas","title":"Interfaces vs Clases abstractas","text":"<ul> <li>Las clases abstractas pueden tener variables de instancia (atributos) que se heredan, al contrario que las interfaces, que no permiten definir variables solo constantes est\u00e1ticas.</li> <li>Ni las interfaces ni las clases abstractas se puede instanciar.</li> <li>Las interfaces no pueden tener constructores y las clases abstractas si.</li> <li>Todos los m\u00e9todos definidos en una interfaz son por defecto p\u00fablicos y abstractos, mientras que, en un clase abstracta podemos tener m\u00e9todos con diferentes visibilidades (<code>public</code>, <code>private</code> o <code>protected</code>) y abstractos o con cuerpo.</li> <li>Si implementas una interfaz debes sobreescribir todos sus m\u00e9todos, si heredas de una clase abstractas solo est\u00e1s obligado a sobreescribir los m\u00e9todos abstractos.</li> </ul>"},{"location":"ud5/7exceptions/","title":"Excepciones","text":"<p>Una excepci\u00f3n es un evento que ocurre durante la ejecuci\u00f3n de una aplicaci\u00f3n e interrumpe el flujo normal de las instrucciones del programa.</p> <p></p> <p>Class Exception y class Error extienden Throwable. Un m\u00e9todo Java puede \"lanzar\" un objeto de clase Throwable.</p> <p>Las excepciones son diferentes de los errores porque se pueden escribir programas para recuperarse de excepciones, pero no se pueden escribir programas para recuperarse de errores.</p> <p>Las excepciones pueden ser detectadas por una parte del programa que intenta recuperarse del problema.</p> <p>En Java, hay dos tipos de excepciones:</p> <ul> <li>Checked exceptions (Excepciones verificadas).</li> <li>Unchecked exceptions (Excepciones no verificadas).</li> </ul>"},{"location":"ud5/7exceptions/#checked-exceptions","title":"Checked exceptions","text":"<p>Estas son las excepciones que se comprueban en tiempo de compilaci\u00f3n, es decir, un m\u00e9todo debe hacer algo al respecto sino el programa no compila. Si alg\u00fan c\u00f3digo dentro de un m\u00e9todo arroja una excepci\u00f3n verificada, entonces el m\u00e9todo puede:</p> <ol> <li>manejar la excepci\u00f3n en un bloque <code>try-catch{}</code>, o</li> <li><code>throws</code> (lanzar) la excepci\u00f3n al que invoca el m\u00e9todo.</li> </ol> <pre><code>public void leerFichero(String[] a) throws IOException {\n//c\u00f3digo java\n}\n</code></pre> <p>En el ejemplo, <code>IOException</code> es una checked exception. Este m\u00e9todo lanza una IOException cuando hay un problema de lectura.</p> <p>La palabra reservada <code>throws</code> dice que este m\u00e9todo no captura la excepci\u00f3n <code>IOException</code> con un <code>catch</code>, sino que cuando ocurra una, se lanzar\u00e1 a la persona que llama el m\u00e9todo <code>leerFichero</code>.</p> <p>Si hici\u00e9ramos esto en un m\u00e9todo <code>main</code>, como por ejemplo:</p> <pre><code>public static void main(String[] args) throws IOException {\n//c\u00f3digo java\n\n}\n</code></pre> <p>La excepci\u00f3n se lanzar\u00e1 al Java runtime system. El sistema de tiempo de ejecuci\u00f3n de Java detecta las excepciones que se le han lanzado e imprime un mensaje y un seguimiento de la pila utilizando los datos de la excepci\u00f3n.</p>"},{"location":"ud5/7exceptions/#unchecked-exceptions","title":"Unchecked exceptions","text":"<p>Ocurren en tiempo de compilaci\u00f3n, es decir, no se verifican por el compilador. En Java, las excepciones en las clases RunTimeException y Error y sus subclases son unchecked exceptions todo lo dem\u00e1s es es checked.</p> <p>Depende de los programadores especificar o detectar las excepciones unchecked. Por ejemplo, imagina que tenemos el siguiente programa Java se compila sin erorres:</p> <pre><code>public static void main(String[] args) {\nint x = 0;\nint y = 10;\nint z = y / x;\n}\n</code></pre> <p>El compilador nos deja compilar la aplicaci\u00f3n porque <code>ArithmeticException</code> es una excepci\u00f3n no verificada, pero al ejecutar el programa se lanza la excepci\u00f3n, por tanto, nosotros tendremos que darnos cuenta y controlar este tipo de excepciones.</p>"},{"location":"ud5/7exceptions/#diferencias-entre-checked-y-unchecked-exceptions","title":"Diferencias entre checked y unchecked exceptions","text":"<ul> <li>Una checked exception se detecta en tiempo de compilaci\u00f3n, mientras que una unchecked exception en tiempo de ejecuci\u00f3n.</li> <li>Una checked exception debe manejarse o bien con volvi\u00e9ndola a lanzar con un <code>throw</code> o con un bloque <code>try catch</code>, mientras que una unchecked exception no requiere ser manejada.</li> <li>Una unchecked exception es un error de programaci\u00f3n y es fatal, mientras que una checked exception es una condici\u00f3n de excepci\u00f3n dentro de la l\u00f3gica de su c\u00f3digo y se puede recuperar o volver a intentar.</li> </ul>"},{"location":"ud5/7exceptions/#throwable","title":"Throwable","text":"<p><code>Throwable</code> es la superclase de todas las excepciones y errores. Se podria capturar en un bloque <code>try-catch</code>, \u00a1pero nunca se debe hacer!, ya que, no solo capturar\u00e1 todas las excepciones; sino que tambi\u00e9n har\u00e1 lo mismo con todos los errores que genere la aplicacion.</p> <p>La JVM arroja errores para indicar problemas graves que no est\u00e1n destinados a ser manejados por una aplicaci\u00f3n.</p> <p>Ejemplos t\u00edpicos de eso son <code>OutOfMemoryError</code> o <code>StackOverflowError</code>. Ambos son causados por situaciones que est\u00e1n fuera del control de la aplicaci\u00f3n y no se pueden manejar.</p> <p>Por lo tanto, es mejor que NUNCA captures un Throwable.</p>"},{"location":"ud5/7exceptions/#excecpciones-personalizadas","title":"Excecpciones personalizadas","text":"<p>Aunque las excepciones de Java cubren casi todas las excepciones generales que est\u00e1n obligadas a ocurrir en la programaci\u00f3n. Sin embargo, a veces necesitamos complementar estas excepciones est\u00e1ndar con las nuestras.</p> <p>Estas son las principales razones para introducir excepciones personalizadas:</p> <ul> <li>A\u00f1adir excepciones que son espec\u00edficas de la l\u00f3gica de nuestra aplicaci\u00f3n o empresa. \u00c9stas ayudan a los usuarios de la aplicaci\u00f3n o a los desarrolladores a comprender cu\u00e1l es el problema exacto.</li> <li>Para capturar y proporcionar un tratamiento espec\u00edfico a un subconjunto de excepciones de Java existentes.</li> <li>A\u00f1adir nuevos m\u00e9todos o atributos que no son parte de las excepciones est\u00e1ndar.</li> </ul>"},{"location":"ud5/7exceptions/#buenas-practicas-para-definir-excepciones-personalizadas","title":"Buenas pr\u00e1cticas para definir excepciones personalizadas","text":""},{"location":"ud5/7exceptions/#haz-que-tenga-sentido","title":"Haz que tenga sentido","text":"<p>Proporciona informaci\u00f3n o funcionalidad que no forma parte de las excepciones est\u00e1ndar de Java.</p> <p>Esa es la esencia de la primera y m\u00e1s importante recomendaci\u00f3n. De lo contrario, su excepci\u00f3n no brinda ning\u00fan beneficio en comparaci\u00f3n con la gran cantidad de excepciones que ya proporciona el JDK.</p> <p>Si no puede proporcionar ning\u00fan beneficio, es mejor que use una de las excepciones est\u00e1ndar, como UnsupportedOperationException o IllegalArgumentException. Todos los desarrolladores de Java ya conocen estas excepciones. Eso hace que su c\u00f3digo y API sean m\u00e1s f\u00e1ciles de entender.</p>"},{"location":"ud5/7exceptions/#sigue-la-convencion-de-nomenclatura-estandar","title":"Sigue la convenci\u00f3n de nomenclatura est\u00e1ndar","text":"<p>Cuando obsevamos las clases de excepci\u00f3n proporcionadas por el JDK, r\u00e1pidamente nos damos cuenta que todos sus nombres terminan con <code>Exception</code>. Esta convenci\u00f3n de nomenclatura general se utiliza en todo el sistema de Java. Y su excepci\u00f3n personalizada tambi\u00e9n deber\u00eda seguirlo, por ejemplo, <code>ImpresoraException</code>.</p>"},{"location":"ud5/7exceptions/#anade-javadoc-a-tu-clase-de-excepcion-personalizada","title":"A\u00f1ade Javadoc a tu clase de excepci\u00f3n personalizada","text":"<p>Las API no documentadas son muy dif\u00edciles de usar.</p> <p>Las clases de excepci\u00f3n pueden no ser la parte m\u00e1s obvia de tu API, pero siguen siendo parte de ella. Tan pronto como uno de sus m\u00e9todos orientados al cliente arroja una excepci\u00f3n, la clase de excepci\u00f3n se convierte en parte de la API. Eso implica que requiere documentaci\u00f3n y un buen Javadoc.</p> <p>El Javadoc debe describir el significado general de la excepci\u00f3n y las situaciones en las que podr\u00eda ocurrir. El objetivo es ayudar a otros desarrolladores a comprender su API y evitar escenarios de error comunes.</p>"},{"location":"ud5/7exceptions/#proporciona-un-constructor","title":"Proporciona un constructor","text":"<p>Normalmente, nuestro c\u00f3digo detectar\u00e1 una excepci\u00f3n est\u00e1ndar antes de lanzar nuestra excepci\u00f3n personalizada. Esto, no debe ocultarse ya que la excepci\u00f3n capturada generalmente contendr\u00e1 informaci\u00f3n esencial que necesitaremos para analizar el incidente.</p> <p>En el siguiente ejemplo, <code>NumberFormatException</code> proporciona informaci\u00f3n detallada sobre el error. Perder\u00e1 esta informaci\u00f3n si no la configura como la causa de <code>MyException</code>.</p> <pre><code>public void methodA(String entrada) throws MyException {\ntry {\n// c\u00f3digo\n} catch (NumberFormatException e) {\nthrow new MyException(\"Mensaje que describe el error.\", e, ErrorCode.INVALID_ENTRY);\n}\n}\n</code></pre> <p><code>Exception</code> y <code>RuntimeException</code> proporcionan constructores que aceptan un <code>Throwable</code> que describe la causa de la excepci\u00f3n. Por tanato, nuestra excepci\u00f3n deber\u00eda hacer lo mismo. Debemos implementar al menos un constructor que obtenga el Throwable causante como par\u00e1metro y lo establezca en la superclase.</p>"},{"location":"ud5/7exceptions/#pasos-para-implementar-una-excepcion-personalizada","title":"Pasos para implementar una excepci\u00f3n personalizada","text":"<ol> <li>Debemos extender de la clase <code>java.lang.Exception</code>.</li> <li>Se debe proporcionar un constructor que establezca la excepci\u00f3n causante y brinde un beneficio en comparaci\u00f3n con las excepciones est\u00e1ndar disponibles.</li> </ol> <p>Ejemplo:</p> <p></p> <p></p> <p><code>MyException</code> usa un enum personalizado para almacenar un c\u00f3digo de error que identifica el problema de nuestra aplicaci\u00f3n. Los clientes pueden usar el c\u00f3digo de error para mostrar mensajes de error localizados o decirle al usuario que incluya este c\u00f3digo en un ticket de soporte.</p> <p>Para usar <code>MyException</code> en nuestra aplicaci\u00f3n o programa necesitaremos especificarlo como parte de la signatura de un m\u00e9todo o simplemente capturarla con un bloque <code>try-catch</code>.</p> <p></p> <p>Note</p> <p>Si queremos crear una excepci\u00f3n personalizada de tipo unchecked exception realizaremos el mismo procedimiento con la diferencia de que tendremos que extender de la clase <code>java.lang.RuntimeException</code>.</p>"},{"location":"ud6/1list/","title":"Estructuras de datos","text":"<p>La estructura de datos es una forma de almacenar y organizar datos de manera eficiente, de modo que las operaciones requeridas en ellos se puedan realizar de manera eficiente con respecto al tiempo y la memoria. Simplemente, la estructura de datos se utiliza para reducir la complejidad (principalmente la complejidad del tiempo) del c\u00f3digo.</p> <p>Las estructuras de datos pueden ser de dos tipos:</p> <ol> <li>Estructura de datos est\u00e1tica</li> <li>Estructura de datos din\u00e1mica</li> </ol>"},{"location":"ud6/1list/#estructuras-de-datos-estaticos","title":"Estructuras de datos est\u00e1ticos","text":"<p>En la estructura de datos est\u00e1tica, el tama\u00f1o de la estructura es fijo. El contenido de la estructura de datos se puede modificar pero sin cambiar el espacio de memoria que se le asigna. Un ejemplo de estas estructuras son los arrays que vimos en la unidad 4.</p> <p>Aunque los arrays son muy \u00fatiles como hemos estudiado, si queremos redimensionar un array, es decir, cambiar su tama\u00f1o una vez lo hemos creado y preservar los valores que se encuentran en \u00e9l la \u00fanica forma de hacerlo ser\u00eda creando un nuevo array y copiar los elementos a este nuevo array. Hacer esto cada vez que queremos redimensionar el tama\u00f1o de un array es muy tedioso y no es nada productivo.</p>"},{"location":"ud6/1list/#estructuras-de-datos-dinamicas","title":"Estructuras de datos din\u00e1micas","text":"<p>En la estructura de datos din\u00e1mica, el tama\u00f1o de la estructura no es fijo y puede modificarse durante las operaciones realizadas en \u00e9l. Las estructuras de datos din\u00e1micas est\u00e1n dise\u00f1adas para facilitar el cambio en tiempo de ejecuci\u00f3n.</p> <p>Documentaci\u00f3n oficial Collections Java</p>"},{"location":"ud6/1list/#list","title":"List","text":"<p>Una lista se puede ver como un array ya que es una secuencia de elementos o colecci\u00f3n ordenada que te permite tener elementos en posiciones consecutivas.</p> <p>En Java <code>List</code> es una interfaz Java.util.List que exitende de <code>Collection</code>. Siempre conserva el orden de los elementos. Los elementos contenidos en una lista se pueden insertar, acceder, iterar y eliminar de acuerdo con el orden en que aparecen internamente en la lista. El orden de los elementos es la raz\u00f3n por la cual esta estructura de datos se llama <code>List</code>. Cada elemento en una lista de Java tiene un \u00edndice, al igual que ocurr\u00eda con los arrays.</p> <p>La interfaz de lista se implementa mediante las clases <code>ArrayList</code>, <code>LinkedList</code>, <code>Vector</code> y <code>Stack</code>. Es decir, dado que <code>List</code> es una interfaz, no se puede crear una instancia directamente. Sin embargo, uno puede crear objetos de aquellas clases que han implementado esta interfaz e instanciarlos. Por ejemplo:</p> <pre><code>List a = new ArrayList();\nList b = new LinkedList();\nList c = new Vector(); List d = new Stack(); </code></pre> <p>De estas implementaciones, <code>ArrayList</code> es la m\u00e1s utilizada.</p>"},{"location":"ud6/1list/#arraylist","title":"ArrayList","text":"<p>La primera clase de la que vamos a hablar es <code>ArrayList</code>. Un <code>ArrayList</code> como su nombre indica basa su implementaci\u00f3n de una lista en un array. Es un array din\u00e1mico en tama\u00f1o (es decir, de tama\u00f1o variable), pudiendo agrandarse el n\u00famero de elementos o disminuirse de forma autom\u00e1tica. Implementa todos los m\u00e9todos de la interfaz List y permite incluir elementos null.</p> <p>Un <code>ArrayList</code> no permite almacenar tipos de datos primitivos, solo puede almacenar objetos. Al contrario que un array que permit\u00eda almacenar ambos. Sin embargo, desde Java 5, las primitivas se convierten autom\u00e1ticamente en objetos, gracias a los Wrappers.</p> <p><code>ArrayList</code> forma parte de <code>Collection</code> en Java. Por lo tanto, a diferencia de los arrays que para acceder a los elementos se hac\u00eda usando [], en <code>ArrayList</code> tenemos un  conjunto de m\u00e9todos para acceder a los elementos y modificarlos.</p>"},{"location":"ud6/1list/#crear-un-arraylist","title":"Crear un <code>ArrayList</code>","text":"<p>Para crear un <code>ArrayList</code> en IntelliJ escribimos:</p> <p></p> <p>Si nos fijamos nos aparece una <code>&lt;E&gt;</code>, esto quiere decir que cuando creamos un <code>ArrayList</code> no le estamos diciendo el tipo como hac\u00edamos con los arrays: <code>int[] array;</code>. Por tanto, para crear un <code>ArrayList</code> que almacena objetos necesitamos decirle qu\u00e9 tipo de datos vamos a almacenar en nuestra lista.</p> <p></p> <p>En el ejemplo hemos creado una lista que contendr\u00e1 elementos de tipo <code>String</code>. Y si nos fijamos no le hemos especificado ning\u00fan tama\u00f1o como hac\u00edamos en los arrays puesto que Java maneja el tama\u00f1o por nosotros autom\u00e1ticamente.</p>"},{"location":"ud6/1list/#anadir-item-al-arraylist","title":"A\u00f1adir \u00edtem al <code>ArrayList</code>","text":"<p>Para agregar un \u00edtem o elemento a la lista utilizaremos los m\u00e9todos que nos provee la interfaz <code>List</code>:</p> <p></p> <p>El m\u00e9todo <code>add</code> agrega autom\u00e1ticamente el elemento en la lista. <code>ArrayList</code> es el que tiene toda la funcionalidad sobre d\u00f3nde guardarlo (posici\u00f3n) y cantidad de espacio para asignar. Eso es abstracto para nosotros y no tenemos que preocuparnos por ello.</p>"},{"location":"ud6/1list/#imprimir-los-elementos-del-arraylist","title":"Imprimir los elementos del <code>ArrayList</code>","text":""},{"location":"ud6/1list/#modificar-un-item-en-una-posicion-del-arraylist","title":"Modificar un \u00edtem en una posici\u00f3n del <code>ArrayList</code>","text":""},{"location":"ud6/1list/#eliminar-un-item-de-un-arraylist","title":"Eliminar un \u00edtem de un <code>ArrayList</code>","text":"<p>El m\u00e9todo remove elimina el elemento de la lista y deja la lista ordenada, es decir, si tuvi\u00e9ramos una lista con los siguientes productos: [\"Leche\", \"Tomate\", \"Lechuga\", \"Carne\"] y elimin\u00e1ramos el producto <code>Tomate</code>, la lista quedar\u00eda: [\"Leche\", \"Lechuga\", \"Carne\"], los \u00edtem se mover\u00edan de posiciones. Todo eso lo hace Java autom\u00e1ticamente por nosotros.</p>"},{"location":"ud6/1list/#copiar-todo-el-contenido-del-un-arraylist-a-otro","title":"Copiar todo el contenido del un <code>ArrayList</code> a otro","text":"<p>Se puede hacer de varias formas:</p> <pre><code>//Forma 1\nArrayList&lt;String&gt; newArray = new ArrayList&lt;String&gt;();\nnewArray.addAll(productosList);\n\n//Forma 2\nArrayList&lt;String&gt; newArray2 = new ArrayList&lt;String&gt;(productosList);\n\n//Forma 3 - Copiar un ArrayList a un array\nString[] myArray = new String[productosList.size()];\nmyArray = productosList.toArray(myArray);\n</code></pre>"},{"location":"ud6/1list/#buscar-un-item-en-el-arraylist","title":"Buscar un \u00edtem en el <code>ArrayList</code>","text":""},{"location":"ud6/1list/#comprobar-si-existe-un-item-en-el-arraylist","title":"Comprobar si existe un \u00edtem en el <code>ArrayList</code>","text":"<pre><code>public class ProductList {\n\nprivate ArrayList&lt;String&gt; productosList = new ArrayList&lt;String&gt;();\n\npublic void addProduct(String item) {\nproductosList.add(item);\n}\n\npublic void printProductList() {\nSystem.out.println(\"Tenemos \"  + productosList.size() + \" elementos en el arrayList\");\nfor(int i = 0; i &lt; productosList.size(); i++) {\nSystem.out.println(productosList.get(i));\n}\n}\n\npublic void modifyProductItem(int index, String newItem) {\nproductosList.set(index, newItem);\n}\n\npublic void removeProductItem(int index) {\nString item = productosList.get(index);\nproductosList.remove(item);\n}\n\npublic boolean existsItem(String searchItem) {\nreturn productosList.contains(searchItem);\n}\n\npublic String findItem(String searchItem) {\nint index = productosList.indexOf(searchItem);\nif (index &gt;= 0) {\nreturn productosList.get(index);\n}\nreturn null;\n}\n}\n</code></pre>"},{"location":"ud6/1list/#main","title":"Main","text":"<p>Vamos a crear una clase principal <code>Main</code> con un m\u00e9todo <code>main</code>que imprimir\u00e1 un men\u00fa de opciones relacionadas con la lista de productos y realizar\u00e1 sus respectivas acciones.</p> <pre><code>public class MainList {\n\nprivate static Scanner scanner = new Scanner(System.in);\nprivate static ProductList productList = new ProductList();\n\npublic static void imprimirMenu() {\nSystem.out.println(\"0 - Para imprimir menu\");\nSystem.out.println(\"1 - Para imprimir productos\");\nSystem.out.println(\"2 - Para a\u00f1adir\");\nSystem.out.println(\"3 - Para modificar\");\nSystem.out.println(\"4 - Para eliminar\");\nSystem.out.println(\"5 - Para salir\");\n}\n\npublic static void addItem() {\nSystem.out.println(\"Inserta el producto: \");\nproductList.addProduct(scanner.nextLine());\n}\n\npublic static void modifyItem() {\nSystem.out.println(\"Inserta n\u00famero de posici\u00f3n: \");\nint index = scanner.nextInt();\nscanner.nextLine();\nSystem.out.println(\"Escribe el nuevo producto:\");\nString newItem = scanner.nextLine();\nproductList.modifyProductItem(index, newItem);\n}\n\npublic static void removeItem() {\nSystem.out.println(\"Inserta n\u00famero de posici\u00f3n: \");\nint index = scanner.nextInt();\nscanner.nextLine();\nproductList.removeProductItem(index);\n}\n\npublic static void main(String[] args) {\nboolean continuar = true;\nint opcion = 0;\nimprimirMenu();\n\nwhile(continuar) {\nSystem.out.println(\"Elige una opci\u00f3n: \");\nopcion = scanner.nextInt();\nscanner.nextLine();\n\nswitch (opcion) {\ncase 0:\nimprimirMenu();\nbreak;\ncase 1:\nproductList.printProductList();\nbreak;\ncase 2:\naddItem();\nbreak;\ncase 3:\nmodifyItem();\nbreak;\ncase 4:\nremoveItem();\nbreak;\ncase 5:\ncontinuar = false;\nbreak;\n}\n}\n}\n}\n</code></pre>"},{"location":"ud6/1list/#buenas-practicas","title":"Buenas pr\u00e1cticas","text":"<p>Si nos fijamos, el m\u00e9todo para modificar un \u00edtem de la lista espera recibir un \u00edndice o posici\u00f3n donde se encuentra el elemento. Pero eso puede se peligroso, puesto que, sabemos que las posiciones empiezan por 0, pero a lo mejor el usuario no lo sabe y piensan que empiezan por 1. Por tanto, no sabemos a qu\u00e9 posici\u00f3n apunta realmente el \u00edndice que recibimos.</p> <p>Una buena pr\u00e1ctica es crear otro m\u00e9todo que se le pase el nombre, buscarlo y devolver la posici\u00f3n en la lista:</p> <pre><code>public void modifyProductItem(String actualItem, String newItem) {\nint index = findItem(actualItem);\nif (index &gt;= 0) {\nmodifyProductItem(index, newItem);\n}\n}\n\nprivate void modifyProductItem(int index, String newItem) {\nproductosList.set(index, newItem);\n}\n\npublic int findItem(String searchItem) {\nreturn productosList.indexOf(searchItem);\n}\n</code></pre> <p>Ejercicio. Haz lo mismo con el m\u00e9todo de eliminar elemento.</p>"},{"location":"ud6/2linkedlist/","title":"<code>LinkedList</code>","text":"<p>Una <code>LinkedList</code> en Java es una implementaci\u00f3n de lista doblemente enlazada. Admite duplicados.</p> <p>Cada elemento de la lista almacena el enlace real al siguiente elemento de la lista as\u00ed como tambi\u00e9n el valor real que se desea almacenar.</p> <p><code>LinkedList</code> no es un array, sino una cola de dos extremos de elementos conectados entre s\u00ed. El primer elemento apunta al segundo, que apunta al tercero, y as\u00ed sucesivamente. Internamente, LinkedList se implementa utilizando la estructura de datos de lista doblemente enlazada. La principal diferencia entre una lista enlazada normal y una lista doblemente enlazada es que una lista doblemente enlazada contiene un puntero adicional, normalmente llamado puntero anterior, junto con el puntero siguiente y los datos que est\u00e1n en la lista enlazada individualmente.</p> <p></p> <p>ArrayList contiene un \u00fanico array para el almacenamiento de datos. LinkedList necesita una estructura de datos personalizada. Esta estructura de datos personalizada es conocida como Nodo. Es una peque\u00f1a clase interna que sirve como envoltorio para cada elemento.</p> <p>El primer puntero conocido como head, apunta al primer nodo y se actualiza cada vez que se inserta un nuevo nodo al principio. El puntero que apunta al \u00faltimo nodo es conocido como tail y tambi\u00e9n se actualiza cada vez que se agrega un nuevo elemento al final.</p>"},{"location":"ud6/2linkedlist/#crear-y-anadir-items-en-una-linkedlist","title":"Crear y a\u00f1adir \u00edtems en una <code>LinkedList</code>","text":"<pre><code>LinkedList&lt;String&gt; lugares = new LinkedList&lt;String&gt;();\nlugares.add(\"Roma\");\nlugares.add(\"Par\u00eds\");\nlugares.add(\"Amsterdam\");\nlugares.add(\"Toronto\");\nlugares.add(\"Miami\");\n</code></pre>"},{"location":"ud6/2linkedlist/#iterar-una-linkedlist","title":"Iterar una <code>LinkedList</code>","text":"<p>Para iterar una lista vamos a usar el concepto de iterador. Un iterador es una forma de acceder a cada uno de los elementos de una lista, arrayList, linkedlist, etc. Es el equivalente a un bucle for que hemos estado usando hasta ahora.</p> <pre><code>public static void printList(LinkedList&lt;String&gt; lugares) {\nIterator&lt;String&gt; it = lugares.iterator();\nwhile (it.hasNext()) {\nSystem.out.println(\"Nodo: \" + it.next());\n}\nSystem.out.println(\"-----\");\n}\n</code></pre> <p><code>i.next()</code>: primero devuelve el nodo actual y luego se mueve al siguiente elemento. Hasta que no usamos .next() no se sit\u00faa en el primer nodo. La primera l\u00ednea de c\u00f3digo solo es para montar y establecer el iterador.</p>"},{"location":"ud6/2linkedlist/#insertar-elementos-en-orden","title":"Insertar elementos en orden","text":"<p>Para insertar elementos en un orden espec\u00edfico se usa un <code>ListIterator</code> ya que proporcionar mayor flexibilidad y est\u00e1 creado para situaciones como esa. Te permite volver a los elementos anteriores.</p> <pre><code>private static boolean addInOrder(LinkedList&lt;String&gt; lugares, String newItem) {\nListIterator&lt;String&gt; it = lugares.listIterator();\nwhile (it.hasNext()) {\nint comparacion = it.next().compareTo(newItem);\nif (comparacion == 0) {\n//no queremos a\u00f1adir porque no queremos tener duplicados\nSystem.out.println(\"el lugar \" + newItem + \" ya est\u00e1 incluido\");\nreturn false;\n} else if (comparacion &gt; 0) { //newItem es m\u00e1s peque\u00f1o\nit.previous();\nit.add(newItem);\nreturn true;\n}\n}\nit.add(newItem);\nreturn true;\n}\n</code></pre>"},{"location":"ud6/2linkedlist/#ejemplo-de-clase-de-visitar-lugares","title":"Ejemplo de clase de Visitar Lugares","text":"<p>Utilizamos un list iterator para ir hacia adelante y hacia atr\u00e1s.</p> <pre><code>public static void visitarLugar(LinkedList&lt;String&gt; lugares) {\nScanner scanner = new Scanner(System.in);\nboolean continuar = true;\nListIterator&lt;String&gt; it = lugares.listIterator();\n\nif (lugares.isEmpty()) {\nSystem.out.println(\"No hay lugares visitados\");\nreturn;\n} else {\nSystem.out.println(\"Visitando \" + it.next());\nimprimirMenu();\n}\n\nboolean haciaAdelante = true;\nwhile(continuar) {\nint opcion = scanner.nextInt();\nscanner.nextLine();\nswitch (opcion) {\ncase 0:\nSystem.out.println(\"Se acabaron las vacaciones\");\ncontinuar = false;\nbreak;\ncase 1:\nif (!haciaAdelante) {\nif (it.hasNext())\nit.next();\nhaciaAdelante = true;\n}\nif (it.hasNext()) {\nSystem.out.println(\"Visitando \" + it.next());\n} else {\nSystem.out.println(\"Ya no hay m\u00e1s ciudades\");\nhaciaAdelante = false;\n}\nbreak;\ncase 2:\nif(haciaAdelante) {\nif (it.hasPrevious())\nit.previous();\nhaciaAdelante = false;\n}\nif (it.hasPrevious()) {\nSystem.out.println(\"Visitando \" + it.previous());\n} else {\nSystem.out.println(\"Primera ciudad\");\nhaciaAdelante = true;\n}\nbreak;\ncase 3:\nimprimirMenu();\nbreak;\n}\n}\n}\n\npublic static void imprimirMenu() {\nSystem.out.println(\"0 - Para salir\\n\" +\n\"1 - para ir a la siguiente ciudad\\n\" +\n\"2 - para ir a la ciudad anterior\\n\" +\n\"3 - imprimir el men\u00fa\");\n}\n</code></pre>"},{"location":"ud6/3innerclass/","title":"Clases anidadas (Nested classes)","text":"<p>En Java, al igual que los m\u00e9todos, las variables de una clase tambi\u00e9n pueden tener otra clase como miembro. Java permite escribir una clase dentro de otra. La clase escrita dentro se denomina clase anidada o clase interna, y la clase que contiene la clase interna se denomina clase externa.</p>"},{"location":"ud6/3innerclass/#sintaxis","title":"Sintaxis","text":"<p>La clase <code>Outer_Demo</code> es la clase externa y la clase <code>Inner_Demo</code> es la clase interna.</p> <pre><code>class Outer_Demo {\nclass Inner_Demo {\n}\n}\n</code></pre> <p>Las clases anidadas se dividen en dos tipos:</p> <ul> <li>Clases anidadas no est\u00e1ticas: son las llamadas clases internas (inner classes).</li> <li>Clases est\u00e1ticas anidadas.</li> </ul> <pre><code>class OuterClass {\n...\nclass InnerClass {\n...\n}\nstatic class StaticNestedClass {\n...\n}\n}\n</code></pre> <p></p> <p>Una clase anidada es un miembro de su clase envolvente. Las clases anidadas no est\u00e1ticas (clases internas) tienen acceso a otros miembros de la clase envolvente, incluso si se declaran como privadas. Las clases anidadas est\u00e1ticas no tienen acceso a otros miembros de la clase envolvente. Como miembro de <code>OuterClass</code>, una clase anidada se puede declarar <code>private</code>, <code>public</code>, <code>protected</code>.</p>"},{"location":"ud6/3innerclass/#por-que-usar-clases-anidadas","title":"\u00bfPor qu\u00e9 usar clases anidadas?","text":"<ol> <li> <p>Es una forma de agrupar l\u00f3gicamente las clases que solo se usan en un lugar: si una clase es \u00fatil solo para otra clase, entonces es l\u00f3gico incrustarla en esa clase y mantener las dos juntas. Anidar tales \"clases de ayuda\" hace que su paquete sea m\u00e1s optimizado.</p> </li> <li> <p>Aumenta la encapsulaci\u00f3n: sabemos que una clase no se puede declarar <code>private</code>, pero si tenemos la clase como miembro de otra clase, entonces la clase interna se puede hacer privada. Y esto tambi\u00e9n se usa para acceder a los miembros privados de una clase.</p> </li> <li> <p>Puede conducir a un c\u00f3digo m\u00e1s legible y mantenible: anidar clases peque\u00f1as dentro de clases de nivel superior coloca el c\u00f3digo m\u00e1s cerca de donde se usa.</p> </li> </ol>"},{"location":"ud6/3innerclass/#clase-interna-inner-class-no-estatica-clase-anidada","title":"Clase Interna (Inner Class) - No est\u00e1tica clase anidada","text":"<p>Al igual que con los m\u00e9todos y variables de instancia, una clase interna est\u00e1 asociada con una instancia de su clase envolvente y tiene acceso directo a los m\u00e9todos y campos de ese objeto. Adem\u00e1s, debido a que una clase interna est\u00e1 asociada con una instancia, no puede definir ning\u00fan miembro est\u00e1tico en s\u00ed misma.</p> <p>Las clases internas son de tres tipos dependiendo de c\u00f3mo y d\u00f3nde se definan:</p> <ol> <li>Clase  - Inner Class</li> <li>Clase interna de m\u00e9todo local - Method-local Inner Class</li> <li>Clase interna an\u00f3nima - Anonymous Inner Class</li> </ol>"},{"location":"ud6/3innerclass/#inner-class","title":"Inner class","text":"<p>Crear una clase interna es bastante simple. Solo hay que escribir una clase dentro de una clase. A diferencia de una clase, una clase interna puede ser privada y una vez que declaras privada una clase interna, no se puede acceder a ella desde un objeto fuera de la clase.</p> <p>Los objetos que son instancias de una clase interna existen dentro de una instancia de la clase externa.</p> <pre><code>class OuterClass {\n\nprivate int num = 32;\n\nclass InnerClass {\n\npublic int getNum() {\nreturn num;\n}\n\n}\n}\n\npublic class Main {\n\npublic static void main(String args[]) {\nOuterClass outer = new OuterClass();\n\nOuterClass.InnerClass inner = outer.new InnerClass();\nSystem.out.println(inner.getNum());\n}\n}\n</code></pre> <p>Una instancia de <code>InnerClass</code> solo puede existir dentro de una instancia de <code>OuterClass</code> y tiene acceso directo a los m\u00e9todos y campos de su instancia adjunta.</p> <p>Para instanciar una clase interna, primero debe instanciar la clase externa.</p>"},{"location":"ud6/3innerclass/#clase-interna-de-metodo-local","title":"Clase interna de m\u00e9todo local","text":"<p>En Java, podemos escribir una clase dentro de un m\u00e9todo y esta ser\u00e1 de tipo local. Al igual que las variables locales, el alcance de la clase interna est\u00e1 restringido dentro del m\u00e9todo.</p> <p>Una clase interna local de m\u00e9todo solo se puede instanciar dentro del m\u00e9todo donde se define la clase interna.</p> <pre><code>public class Outerclass {\n\nvoid my_Method() {\nint num = 23;\n\n// method-local inner class\nclass MethodInner_Demo {\npublic void print() {\nSystem.out.println(\"This is method inner class \"+num);\n}   } // end of inner class\n\n// Accessing the inner class\nMethodInner_Demo inner = new MethodInner_Demo();\ninner.print();\n}\n\npublic static void main(String args[]) {\nOuterclass outer = new Outerclass();\nouter.my_Method();\n}\n}\n</code></pre>"},{"location":"ud6/3innerclass/#clase-interna-anonima","title":"Clase interna an\u00f3nima","text":"<p>Una clase interna declarada sin un nombre de clase se conoce como clase interna an\u00f3nima. En el caso de clases internas an\u00f3nimas, las declaramos y las instanciamos al mismo tiempo. Por lo general, se utilizan siempre que necesite anular el m\u00e9todo de una interfaz o clase abstracta.</p> <p>Las clases an\u00f3nimas permiten hacer el c\u00f3digo m\u00e1s conciso. Permiten declarar e instanciar una clase al mismo tiempo. Son como clases locales excepto que no tienen nombre. Se usa si se necesita usar una clase local solo una vez.</p>"},{"location":"ud6/3innerclass/#ejemplo-1","title":"Ejemplo 1","text":"<pre><code>interface Greeting {\npublic void greet();\npublic void greetSomeone(String someone);\n}\n\nclass Main {\npublic static void main(String[] args) {\n//Anonymous class\nGreeting frenchGreeting = new Greeting() {\nString name = \"tout le monde\";\npublic void greet() {\ngreetSomeone(\"tout le monde\");\n}\npublic void greetSomeone(String someone) {\nname = someone;\nSystem.out.println(\"Salut \" + name);\n}\n};\n}\n}\n</code></pre>"},{"location":"ud6/3innerclass/#ejemplo-2","title":"Ejemplo 2","text":"<pre><code>abstract class AnonymousInner {\npublic abstract void mymethod();\n}\n\npublic class OuterClass {\n\npublic static void main(String args[]) {\n\nAnonymousInner inner = new AnonymousInner() {\npublic void mymethod() {\nSystem.out.println(\"This is an example of anonymous inner class\");\n}\n};\ninner.mymethod();\n}\n}\n</code></pre>"},{"location":"ud6/3innerclass/#clases-anidadas-estaticas","title":"Clases Anidadas Est\u00e1ticas","text":"<p>Una clase interna est\u00e1tica es una clase anidada que es un miembro est\u00e1tico de la clase externa. Se puede acceder a ella sin instanciar la clase externa, usando otros miembros est\u00e1ticos. Al igual que los miembros est\u00e1ticos, una clase anidada est\u00e1tica no tiene acceso a las variables de instancia ni a los m\u00e9todos de la clase externa.</p> <pre><code>class MyOuter {\nstatic class NestedDemo {\n}\n}\n</code></pre> <p>Crear una instancia de una clase anidada est\u00e1tica es un poco diferente de crear una instancia de una clase interna.</p> <pre><code>class Outer {\nprivate int x = 0;\n\nstatic class Inner {\nprivate int y = 9;\n\npublic int getY() {\nreturn y;\n}\n}\n}\npublic class StaticNestedClass {\npublic static void main(String[] args) {\nOuter.Inner inner = new Outer.Inner();\nSystem.out.println(inner.getY());\n}\n}\n</code></pre>"},{"location":"ud6/3innerclass/#ejemplo-combinado-clase-interna-y-clase-estatica-interna","title":"Ejemplo combinado Clase interna y clase est\u00e1tica interna","text":"<pre><code>class OuterClass {\n\nprivate String outerField = \"Outer field\";\nprivate static String staticOuterField = \"Static outer field\";\n\nclass InnerClass {\nvoid accessMembers() {\nSystem.out.println(outerField);\nSystem.out.println(staticOuterField);\n}\n}\n\nstatic class StaticNestedClass {\nvoid accessMembers(OuterClass outer) {\n// Compiler error: Cannot make a static reference to the non-static\n//     field outerField\n//System.out.println(outerField);\nSystem.out.println(outer.outerField);\nSystem.out.println(staticOuterField);\n}\n}\n\npublic static void main(String[] args) {\nSystem.out.println(\"Inner class:\");\nSystem.out.println(\"------------\");\nOuterClass outerObject = new OuterClass();\nOuterClass.InnerClass innerObject = outerObject.new InnerClass();\ninnerObject.accessMembers();\n\nSystem.out.println(\"\\nStatic nested class:\");\nSystem.out.println(\"--------------------\");\nStaticNestedClass staticNestedObject = new StaticNestedClass();\nstaticNestedObject.accessMembers(outerObject);\n}\n}\n</code></pre>"},{"location":"ud6/4map/","title":"Map","text":"<p>Aunque las estructura de datos <code>Map</code> no forma parte dentro de la jerarqu\u00eda de la interfaz <code>Collection</code>, se considera una interfaz de colecci\u00f3n principal de Java Collections Framework.</p> <p></p> <p>Un <code>Map</code> es un objeto que asigna claves a valores. Un mapa no puede contener claves duplicadas: cada clave puede asignarse a un valor como m\u00e1ximo. Sin embargo, los valores asignados a la clave pueden tener valores duplicados. La interfaz <code>Map</code> incluye m\u00e9todos para operaciones b\u00e1sicas (como put, get, remove, containsKey, containsValue, size, y empty) entre muchos otros.</p> <p></p> <p>La plataforma Java contiene tres implementaciones de <code>Map</code>: <code>HashMap</code>, <code>TreeMap</code> y <code>LinkedHashMap</code>.</p>"},{"location":"ud6/4map/#crear-un-mapa","title":"Crear un Mapa","text":"<p>Para crear un objeto <code>Map</code> podemos usar cualquiera de las implementaciones para esta interfaz (<code>HashMap</code>, <code>TreeMap</code> y <code>LinkedHashMap</code>), por ejemplo:</p> <pre><code>Map&lt;String, String&gt; idiomas = new HashMap&lt;&gt;();\n</code></pre>"},{"location":"ud6/4map/#anadir-claves-y-valores-en-un-mapa","title":"A\u00f1adir claves y valores en un mapa","text":"<p>Para a\u00f1adir un par de clave-valor al mapa usamos el m\u00e9todo <code>put</code>:</p> <pre><code>public class MainMap {\n\npublic static void main(String[] args) {\nMap&lt;String, String&gt; idiomas = new HashMap&lt;&gt;();\nidiomas.put(\"es\", \"Espa\u00f1ol\");\nidiomas.put(\"en\", \"English EEUU\");\nidiomas.put(\"ca\", \"English Canad\u00e1\");\nidiomas.put(\"de\", \"Aleman\");\nidiomas.put(\"fr\", \"Franc\u00e9s\");\nidiomas.put(\"it\", \"Italian\");\n}\n}\n</code></pre> <p>Las claves de los mapas son \u00fanicas, si intentamos a\u00f1adir un nuevo valor para una clave que ya existe, el valor es sobreescrito.</p> <p>Para saber si estamos agregando una nueva clave o solo modificando el valor, el m\u00e9todo <code>put</code> nos ayuda, ya que devuelve el valor anterior asociado con la clave, o <code>null</code> si no hubo asignaci\u00f3n para la clave antes.</p> <p>Ejemplo:</p> <pre><code>Map&lt;String, String&gt; idiomas = new HashMap&lt;&gt;();\n\nidiomas.put(\"es\", \"Espa\u00f1ol\");\nidiomas.put(\"en\", \"English EEUU\");\nidiomas.put(\"ca\", \"English Canad\u00e1\");\nidiomas.put(\"de\", \"Aleman\");\nidiomas.put(\"fr\", \"Franc\u00e9s\");\nSystem.out.println(idiomas.put(\"it\", \"Italian\")); //devuelve null\nSystem.out.println(idiomas.put(\"it\", \"Italiano\")); //devuelve el valor previo \"Italian\", lo que significa que se ha sobreescrito\n</code></pre>"},{"location":"ud6/4map/#obtener-el-valor-para-una-clave","title":"Obtener el valor para una clave","text":"<p>Para obtener el valor asociado a una clave usamos el m\u00e9todo <code>get</code>:</p> <pre><code>String valor = idiomas.get(\"it\");\n</code></pre>"},{"location":"ud6/4map/#comprobar-si-una-clave-o-valor-existe","title":"Comprobar si una clave o valor existe","text":"<pre><code>if (idiomas.containsKey(\"es\")) {\nSystem.out.println(\"La clave es ya existe\");\n}\n\nif (idiomas.containsValue(\"Espa\u00f1ol\")) {\nSystem.out.println(\"El idioma espa\u00f1ol ya existe\");\n}\n</code></pre>"},{"location":"ud6/4map/#imprimir-todos-los-valores-del-map","title":"Imprimir todos los valores del <code>Map</code>","text":"<p>Lo haremos de la siguiente forma:</p> <pre><code>for(String key: idiomas.keySet()) {\nSystem.out.println(key + \" \" + idiomas.get(key));\n}\n</code></pre> <p>Al imprimir vemos que las claves no aparecen en ning\u00fan orden, ni en el que las hemos introducido ni en orden alfab\u00e9tico. Los elementos del <code>HashMap</code> no est\u00e1n ordenados.</p>"},{"location":"ud6/4map/#imprimir-cada-una-de-las-entradas-del-mapa","title":"Imprimir cada una de las entradas del mapa","text":"<p>Si queremos recorrer las entradas del mapa usaremos:</p> <pre><code>for (Map.Entry&lt;String, String&gt; entradaMapa: idiomas.entrySet()) {\nSystem.out.println(entradaMapa.getKey() + \" \" + entradaMapa.getValue());\n}\n</code></pre>"},{"location":"ud6/4map/#eliminar-una-entrada-clave-valor-de-un-map","title":"Eliminar una entrada clave-valor de un <code>Map</code>","text":"<p>Tenemos dos formas de eliminar:</p> <ol> <li>Eliminar desde una clave existente, o</li> <li>Eliminar un par clave-valor existente.</li> </ol> <pre><code>//Forma 1\nboolean eliminado = idiomas.remove(\"fr\");\n\n//Forma 2\nif (idiomas.remove(\"de\", \"Ingles\")) {\nSystem.out.println(\"de ha sido eliminado\");\n} else {\nSystem.out.println(\"No existe un par clave-valor con de-Ingles\");\n}\n</code></pre>"},{"location":"ud6/4map/#reemplazar-el-valor-de-una-clave","title":"Reemplazar el valor de una clave","text":"<pre><code>idiomas.replace(\"es\", \"Spain\");\nidiomas.replace(\"en\", \"English\", \"English EEUU\");//Reemplazo el antiguo valor por el nuevo, pero antes me aseguro que el antiguo valor sea ese dato antes de cambiarlo\n</code></pre>"},{"location":"ud6/4map/#hashmap","title":"<code>HashMap</code>","text":"<p><code>HashMap</code> es una estructura de datos que implementa la <code>Map&lt;Key,Value&gt;</code> interfaz y se basa en el principio de hash.</p> <p>Una funci\u00f3n hash es una funci\u00f3n que convierte datos de entrada de cualquier tama\u00f1o (generalmente grande) en datos de tama\u00f1o fijo, generalmente compactos. El resultado de esta funci\u00f3n de trabajo se llama c\u00f3digo hash.</p> <p>Cada objeto Java tiene un c\u00f3digo hash. Suele ser un n\u00famero y se calcula utilizando el m\u00e9todo hashCode de la clase Object.</p>"},{"location":"ud6/5set/","title":"Set (Conjunto)","text":"<p>La interfaz <code>Set</code> est\u00e1 contenida en el paquete java.util y extiende de la interfaz Collection, es una colecci\u00f3n desordenada de objetos en los que no se pueden almacenar valores duplicados. Esta interfaz contiene los m\u00e9todos heredados de la interfaz Collection y agrega una funci\u00f3n que restringe la inserci\u00f3n de elementos duplicados.</p> <p></p> <p>La interfaz <code>Set</code> define los m\u00e9todos b\u00e1sicos de a\u00f1adir, eliminar, comprobar tama\u00f1o, si est\u00e1 vac\u00edo, tambi\u00e9n podemos verificar si un elemento existe en el conjunto (Set). Pero no hay forma de obtener un elemento del conjunto. Es decir, podemos comprobar que algo existe y podemos iterar sobre los elementos del conjunto, pero no es posible obtener, por ejemplo, el elemento 3 del conjunto.</p> <p>Dado que <code>Set</code> es una interfaz, debe instanciar una implementaci\u00f3n concreta de la interfaz para poder usarla. Puede elegir entre las siguientes implementaciones de Set en la API de colecciones de Java:</p> <ul> <li>java.util.EnumSet</li> <li>java.util.HashSet</li> <li>java.util.LinkedHashSet</li> <li>java.util.TreeSet</li> </ul> <p>Una de las mejores implementaciones (con mejor rendimiento) de la interfaz <code>Set</code> es la clase <code>HashSet</code>, que utiliza tablas hashes para almacenar los elementos. Es muy parecido a la clase <code>HashMap</code> que hemos utilizado anteriormente.</p>"},{"location":"ud6/5set/#crear-un-set","title":"Crear un Set","text":"<p>Puedo crearme <code>Set</code> gen\u00e9rico sin especificar el tipo:</p> <pre><code>        Set setA = new HashSet();\nSet setB = new LinkedHashSet();\nSet setC = new TreeSet();\n</code></pre> <pre><code>Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();\n</code></pre>"},{"location":"ud6/5set/#anadir-elementos-en-un-set","title":"A\u00f1adir elementos en un Set","text":"<pre><code>Set&lt;String&gt; setA = new HashSet&lt;&gt;();\n\nsetA.add(\"element 1\");\nsetA.add(\"element 2\");\nsetA.add(\"element 3\");\n</code></pre>"},{"location":"ud6/5set/#recorrer-los-elementos-de-un-set","title":"Recorrer los elementos de un Set","text":"<p>Hay dos formas de iterar los elementos de un Java Set:</p> <ul> <li>Utilizando un <code>Iterator</code> obtenido de la interfaz <code>Set</code>.</li> <li>Usando un bucle for-each.</li> </ul> <p>Al iterar los elementos en el <code>Set</code>, el orden de los elementos depende de la implementaci\u00f3n que utilicemos para crear el <code>Set</code>.</p>"},{"location":"ud6/5set/#con-iterator","title":"Con Iterator","text":"<pre><code>Set&lt;String&gt; setA = new HashSet&lt;&gt;();\n\nsetA.add(\"element 1\");\nsetA.add(\"element 2\");\nsetA.add(\"element 3\");\n\nIterator&lt;String&gt; iterator = set.iterator();\n\nwhile(iterator.hasNext(){\nString element = iterator.next();\n}\n</code></pre>"},{"location":"ud6/5set/#con-bucle-for-each","title":"Con bucle for-each","text":"<pre><code>Set&lt;Integer&gt; set = new HashSet();\n\nfor(Integer num: set) {\nSystem.out.println(num);\n}\n</code></pre> <p>Si me he creado un set gen\u00e9rico, tengo que hacer un cast del objeto:</p> <pre><code>Set set = new HashSet();\n\nfor(Object object : set) {\nString element = (String) object;\n}\n</code></pre>"},{"location":"ud6/5set/#eliminar-elemento-de-un-set","title":"Eliminar elemento de un Set","text":"<pre><code>set.remove(\"object-to-remove\");\n</code></pre> <p>No hay forma de eliminar un objeto basado en el \u00edndice en un <code>Set</code>, ya que el orden de los elementos depende de la implementaci\u00f3n.</p>"},{"location":"ud6/5set/#eliminar-todos-los-elementos-de-un-set","title":"Eliminar todos los elementos de un Set","text":"<p>Para eliminar todos los elementos usamos el m\u00e9todo <code>clear()</code>:</p> <pre><code>set.clear();\n</code></pre>"},{"location":"ud6/5set/#tamano-de-un-set","title":"Tama\u00f1o de un Set","text":"<p>Para verificar el tama\u00f1o de un <code>Set</code> en Java se usa el m\u00e9todo size(). El tama\u00f1o de un Conjunto es el n\u00famero de elementos contenidos en el Conjunto.</p> <pre><code>Set&lt;String&gt; set = new HashSet&lt;&gt;();\n\nset.add(\"123\");\nset.add(\"456\");\nset.add(\"789\");\n\nint size = set.size();//el tama\u00f1o ser\u00e1 3\n</code></pre>"},{"location":"ud6/5set/#comprobar-si-esta-vacio","title":"Comprobar si est\u00e1 vac\u00edo","text":"<pre><code>Set&lt;String&gt; set = new HashSet&lt;&gt;();\n\nboolean isEmpty = set.isEmpty();\n</code></pre>"},{"location":"ud6/5set/#verificar-si-contiene-un-elemento","title":"Verificar si contiene un elemento","text":"<p>Para determinar si un conjunto contiene el elemento, se llama al m\u00e9todo <code>contains</code>, que internamente iterar\u00e1 sobre todos sus elementos y comparar\u00e1 cada elemento con el objeto pasado como par\u00e1metro. La comparaci\u00f3n utiliza el m\u00e9todo de <code>equals</code> de Java del elemento para verificar si el elemento es igual al par\u00e1metro.</p> <pre><code>Set&lt;String&gt; set = new HashSet&lt;&gt;();\n\nset.add(\"123\");\nset.add(\"456\");\n\nboolean contains123 = set.contains(\"123\");//devuelve true\n</code></pre> <p>Dado que es posible agregar valores nulos a un conjunto, tambi\u00e9n es posible verificar si el conjunto contiene un valor nulo. As\u00ed es como verifica si un conjunto contiene un valor nulo:</p> <pre><code>Set&lt;String&gt; set = new HashSet&lt;&gt;();\nset.add(null);\nboolean containsElement = set.contains(null);\n</code></pre>"},{"location":"ud6/5set/#convertir-set-en-list","title":"Convertir Set en List","text":"<p>Puede convertir los elementos de un <code>Set</code> en una <code>List</code> llamamos al m\u00e9todo addAll(), pasando el conjunto como par\u00e1metro.</p> <pre><code>Set&lt;String&gt; set = new HashSet&lt;&gt;();\nset.add(\"123\");\nset.add(\"456\");\n\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.addAll(set);\n</code></pre>"},{"location":"ud6/5set/#necesidad-de-sobreescribir-o-anular-metodo-equals-y-hashcode","title":"Necesidad de sobreescribir o anular m\u00e9todo <code>equals()</code> y <code>hashCode()</code>","text":"<p><code>HashMap</code> y <code>HashSet</code> usan el valor del c\u00f3digo hash de un objeto para averiguar c\u00f3mo se almacenar\u00eda el objeto en la colecci\u00f3n y, posteriormente, el c\u00f3digo hash se usa para ayudar a localizar el objeto en la colecci\u00f3n. La recuperaci\u00f3n de hash implica:</p> <ul> <li>Primero, encontrar el correcto lugar donde est\u00e1 almacenado usando hashCode().</li> <li>Segundo, buscar el elemento correcto usando equals().</li> </ul>"},{"location":"ud6/5set/#ejemplo","title":"Ejemplo","text":"<p>Cuando llamamos <code>map.put(g1, \u201cMARKETING\u201d);</code> generar\u00e1 un hash en alguna ubicaci\u00f3n y cuando llamemos a <code>map.put(g2, \"IT\");</code> generar\u00e1 el mismo valor hash (igual que g1) y reemplazar\u00e1 el primer valor por el segundo valor porque al iterar sobre la estructura encuentra que k.equals(g2) es verdadero, significa que la clave de b\u00fasqueda ya existe. Entonces, reemplaza el valor anterior de esa clave por un valor nuevo.</p> <p>Cuando Java compara dos objetos en estructuras de tipo hash (HashMap, HashSet etc) primero invoca al m\u00e9todo hashcode y luego el equals. Si los m\u00e9todos hashcode de cada objeto devuelven diferente hash no seguir\u00e1 comparando y considerar\u00e1 a los objetos distintos. En el caso en el que ambos objetos compartan el mismo hashcode Java invocar\u00e1 al m\u00e9todo equals() y revisar\u00e1 a detalle si se cumple la igualdad. De esta forma las b\u00fasquedas quedan simplificadas en estructuras hash.</p> <pre><code>class Persona {\n\nprivate String name;\nprivate int id;\n\nPersona(String name, int id) {\nthis.name = name;\nthis.id = id;\n}\n\n@Override\npublic boolean equals(Object o) {\nif (this == o) return true;\nif (o == null || getClass() != o.getClass()) return false;\nPersona persona = (Persona) o;\nreturn id == persona.id &amp;&amp; Objects.equals(nombre, persona.nombre);\n}\n\n@Override\npublic int hashCode() {\nreturn Objects.hash(nombre, id);\n}\n}\n\n\npublic static void main(String[] args) {\nPersona p1 = new Persona(\"Patricia\", 1);\nPersona p2 = new Persona(\"Patricia\", 1);\n\nSet&lt;Persona&gt; conjunto = new HashSet&lt;Persona&gt;();\nconjunto.add(p1);\nconjunto.add(p2);\n\nSystem.out.println(conjunto.contains(p1));\n}\n</code></pre>"},{"location":"ud6/5set/#operaciones-con-set","title":"Operaciones con <code>Set</code>","text":"<p>Dado que <code>Set</code> representa un conjunto, podemos realizar todas las operaciones matem\u00e1ticas b\u00e1sicas como intersecci\u00f3n, uni\u00f3n y diferencia.</p> <p>Supongamos que tenemos dos conjuntos, es decir, conjunto1 = [22, 45, 33, 66, 55, 34, 77] y conjunto2 = [33, 2, 83, 45, 3, 12, 55]. Podemos realizar la siguiente operaci\u00f3n en el Set:</p> <p></p> <ul> <li>Intersecci\u00f3n: La operaci\u00f3n de intersecci\u00f3n devuelve todos aquellos elementos que est\u00e1n presentes en ambos conjuntos. La intersecci\u00f3n de set1 y set2 ser\u00e1 [33, 45, 55].</li> <li>Uni\u00f3n: la operaci\u00f3n de uni\u00f3n devuelve todos los elementos de set1 y set2 en un solo conjunto, y ese conjunto puede ser set1 o set2. La uni\u00f3n de set1 y set2 ser\u00e1 [2, 3, 12, 22, 33, 34, 45, 55, 66, 77, 83].</li> <li>Diferencia: La operaci\u00f3n de diferencia elimina los valores del conjunto que est\u00e1n presentes en otro conjunto. La diferencia de set1 y set2 ser\u00e1 [66, 34, 22, 77].</li> </ul> <p>En <code>Set</code>, el m\u00e9todo <code>addAll()</code> se usa para realizar la uni\u00f3n, el m\u00e9todo de <code>retainAll()</code> se usa para realizar la intersecci\u00f3n y el m\u00e9todo <code>removeAll()</code> se usa para realizar la diferencia.</p>"},{"location":"ud6/6ordercollections/","title":"Colecciones ordenadas","text":"<p>Vamos a estudiar una variante del <code>HashMap</code> y <code>HashSet</code>, el <code>LinkedHashMap</code> y <code>LinkedHashSet</code>.</p> <p>Tambi\u00e9n est\u00e1n las versiones ordenadas del <code>HashMap</code> y el <code>HashSet</code> que son <code>TreeMap</code> y <code>TreeSet</code>.</p> <p>Como las operaciones entre <code>Map</code> y <code>Set</code> son muy similares nos centraremos en los mapas.</p>"},{"location":"ud6/6ordercollections/#linkedhashmap","title":"<code>LinkedHashMap</code>","text":"<p>La clase <code>LinkedHashMap</code> es como <code>HashMap</code> con una caracter\u00edstica adicional de mantener el orden de elementos insertados en ella.</p> <p><code>HashMap</code> proporciona la ventaja de una r\u00e1pida inserci\u00f3n, b\u00fasqueda y borrado, pero NO mantiene el orden en el que se insertan los elementos. Con <code>LinkedHashMap</code> se puede acceder a los elementos en su orden de inserci\u00f3n.</p>"},{"location":"ud6/6ordercollections/#caracteristicas","title":"Caracter\u00edsticas","text":"<ul> <li>Un LinkedHashMap contiene valores basados en la clave.Implementa la interfaz del mapa y extiende la clase HashMap.</li> <li>Contiene solo elementos \u00fanicos.</li> <li>Solo puede tener una clave nula pero varios valores nulos.</li> <li>Es lo mismo que <code>HashMap</code> con una caracter\u00edstica adicional que mantiene el orden de inserci\u00f3n.</li> </ul> <p>Los datos se almacenan en forma de nodos. La implementaci\u00f3n de <code>LinkedHashMap</code> es muy similar a una lista doblemente enlazada. Por lo tanto, cada nodo del LinkedHashMap est\u00e1 representado como:</p> <p></p> <ul> <li>Hash: Todas las claves (keys) de entrada se convierten en un hash, que es una forma m\u00e1s corta de la clave para que la b\u00fasqueda y la inserci\u00f3n sean m\u00e1s r\u00e1pidas.</li> <li>Key: Dado que esta clase extiende <code>HashMap</code>, los datos se almacenan en forma de par clave-valor. Este par\u00e1metro es la clave de los datos.</li> <li>Value: Para cada clave, hay un valor asociado con \u00e9l.</li> <li>After: Dado que LinkedHashMap almacena la orden de inserci\u00f3n, contiene la direcci\u00f3n al siguiente nodo de la lista.</li> <li>Before: Este par\u00e1metro contiene la direcci\u00f3n al nodo anterior de la lista.</li> </ul>"},{"location":"ud6/6ordercollections/#treemap","title":"<code>TreeMap</code>","text":"<p>Java TreeMap es una estructura de datos que implementa la interfaz <code>Map&lt;Key,Value&gt;</code>, se basa en un \u00e1rbol binario y ordena por clave.</p> <p><code>TreeMap</code> es una implementaci\u00f3n de Map que mantiene sus entradas ordenadas seg\u00fan el orden natural de sus claves. Para n\u00fameros significa orden ascendente, para cadenas, orden alfab\u00e9tico. Sin embargo, es posible utilizar un comparador si necesita cambiar la l\u00f3gica.</p> <p><code>HashMap</code> le permite almacenar una clave nula y varios valores nulos. <code>TreeMap</code> ordena los elementos en orden natural y no permite claves nulas porque el m\u00e9todo <code>compareTo()</code> arroja <code>NullPointerException</code> si se compara con nulo.</p>"},{"location":"ud6/7final/","title":"Keyword Final","text":"<p>Generalmente, usamos la palabra reservada <code>final</code> para definir valores constantes. Pero en realidad, los campos o atributos finales no son constantes porque pueden modificarse. Pero SOLO una vez y cualquier modificaci\u00f3n debe realizarse antes de que finalice el constructor de la clase.</p> <p>Ejemplo: Podemos asignarle final a un campo de la clase y declararlo por primera vez en el constructor.</p> <pre><code>public class TestFinal {\n\nprivate final int numero;\n\npublic TestFinal(int n) {\nnumero = n;\n}\n}\n</code></pre> <pre><code>public class TestFinal {\n\nprivate final int numero = 0;\n\npublic TestFinal() {\n}\n}\n</code></pre> <p>Ambos c\u00f3digos hacen lo mismo.</p> <p>Cuando declaramos un atributo como final, IntelliJ es listo y no nos deja implementar el m\u00e9todo setter de ese atributo.</p> <p>Cuando queremos crear una variable constante de la que ya conocemos su valor, normalmente usamos <code>static final</code> y la nombramos en may\u00fasculas. Pero una variable final que cambia para cada instancia de la clase, no se nombra en may\u00fasculas.</p>"},{"location":"ud6/7final/#final-en-la-definicion-de-clase","title":"Final en la definici\u00f3n de clase","text":"<p>Si a\u00f1adimos la palabra <code>final</code> al crear una clase, lo que hacemos es NO permitir que se pueda extender de esa clase. Es decir, no puede tener hijos que hereden de ella.</p> <p>Ejemplo:</p> <pre><code>public final class Coche {\n\n}\n</code></pre>"},{"location":"ud6/7final/#final-en-la-definicion-de-metodos","title":"Final en la definici\u00f3n de m\u00e9todos","text":"<p>A veces queremos, heredar de una clase, pero no queremos que se puedan sobreescribir o anular todos los m\u00e9todos de la clase padre en los hijos porque a lo mejor son m\u00e9todos que tienen una cierta funcionalidad que no cambia. Es decir, queremos prevenir que modifiquen su comportamiento. Para realizar esto declaramos los m\u00e9todos como final.</p> <p>Los \u00fanicos m\u00e9todos que no pueden declararse como final son los constructores, ya que no se heredan.</p> <pre><code>class Perro {\n\n@Override\npublic void mover() {\n\n}\n\n}\npublic class Animal {\n\npublic final void comer() {\n//este m\u00e9todo no puede sobreescribirse en los hijos\n}\n\npublic void mover() {\n//este m\u00e9todo se puede sobreescribir\n}\n}\n</code></pre>"},{"location":"ud6/7final/#bloque-estaticos","title":"Bloque est\u00e1ticos","text":"<p>El bloque est\u00e1tico se usa para inicializar las variables est\u00e1ticas. Este bloque se ejecuta cuando la clase se carga en la memoria. Una clase puede tener varios bloques est\u00e1ticos, que se ejecutar\u00e1n en la misma secuencia en la que se escribieron en el programa. Se ejecutan antes que los constructores.</p> <p>Los bloques est\u00e1ticos de inicializaci\u00f3n son equivalentes a los constructores. Los constructores como bien sabemos son constructores de instancias de la clase, como no son est\u00e1ticos, se ejecutan cada vez que se crea una nueva instancia de la clase.</p> <p>Como hemos dicho, el equivalente a los constructores en su versi\u00f3n est\u00e1tica, son los bloques est\u00e1ticos de inicializaci\u00f3n, la diferencia es que el bloque est\u00e1tico SOLO se ejecuta una vez cuando se carga la clase.</p> <p>Al igual que las variables finales pueden inicializarse en el constructor. Las variables est\u00e1ticas finales pueden hacerlo en los bloques est\u00e1ticos de inicializaci\u00f3n.</p> <pre><code>class Test {\n\nprivate static int num;\nprivate static final int x;\n\nstatic{\nnum = 68;\nx = 9;\n}\n\n}\n</code></pre>"},{"location":"ud6/8hashcode_equals/","title":"Necesidad de Java Equals y Hashcode","text":"<p>Los m\u00e9todos Java <code>equals()</code> y <code>hashCode()</code> est\u00e1n presentes en la clase <code>Object</code>. Como todas las clases heredan de la clase Object de forma autom\u00e1tica reciben una implementaci\u00f3n predeterminada de equals() y hashCode() sino se sobreescribe.</p> <p>El m\u00e9todo equals() sirve para comparar instancias de clases entre s\u00ed. Si usamos colecciones como las que hemos visto en el tema: ArrayList, LinkedList... muchos de sus m\u00e9todos (contains, remove, indexOf, etc.) llaman al m\u00e9todo equals internamente para encontrar el objeto. Es decir, van comparando el objeto con los que hay en la lista.</p> <p>A veces cuando creamos colecciones donde el tipo de dato es un Objeto definido por nosotros, como Persona, Coche, etc. Necesitamos de alg\u00fan m\u00e9todo que nos permita comparar objetos de este tipo.</p> <p>Los m\u00e9todos Java hashCode() y equals() se utilizan conjuntamente en implementaciones basadas en tablas Hash en Java para almacenar y recuperar datos.</p>"},{"location":"ud6/8hashcode_equals/#equals","title":"Equals","text":"<p>Lo heredamos autom\u00e1ticamente de Object de la siguiente forma:</p> <pre><code>//Dos objetos son iguales, si son el mismo objeto\npublic boolean equals(Object obj) {\nreturn (this == obj);\n}\n</code></pre> <p>En ocasiones, queremos cambiar la l\u00f3gica de la implementaci\u00f3n de <code>Object</code> por otra l\u00f3gica que nos diga si dos instancias de una clase son equivalentes a pesar de tratarse de distintos objetos. Por ejemplo, teniendo en cuenta los atributos de la clase que nosotros le indiquemos para ello.</p> <p>En el siguiente ejemplo tenemos la clase Client, en nuestra l\u00f3gica dos objetos de cliente son iguales si son del mismo tipo (Client) y comparten el mismo nombre.</p> Client.java<pre><code>public class Client {\n\nprivate String name;\nprivate int age;\n\n@Override\npublic boolean equals(Object o) {\nif (this == o) return true;\nif (o == null || getClass() != o.getClass()) return false;\nClient client = (Client) o;\nreturn Objects.equals(name, client.name);\n}\n}\n</code></pre>"},{"location":"ud6/8hashcode_equals/#contrato-equals-hashcode","title":"Contrato equals() - hashcode()","text":"<p>Cuando utilicemos estructuras de datos basadas en hash tables como HashMap, HashSet, LinkedHashMap, LinkedHashSet, Hashtable, ... necesitamos de un contrato equals - hashcode:</p> <p>Cuando sobreescribimos el m\u00e9todo equals() en nuestra clase para cambiar la l\u00f3gica que se hereda de la clase Object, tenemos que sobreescribir el m\u00e9todo hashCode() de manera que si dos instancias de nuestra clase son iguales seg\u00fan la nueva l\u00f3gica en equals(), el m\u00e9todo hashCode() deber\u00e1 retornar el mismo valor si lo llamo para dichas instancias.</p> <p>El m\u00e9todo <code>hashcode()</code> sirve para comparar objetos de una forma m\u00e1s r\u00e1pida en estructuras Hash ya que \u00fanicamente nos devuelve un n\u00famero entero. Cuando Java compara dos objetos en estructuras de tipo hash primero invoca al m\u00e9todo hashcode y luego el equals. Si los m\u00e9todos hashcode de cada objeto devuelven diferente hash no seguir\u00e1 comparando y considerar\u00e1 a los objetos distintos. En el caso en el que ambos objetos compartan el mismo hashcode Java invocar\u00e1 al m\u00e9todo equals() y revisar\u00e1 si se cumple la igualdad.</p>"},{"location":"ud6/8hashcode_equals/#ejemplo","title":"Ejemplo","text":"<p>Muchas veces se nos olvida que la invocaci\u00f3n a los m\u00e9todos equals y hashcode forma parte intr\u00ednseca del framework de colecciones. Por ejemplo si construimos dos objetos de tipo Client y los a\u00f1adimos a un HashSet, podemos comprobar que el cliente existe utilizando el m\u00e9todo contains dentro del conjunto.</p> Main.java<pre><code>public static void main(String[] args) {\nClient p1= new Client();\np1.setName(\"Patricia\");\n\nClient p2= new Client();\np2.setName(\"Chema\");\n\nClient p3= new Client();\np3.setName(\"Patricia\");\n\nHashSet&lt;Client&gt; conjunto = new HashSet&lt;&gt;();\nconjunto.add(p1);\nconjunto.add(p2);\nconjunto.add(p3);\nSystem.out.println(conjunto.contains(p1));//true\nSystem.out.println(conjunto.size());//2\n}\n</code></pre> <p>Esto nos devolver\u00e1 true ya que el HashSet contiene este elemento. Ahora bien si nosotros sobreescribimos de forma incorrecta el hashcode con el siguiente c\u00f3digo:</p> <pre><code>    @Override\npublic int hashCode() {\nreturn (int)(Math.random()*100);\n}\n\npublic static void main(String[] args) {\nClient p1= new Client();\np1.setName(\"Patricia\");\n\nClient p2= new Client();\np2.setName(\"Chema\");\n\nClient p3= new Client();\np3.setName(\"Patricia\");\n\nHashSet&lt;Client&gt; conjunto = new HashSet&lt;&gt;();\nconjunto.add(p1);\nconjunto.add(p2);\nconjunto.add(p3);\nSystem.out.println(conjunto.contains(p1));//false\nSystem.out.println(conjunto.size());//3\n}\n</code></pre> <p>Estaremos calculando al azar el hashcode y dos objetos iguales devolver\u00e1n hashcodes diferentes. El <code>HashSet</code> nos devolver\u00e1 false cuando invoquemos el m\u00e9todo contains aunque sabemos que el elemento existe en el conjunto. Y tambi\u00e9n agregar\u00e1 duplicado ya que no encuentra el elemento.</p>"},{"location":"ud7/1generics/","title":"\ud83e\udd84 Gen\u00e9ricos","text":"<p>Antes de Java 5 cuando introduc\u00edamos objetos en una colecci\u00f3n estos se guardaban como objetos de tipo <code>Object</code>, aprovechando el polimorfismo para poder introducir cualquier tipo de objeto en la colecci\u00f3n. Esto nos obligaba a hacer un casting al tipo original al obtener los elementos de la colecci\u00f3n.</p> <pre><code>public class Ejemplo {  public static void main(String[] args) {  List lista = new ArrayList();  lista.add(\"Hola mundo\");  String cadena = (String) lista.get(0);  System.out.println(cadena);  }  } </code></pre> <p>Esta forma de trabajar no solo nos ocasiona tener que escribir m\u00e1s c\u00f3digo innecesariamente, sino que es propenso a errores porque carecemos de un sistema de comprobaci\u00f3n de tipos. Si introdujeramos un objeto de tipo incorrecto el programa compilar\u00eda pero lanzar\u00eda una excepci\u00f3n en tiempo de ejecuci\u00f3n al intentar convertir el objeto en <code>String</code>:</p> <pre><code>public class Ejemplo {  public static void main(String[] args) {  List lista = new ArrayList();  lista.add(22);  String cadena = (String) lista.get(0);  System.out.println(cadena);  } } </code></pre> <p>Desde Java 5 contamos con una caracter\u00edstica llamada generics que puede solventar esta clase de problemas. Los generics son una mejora al sistema de tipos que nos permite programar abstray\u00e9ndonos de los tipos de datos.</p> <p>Gen\u00e9ricos significa tipos parametrizados. La idea es permitir que el tipo (<code>Integer</code>, <code>String</code>, etc., y tipos definidos por el usuario) sea un par\u00e1metro para m\u00e9todos, clases e interfaces. Utilizando Generics, es posible crear clases que trabajen con diferentes tipos de datos. Una entidad como clase, interfaz o m\u00e9todo que opera en un tipo parametrizado es una entidad gen\u00e9rica.</p> <p>Gracias a los generics podemos especificar el tipo de objeto que introduciremos en la colecci\u00f3n, de forma que el compilador conozca el tipo de objeto que vamos a utilizar, evit\u00e1ndonos as\u00ed el casting. Adem\u00e1s, gracias a esta informaci\u00f3n, el compilador podr\u00e1 comprobar el tipo de los objetos que introducimos, y lanzar un error en tiempo de compilaci\u00f3n si se intenta introducir un objeto de un tipo incompatible, en lugar de que se produzca una excepci\u00f3n en tiempo de ejecuci\u00f3n.</p> <p>Para utilizar generics con nuestras colecciones tan solo tenemos que indicar el tipo entre el operador Diamond &lt;&gt; a la hora de crearla. A estas clases a las que podemos pasar un tipo como \u00abpar\u00e1metro\u00bb se les llama clases parametrizadas, clases gen\u00e9ricas o simplemente gen\u00e9ricas (generics).</p> <pre><code>public class Ejemplo {  public static void main(String[] args) {  List&lt;String&gt; lista = new ArrayList&lt;String&gt;();  lista.add(\"Hola mundo\");  String cadena = lista.get(0);  System.out.println(cadena);  }  } </code></pre> <p>El c\u00f3digo anterior no compilar\u00eda, si intent\u00e1ramos insertar en la lista un n\u00famero <code>lista.add(14);</code>, nos dar\u00eda un error de compilaci\u00f3n de tipos.</p> <p>Note</p> <p>Algo a tener en cuenta es que el tipo par\u00e1metro debe ser una clase; no podemos utilizar tipos primitivos.</p>"},{"location":"ud7/1generics/#clases-genericas","title":"\ud83e\udd84 Clases gen\u00e9ricas","text":"<p>Al crear una clase que utiliza o contiene alg\u00fan atributo gen\u00e9rico, me obliga a a\u00f1adir este tipo de gen\u00e9rico en la definici\u00f3n de clase. Por convenci\u00f3n se suele utilizar una sola letra may\u00fascula para el tipo gen\u00e9rico.</p> <p>Es decir, si mi clase tiene un atributo <code>T elemento</code> gen\u00e9rico que no s\u00e9 qu\u00e9 tipo de dato va a ser, entero, double, float.... le pongo una letra y con esto le digo que ese atributo es de tipo gen\u00e9rico, puede ser cualquier tipo de dato.</p> <pre><code>public class Box&lt;T&gt; {\n\nprivate T elemento;\n\npublic T get() { return elemento; }\npublic void set(T elemento) { this.elemento = elemento; }\n\n}\n</code></pre> <p>Seg\u00fan las convenciones los nombres de los par\u00e1metros de tipo usados com\u00fanmente son los siguientes:</p> <ul> <li>E: elemento de una colecci\u00f3n.</li> <li>K: clave.</li> <li>N: n\u00famero.</li> <li>T: tipo.</li> <li>V: valor.</li> <li>S, U, V etc: para segundos, terceros y cuartos tipos.</li> </ul> <p>En el momento de la instanciaci\u00f3n de un tipo gen\u00e9rico indicaremos el argumento para el tipo, en este caso Box contendr\u00e1 una referencia a un tipo Integer.</p> <pre><code>//Las dos formas son v\u00e1lidas:\nBox&lt;Integer&gt; integerBox1 = new Box&lt;Integer&gt;();\nBox&lt;Integer&gt; integerBox2 = new Box&lt;&gt;();\n\nBox&lt;String&gt; textoBox = new Box&lt;&gt;();\n</code></pre> <p>Estamos creando objetos de la clase <code>Box</code>, tanto de tipo Integer como String.</p> <p>A veces querremos limitar los tipos que pueden ser usados empleando lo que se denomina bounded type. Con \\&lt;T extends Number&gt; el tipo T debe extender la clase Number. Java permite m\u00faltiples l\u00edmites o bounded type: <code>&lt;T extends B1 &amp; B2 &amp; B3&gt;</code>. <code>Box</code> es una clase y <code>B1</code> y <code>B2</code> son interfaces. Primero siempre debe ir la clase y luego las interfaces. Recuerda que Java NO permite la herencia m\u00faltiple, por tanto, SOLO se puede extender de una clase, pero puede implementar varias interfaces en la declaraci\u00f3n del bounded type.</p>"},{"location":"ud7/1generics/#metodos-genericos","title":"\ud83e\udd84 M\u00e9todos gen\u00e9ricos","text":"<p>Al igual que ocurre con las clases, si me creo un m\u00e9todo gen\u00e9rico, es decir, que recibe tipos de datos gen\u00e9ricos \u00fanicos que no est\u00e1n definidos en la clase, tengo que especificar en la signatura del m\u00e9todo esos gen\u00e9ricos:</p> <p>Ejemplo</p> <pre><code>public static &lt;T, R&gt; void executeFunction(List&lt;T&gt; lista, Function&lt;T,R&gt; function) {\nfor(T t: lista) {\nSystem.out.println(function.apply(t));\n}\n}\n</code></pre>"},{"location":"ud7/2lambda/","title":"Expresiones lambda","text":"<p>Las expresiones lambda es una caracter\u00edstica importante que fue a\u00f1adida en Java 8. Es muy \u00fatil, ayuda a iterar, filtrar y extraer datos de la colecci\u00f3n.</p> <p>Una expresi\u00f3n lambda es un bloque corto de c\u00f3digo que toma par\u00e1metros y devuelve un valor. Las expresiones lambda son similares a los m\u00e9todos, pero no necesitan un nombre y se pueden implementar directamente en el cuerpo de un m\u00e9todo.</p> <p>La expresiones lambda de Java son tratadas como una funci\u00f3n, por lo que el compilador no crea un archivo .class.</p> <p>La expresi\u00f3n lambda proporciona la implementaci\u00f3n de una interfaz funcional. Una interfaz funcional es aquella que tiene UN SOLO m\u00e9todo abstracto. Las interfaces funcionales en Java incluyen la anotaci\u00f3n <code>@FunctionalInterface</code>.</p>"},{"location":"ud7/2lambda/#sintaxis","title":"Sintaxis","text":"<p>Dado que las expresiones lambda son efectivamente solo m\u00e9todos, las expresiones lambda pueden tomar par\u00e1metros como los m\u00e9todos.</p> <p>La expresi\u00f3n lambda de Java consta de tres componentes.</p> <ol> <li> <p>Par\u00e1metros - lista de argumentos: una expresi\u00f3n lambda puede tener cero o cualquier n\u00famero de argumentos.</p> </li> <li> <p>Token de flecha: se utiliza para vincular la lista de argumentos y el cuerpo de la expresi\u00f3n.</p> </li> <li> <p>Cuerpo: Contiene expresiones y declaraciones para la expresi\u00f3n lambda.</p> </li> </ol> <p>Las expresiones lambda se pueden almacenar en variables si el tipo de variable es una interfaz que tiene un solo m\u00e9todo. La expresi\u00f3n lambda debe tener la misma cantidad de par\u00e1metros y el mismo tipo de retorno que ese m\u00e9todo.</p>"},{"location":"ud7/2lambda/#cero-parametros","title":"Cero par\u00e1metros","text":"<p>Los par\u00e9ntesis no tienen contenido en el medio. Eso es para indicar que la expresi\u00f3n lambda no recibe par\u00e1metros.</p> <p>() -&gt; {body}</p> <pre><code>interface Saludo{  public String say();  }  public class Main {\n\npublic static void main(String[] args) {  Saludo s=()-&gt;{  return \"Hola\";  };  System.out.println(s.say());  }  }  </code></pre>"},{"location":"ud7/2lambda/#un-parametro","title":"Un par\u00e1metro","text":"<p>Cuando una expresi\u00f3n lambda recibe un solo par\u00e1metro, tambi\u00e9n se puede omitir los par\u00e9ntesis, de forma que quedar\u00eda as\u00ed:</p> <p>(p1) -&gt; {body}</p> <p>p1 -&gt; {body}</p> <pre><code>interface Saludo{  public String say(String nombre);  }\n\npublic class Main {\n\npublic static void main(String[] args) { //sin omitir par\u00e9ntesis \nSaludo s = (nombre)-&gt;{  return \"Hola \" + nombre;  };  System.out.println(s.say(\"Patri\"));\n\n\n// Omitir par\u00e9ntesis\nSaludo s2 = nombre -&gt;{  return \"Hola, \" + nombre;  };  System.out.println(s2.say(\"Patri\"));  }\n}  </code></pre>"},{"location":"ud7/2lambda/#multiples-parametros","title":"M\u00faltiples par\u00e1metros","text":"<p>Si el m\u00e9todo con el que coincide su expresi\u00f3n lambda de Java recibe varios par\u00e1metros, los par\u00e1metros deben enumerarse entre par\u00e9ntesis. As\u00ed es como se ve en c\u00f3digo Java:</p> <p>(p1, p2) -&gt; {body}</p> <pre><code>interface Sumable{  int add(int a,int b);  }  public class Main {  public static void main(String[] args) {  Sumable ad1=(a,b)-&gt;(a+b);  System.out.println(ad1.add(10,20));  // con tipo de datos  \nSumable ad2=(int a,int b)-&gt;(a+b);  System.out.println(ad2.add(100,200));  }  } </code></pre>"},{"location":"ud7/2lambda/#tipo-de-parametros","title":"Tipo de par\u00e1metros","text":"<p>En ocasiones, puede ser necesario especificar tipos de par\u00e1metros para una expresi\u00f3n lambda si el compilador no puede inferir los tipos de par\u00e1metros del m\u00e9todo de interfaz funcional con el que coincide la lambda.</p> <pre><code>(Coche coche) -&gt; System.out.println(\"El coche es: \" + coche.getName());\n</code></pre>"},{"location":"ud7/2lambda/#cuerpo-de-las-expresiones-lambda","title":"Cuerpo de las expresiones lambda","text":"<p>El cuerpo de una expresi\u00f3n lambda y, por lo tanto, el cuerpo de la funci\u00f3n/m\u00e9todo que representa, se especifica a la derecha de -&gt; en la declaraci\u00f3n lambda.</p> <p>Si la expresi\u00f3n lambda consta de varias l\u00edneas, se puede encerrar el cuerpo de la funci\u00f3n lambda dentro de los corchetes { }.</p> <pre><code> (oldValue, newValue) -&gt; {\nSystem.out.println(\"Old value: \" + oldValue);\nSystem.out.println(\"New value: \" + newValue);\n}\n</code></pre>"},{"location":"ud7/2lambda/#devolver-un-valor-en-las-expresiones-lambda","title":"Devolver un valor en las expresiones lambda","text":"<p>Al igual que con los m\u00e9todos puedes devolver un valor, en las expresiones lambda tambi\u00e9n. Se hace agregando una declaraci\u00f3n de retorno al cuerpo de la funci\u00f3n lambda.</p> <pre><code>interface Saludo{  public String say(String name);  }\n\npublic class Main {\npublic static void main(String[] args) {  // Lambda expression with single parameter.  \nSaludo s1 = (name)-&gt;{  return \"Hello, \" + name;  };\nSystem.out.println(s1.say(\"Patri\"));  }\n}\n</code></pre> <p>En las expresiones lambda, si solo hay una sentencia, puede o no usar la palabra <code>return</code>. Pero si la expresi\u00f3n lambda tiene varias sentencias se debe poner la palabra <code>return</code>.</p> <pre><code>interface Sumable{  int add(int a,int b);  }\npublic class Main {  public static void main(String[] args) {  // Lambda expression sin palabra clave return\nSumable ad1 = (a,b)-&gt;(a + b);  System.out.println(ad1.add(10,20));  // Lambda expression con la palabra clave return\nSumable ad2 = (a,b)-&gt;{  return (a + b);   };  System.out.println(ad2.add(100,200));  }  } </code></pre> <p>El compilador sabe que la expresi\u00f3n <code>a + b</code> es el valor de retorno de la expresi\u00f3n lambda (de ah\u00ed el nombre de expresiones lambda, ya que las expresiones devuelven un valor de alg\u00fan tipo).</p>"},{"location":"ud7/2lambda/#bucle-for-each","title":"Bucle for-each","text":"<pre><code>public static void main(String[] args) {  List&lt;String&gt; list = new ArrayList&lt;String&gt;();  list.add(\"java\");\nlist.add(\"lambda\");\nlist.add(\"test\");  list.forEach(  (n)-&gt;System.out.println(n)  );  }\n</code></pre>"},{"location":"ud7/2lambda/#escenario-sin-expresiones-lambda","title":"Escenario sin expresiones lambda","text":"<pre><code>interface Saludo { public void saludar();  }  public class LambdaExpressionExample {  public static void main(String[] args) {  String nombre = \"Patri\";\n\n//sin expresiones lambda, Saludo se implementa usando clases an\u00f3nimas\nSaludo s = new Saludo(){  public void saludar(){System.out.println(\"Hola \" + nombre);}  };  s.saludar();  }  }  </code></pre>"},{"location":"ud7/2lambda/#escenario-con-expresiones-lambda","title":"Escenario con expresiones lambda","text":"<pre><code>@FunctionalInterface  //Esto es opcional\ninterface Saludo {  public void saludar();  }  public class LambdaExpressionExample2 {  public static void main(String[] args) {  String nombre = \"Patri\";\n\n//con expresiones lambda\nSaludo s2 = ()-&gt; {\nSystem.out.println(\"Hola \" + nombre);  };\ns2.saludar();  }  }  </code></pre>"},{"location":"ud7/2lambda/#crear-una-expresion-lambda-a-partir-de-un-metodo","title":"Crear una expresi\u00f3n lambda a partir de un m\u00e9todo","text":"<p>Para definir una expresi\u00f3n lambda de un m\u00e9todo que no est\u00e1 definido en ninguna interfaz funcional, tenemos que utilizar la clase <code>Function</code>. A la clase Function se le especifican dos tipos de par\u00e1metros entre <code>&lt;&gt;</code>, el primero es el par\u00e1metro de entrada de la funci\u00f3n, y el segundo es el par\u00e1metro de salida que devuelve la funci\u00f3n o m\u00e9todo.</p> <pre><code>    {\nint total = 0;\nfor (int i = 0; i &lt; texto.length(); i++) {\ntotal+=texto.charAt(i);\n}\nreturn total;\n};\n\n//Queremos crear una expresi\u00f3n lambda que realice lo que est\u00e1 entre { }\n\nFunction&lt;String, Integer&gt; funcionLambda = (s) -&gt; {\nint total = 0;\nfor (int i = 0; i &lt; texto.length(); i++) {\ntotal+=texto.charAt(i);\n}\nreturn total;\n};\n</code></pre> <p>Para ejecutar el c\u00f3digo en el interior de la expresi\u00f3n lambda, utilizaremos el m\u00e9todo <code>apply</code>:</p> <pre><code>System.out.println(funcionLambda.apply(\"Programaci\u00f3n\"));\n</code></pre>"},{"location":"ud7/3predicates/","title":"Predicate","text":"<p>Predicate es una interfaz funcional que se encuentra en el paquete <code>java.util.function</code>. Mejora la capacidad de administraci\u00f3n del c\u00f3digo, ayuda a realizar pruebas unitarias por separado.</p> <p>Se utiliza en expresiones lambda para comprobar si una condici\u00f3n dada es verdadera o falsa.</p> <p>En lugar de pasar un booleano con valor true or false,  pasas una referencia de tipo Predicate para determinar de manera din\u00e1mica si una condici\u00f3n dada es verdadera, o falsa.</p> <p>Esta es la estructura de la interfaz <code>Predicate</code>:</p> <pre><code>@FunctionalInterface\npublic interface Predicate&lt;T&gt; {\n\nboolean test(T t);\n}\n</code></pre> <p>Como vemos la interfaz <code>Predicate</code> utiliza los gen\u00e9ricos para poder decirle que tipo concreto vamos a utilizar.</p> <p>Ejemplo:</p> <pre><code>public class EjemploPredicate {\npublic static void main(String[] args) {\nPredicate&lt;String&gt; checker = a -&gt; a.startsWith(\"M\");\nSystem.out.println(checker.test(\"Miguel\"));\n}\n}\n</code></pre> <p>Hemos creado un objeto <code>Predicate</code> de tipo <code>String</code>. Le damos cuerpo al m\u00e9todo <code>test</code> con una expresi\u00f3n lambda que se le pasa un argumento y devuelve un booleano.</p>"},{"location":"ud7/3predicates/#metodos-predicate","title":"M\u00e9todos Predicate","text":"<p>La interfaz <code>Predicate</code> contiene algunos m\u00e9todos como:</p> <ul> <li><code>isEqual(Object targetRef)</code>: Devuelve un predicado que prueba si dos argumentos son iguales.</li> <li><code>and(Predicate other)</code>: Devuelve un predicado compuesto que representa un AND l\u00f3gico de este predicado y otro.</li> <li><code>or(Predicate other)</code>: Devuelve un predicado compuesto que representa un OR l\u00f3gico de este predicado y otro.</li> <li><code>negate()</code>: Devuelve un predicado que representa la negaci\u00f3n l\u00f3gica de este predicado.</li> </ul> <p>Ejemplo:</p> <pre><code>    Predicate&lt;Integer&gt; greaterThan10 = i -&gt; i &gt; 10;\nPredicate&lt;Integer&gt; lessThan20 = i -&gt; i &lt; 20;\nSystem.out.println(greaterThan10.and(lessThan20).test(15));\n\nPredicate&lt;Integer&gt; greaterThanTen = (i) -&gt; i &gt; 10;\nPredicate&lt;Integer&gt; lowerThanTwenty = (i) -&gt; i &lt; 20;\nboolean resul = greaterThanTen.and(lowerThanTwenty).test(15);//true\nboolean resul2 = greaterThanTen.and(lowerThanTwenty).negate().test(15);//false\n\nPredicate&lt;String&gt; i  = Predicate.isEqual(\"asdf\");\nSystem.out.println(i.test(\"java\"));//false\n</code></pre> <p>Note</p> <p>Debido al uso extendido de <code>Predicate</code> se han a\u00f1adido las interfaces funcionales <code>IntPredicate</code> cuando queremos trabajar con predicados de tipo entero, <code>DoublePredicate</code> y <code>LongPredicate</code>. Tambi\u00e9n tenemos la interfaz <code>BiPredicate</code> que es un caso especial de <code>Predicate</code> y recibe dos par\u00e1metros en vez de uno.</p> <pre><code>    IntPredicate predicate = (x) -&gt; {\nif (x == 12345) {\nreturn true;\n}\nreturn false;\n};\n\nSystem.out.println(predicate.test(12345));\n\nIntPredicate intPredicate1 = predicate.negate();\nSystem.out.println(intPredicate1.test(12345));\n\nBiPredicate&lt;String, Integer&gt; filtroLongitud = (x, y) -&gt; {\nreturn x.length() == y;\n};\n\nboolean result = filter.test(\"java\", 10);\nSystem.out.println(result); // false\n</code></pre>"},{"location":"ud7/3predicates/#supplier","title":"Supplier","text":"<p><code>Supplier</code> es otra interfaz funcional dentro del paquete <code>java.util.function</code> que nos provee del m\u00e9todo abstracto <code>**get**</code>, sin argumentos que devuelve un tipo de dato.</p> <pre><code>@FunctionalInterface\npublic interface Supplier&lt;T&gt; {\n\nT get();\n}\n</code></pre> <p>Esta interfaz tambi\u00e9n se utiliza con expresiones lambda que no tienen par\u00e1metros pero devuelven un resultado:</p> <pre><code>    Random random = new Random();\nSupplier&lt;Integer&gt; su = () -&gt; random.nextInt();\n</code></pre> <p>Al igual que ocurr\u00eda en los predicados con los <code>Supplier</code> tambi\u00e9n disponemos de las clases <code>IntSupplier</code>, <code>DoubleSupplier</code>, <code>LongSupplier</code> y <code>BooleanSupplier</code>.</p>"},{"location":"ud7/3predicates/#consumer","title":"Consumer","text":"<p><code>Consumer</code> es otra interfaz funcional dentro del paquete <code>java.util.function</code> que provee un m\u00e9todo que recibe un solo par\u00e1metro de tipo gen\u00e9rico y no devuelve nada.</p> <pre><code>public interface Consumer&lt;T&gt; {\nvoid accept(T t);\n}\n</code></pre> <p>La expresi\u00f3n lambda asignada a un objeto de tipo <code>Consumer</code> se usa para definir su m\u00e9todo <code>**accept(T t)**</code> que eventualmente aplica la operaci\u00f3n dada en su argumento. Los <code>Consumer</code> son \u00fatiles cuando no necesitan devolver ning\u00fan valor, ya que se espera que operen a trav\u00e9s de efectos secundarios.</p> <p>Existen tambi\u00e9n las interfaces <code>IntConsumer</code>, <code>LongConsumer</code> y <code>DoubleConsumer</code>.</p> <pre><code>Consumer&lt;Integer&gt; numero = (x) -&gt; System.out.println(x);\nnumero.accept(5);\n</code></pre> <p><code>BiConsumer</code> es un caso especial de las expresiones <code>Consumer</code>, son aquellas que reciben dos valores como par\u00e1metro y no devuelven resultado.</p> <pre><code>@FunctionalInterface\npublic interface BiConsumer&lt;T, U&gt; {\nvoid accept(T t, U u);\n}\n</code></pre> <p>Ejemplo:</p> <pre><code>BiConsumer&lt;Integer, String&gt; biConsumer = (x, s) -&gt; System.out.println(x + s);\nbiConsumer.accept(3, \" puntos\");\n</code></pre>"},{"location":"ud7/4functions/","title":"Functions","text":"<p>En el apartado de Expresiones lambda vimos como crear expresiones lambda a partir de un m\u00e9todo definido por el programador. Esto se hac\u00eda utilizando la interfaz funcional <code>Function</code> que se encuentra del paquete <code>java.util.function</code>.</p> <pre><code>@FunctionalInterface\npublic interface Function&lt;T, R&gt; {\nR apply(T t);\n}\n</code></pre> <p><code>Function</code> recibe dos valores de distinto tipo cuando se crea el objeto, el m\u00e9todo recibe un par\u00e1metro de entrada que coincide con el primer tipo espec\u00edfico y devuelve un valor del tipo especificado del objeto que coincide con el segundo valor.</p> <pre><code>Function&lt;Integer, String&gt; function = num -&gt; {\nif(num % 3 == 0 &amp;&amp; num % 5 == 0){\nreturn num + \" divisible entre 3 y 5\";\n}else{\nreturn num + \" no es divisible entre 3 y 5\";\n}\n};\n\nSystem.out.println(function.apply(25));//devuelve un String\n</code></pre> <p>Si tenemos dos funciones y queremos usar el resultado de una para la siguiente funci\u00f3n podemos concatenarlas utilizando <code>andThen</code>.</p> <pre><code>Function&lt;Integer, Integer&gt; suma = x -&gt; x + 2;\nFunction&lt;Integer, Integer&gt; mul = x -&gt; x * 3;\nFunction co = suma.andThen(mul);\nSystem.out.println(co.apply(4)); //imprime 18 = (4 + 2) * 3\n</code></pre>"},{"location":"ud7/4functions/#unaryoperator","title":"UnaryOperator","text":"<p><code>UnaryOperator</code> es una interfaz funcional que extiende de <code>Function</code>.</p> <pre><code>@FunctionalInterface\npublic interface UnaryOperator&lt;T&gt; extends Function&lt;T, T&gt; {\nstatic &lt;T&gt; UnaryOperator&lt;T&gt; identity() {\nreturn t -&gt; t;\n}\n}\n</code></pre> <p><code>UnaryOperator</code> se crea con un tipo de dato, recibe un par\u00e1metro y devuelve un resultado del mismo tipo de su argumento.</p> <pre><code>UnaryOperator&lt;Integer&gt; func2 = x -&gt; x * 2;\nint resultado = func2.apply(2);\nSystem.out.println(resultado);//imprime 4\n</code></pre> <p>Existen tambi\u00e9n las interfaces derivadas <code>IntUnaryOperator</code>, <code>DoubleUnaryOperator</code>, etc.</p>"},{"location":"ud7/4functions/#resumen-de-las-interfaces-funcionales-dentro-de-javautilfunction","title":"Resumen de las interfaces funcionales dentro de java.util.function","text":""},{"location":"ud7/5references/","title":"Referencia a m\u00e9todos en expresiones lambda","text":"<p>Una referencia a m\u00e9todos o m\u00e9todos referenciados proporciona una forma de referirse a un m\u00e9todo sin ejecutarlo. Se relaciona con expresiones lambda porque tambi\u00e9n requiere un contexto de tipo de objetivo que consiste en una interfaz funcional compatible.</p> <p>En el caso de que todo lo que haga la expresi\u00f3n lambda sea llamar a otro m\u00e9todo con los par\u00e1metros pasados \u200b\u200ba la expresi\u00f3n lambda, la implementaci\u00f3n de Java lambda proporciona una forma m\u00e1s corta de expresar la llamada al m\u00e9todo, que es usando ::.</p> <p>Veamos un ejemplo:</p> <pre><code>public interface Impresora{\nvoid imprimir(String s);\n}\n</code></pre> <p>Si us\u00e1ramos lambda sin referencias a m\u00e9todos, lo har\u00edamos de la siguiente forma:</p> <pre><code>Impresora impresora = s -&gt; System.out.println(s);\n</code></pre> <p>Dado que todo lo que hace el cuerpo lambda es reenviar el par\u00e1metro String al m\u00e9todo System.out.println(), podemos reemplazar la declaraci\u00f3n lambda anterior con una referencia de m\u00e9todo utilizando ::. De forma que quedar\u00eda:</p> <pre><code>Impresora impresora = System.out::println;\n</code></pre> <pre><code>List&lt;String&gt; names = new ArrayList();\nnames.add(\"Andrea\");\nnames.add(\"Luisa\");\nnames.add(\"Diego\");\nnames.add(\"Pa\u00fal\");\nnames.add(\"Dario\");\nnames.forEach(System.out::println);\n</code></pre> <p>Observa los dos puntos dobles :: . Estos le indican al compilador de Java que se trata de una referencia de m\u00e9todo. El m\u00e9todo al que se hace referencia es lo que viene despu\u00e9s de los dos puntos dobles. Cualquier clase u objeto que posea el m\u00e9todo al que se hace referencia viene antes de los dos puntos dobles.</p> <p>Podemos hacer referencia a los siguientes tipos de m\u00e9todos:</p> <ul> <li>M\u00e9todo est\u00e1tico</li> <li>M\u00e9todo con par\u00e1metros de objeto</li> <li>M\u00e9todo de instancia</li> <li>Constructor</li> </ul>"},{"location":"ud7/5references/#referencias-a-metodos-estaticos","title":"Referencias a m\u00e9todos est\u00e1ticos","text":"<p>Los m\u00e9todos m\u00e1s f\u00e1ciles de referenciar son los m\u00e9todos est\u00e1ticos. Veamos un ejemplo:</p> <pre><code>public interface Finder {\nint find(String s1, String s2);\n}\n\npublic class MyClass{\npublic static int doFind(String s1, String s2){\nreturn s1.lastIndexOf(s2);\n}\n}\n</code></pre> <p>La referencia al m\u00e9todo est\u00e1tico <code>doFind</code> se har\u00eda con:</p> <pre><code>Finder finder = MyClass::doFind;\n</code></pre> <p>Dado que los par\u00e1metros de los m\u00e9todos <code>Finder.find()</code> y <code>MyClass.doFind()</code> coinciden, es posible crear una expresi\u00f3n lambda que implemente <code>Finder.find()</code> y haga referencia al m\u00e9todo <code>MyClass.doFind()</code>.</p>"},{"location":"ud7/5references/#referencia-a-metodos-con-parametro","title":"Referencia a m\u00e9todos con par\u00e1metro","text":"<p>Tambi\u00e9n puede hacer referencia a un m\u00e9todo con par\u00e1metros de objeto de la clase al m\u00e9todo que se llama.</p> <pre><code>public interface Finder {\nint find(MyClass mc, String s1, String s2);\n}\n\nclass MyClass {\npublic int check(String s1, String s2) {\nreturn s1.indexOf(s2);\n}\n}\n\n//dentro del main\n//Aunque es un m\u00e9todo de instancia, no est\u00e1tico\n//podemos llamarlo con la clase porque en la interfaz\n//est\u00e1 a\u00f1adido un par\u00e1metro de tipo MyClass\nFinder finder = MyClass::check;\n</code></pre> <p>Si quisi\u00e9ramos hacerlo con una expresi\u00f3n lambda sin usar referencia de m\u00e9todos que llama a String.indexOf() para buscar ser\u00eda:</p> <pre><code>Finder finder = (s1, s2) -&gt; s1.indexOf(s2);\n</code></pre> <p>Su equivalente utilizando referencia de m\u00e9todos con par\u00e1metro de objeto en la expresi\u00f3n lambda ser\u00eda:</p> <pre><code>Finder finder = String::indexOf;\nint numero = finder.find(\"Hola\", \"a\");\n</code></pre> <p>Observe c\u00f3mo la versi\u00f3n abreviada hace referencia a un solo m\u00e9todo. El compilador de Java intentar\u00e1 hacer coincidir el m\u00e9todo al que se hace referencia con el primer tipo de par\u00e1metro, utilizando el segundo tipo de par\u00e1metro como par\u00e1metro del m\u00e9todo al que se hace referencia.</p>"},{"location":"ud7/5references/#referencia-a-metodos-de-instancia","title":"Referencia a m\u00e9todos de instancia","text":"<p>En tercer lugar, tambi\u00e9n es posible hacer referencia a un m\u00e9todo de instancia desde una definici\u00f3n lambda.</p> <pre><code>public interface Deserializer {\nint deserialize(String v1);\n}\n</code></pre> <p>Esta interfaz representa un componente que es capaz de \"deserializar\" un String en un int.</p> <pre><code>public class StringConverter {\npublic int convertToInt(String v1){\nreturn Integer.valueOf(v1);\n}\n}\n</code></pre> <p>El m\u00e9todo <code>convertToInt()</code> tiene la misma signatura que el m\u00e9todo <code>deserialize()</code> del m\u00e9todo de la interfaz <code>Deserializer</code>. Por eso, podemos crear una instancia de StringConverter y hacer referencia a su m\u00e9todo convertToInt() desde una expresi\u00f3n lambda de Java.</p> <pre><code>StringConverter stringConverter = new StringConverter();\nDeserializador des = stringConverter::convertToInt;\n</code></pre> <p>La expresi\u00f3n lambda creada por la segunda de las dos l\u00edneas hace referencia al m\u00e9todo convertToInt de la instancia de StringConverter creada en la primera l\u00ednea.</p>"},{"location":"ud7/5references/#referencias-a-constructores","title":"Referencias a constructores","text":"<p>Finalmente, es posible hacer referencia a un constructor de una clase. Para ello, se escribe el nombre de la clase seguido de ::new:</p> <pre><code>-- Nomenclatura\nMiClase::new\n</code></pre> <pre><code>Supplier&lt;Usuario&gt; usu = Usuario::new;\n//Construye un objeto de tipo usuario que es devuelto por m\u00e9todo get();\nUsuario usuario = usu.get();\n</code></pre> <p>Veamos otro ejemplo utilizando <code>BiFunction</code>:</p> <pre><code>class Pruebas {\npublic static void main(String[] args) {\nBiFunction&lt;String, Integer, Usuario&gt; crearUsuario = Usuario::new;\nUsuario u = crearUsuario.apply(\"Patricia\", 12);\n}\n}\nclass Usuario {\nprivate String nombre;\nprivate int edad;\n\npublic Usuario(String nombre, int edad) {\nthis.nombre = nombre;\nthis.edad = edad;\n}\n}\n</code></pre>"},{"location":"ud7/6streams/","title":"Streams","text":"<p>Los Streams fueron introducidos en Java 8 para abrir la puerta a la programaci\u00f3n funcional al igual que con las expresiones lambda. No hay que confundirlos con los streams de entrada/salida, como un buffer stream de entrada o un fichero de salida.</p> <p>Seg\u00fan Oracle:</p> <p>Note</p> <p>A stream is a sequence of elements supporting sequential and parallel aggregate operations.</p> <p>La API <code>Stream</code> permite manipular las colecciones como nunca antes. Nos permite realizar operaciones sobre la colecci\u00f3n, como por ejemplo, buscar, filtrar, reordenar, etc. Pero no nos permite manipular los elementos individualmente en el flujo, sino que se trata el flujo como un todo, a menudo agregando o reduciendo los datos, o quiz\u00e1s contando o agrupando elementos de alguna manera.</p> <p>Con Streams podemos utilizar cualquier clase que implemente la interfaz <code>Collection</code> como si fuese un <code>Stream</code> con la ventaja que nos ofrecen las expresiones lambda.</p> <p>Con streams hay que tener el cuenta que la fuente o colecci\u00f3n que utilicemos no se puede modificar y no debe afectar al estado de la misma. Cada operaci\u00f3n dentro del stream debe verse como una operaci\u00f3n independiente que opera sobre el argumento (colecci\u00f3n).</p> <p>A trav\u00e9s del API Stream podemos trabajar sobre colecciones como si estuvi\u00e9ramos realizando sentencias SQL pero de una manera limpia y clara, evitando bucles y algoritmos que ralentizan los programas e incluso hacen que el c\u00f3digo se torne inmanejable.</p> <p>Cada operaci\u00f3n del stream debe verse como un paso independiente, es decir, no se puede usar variables intermedias.</p> <p>Warning</p> <p>Streams are lazy! Es decir, se inicia con la operaci\u00f3n terminal, y los elementos de origen se consumen s\u00f3lo cuando es necesario.</p>"},{"location":"ud7/6streams/#cuando-querria-utilizar-streams-en-vez-de-colecciones","title":"\u00bfCu\u00e1ndo querr\u00eda utilizar Streams en vez de colecciones?","text":"<p>Los Streams son una interesante incorporaci\u00f3n a Java, ya que me aportan varias ventajas:</p> <ol> <li>Hacen que el c\u00f3digo para procesar los datos sea uniforme, conciso y legible. Tiene una forma similar a SQL.</li> <li>Cuando se trabaja con grances colecciones, los flujos paralelos proporcionan una ventaja de rendimiento.</li> </ol>"},{"location":"ud7/6streams/#partes-de-un-stream","title":"Partes de un Stream","text":"<p>De forma gen\u00e9rica existen 3 partes que componen un Stream:</p> <ol> <li>Un Stream funciona a partir de una lista o colecci\u00f3n, que tambi\u00e9n se la conoce como la fuente de donde obtienen informaci\u00f3n.</li> <li>Operaciones intermedias como por ejemplo el m\u00e9todo filter, que permite hacer una selecci\u00f3n a partir de un predicado.</li> <li>Operaciones terminales, como por ejemplo los m\u00e9todos max, min, forEach, findFirst etc.</li> </ol> <p></p> <p>La fuente proporciona los elementos a la tuber\u00eda.</p>"},{"location":"ud7/6streams/#funciones-de-stream","title":"Funciones de Stream","text":""},{"location":"ud7/6streams/#operaciones-intermedias","title":"Operaciones intermedias","text":"<p>Las operaciones intermedias obtienen elementos uno por uno y los procesan. Todas las operaciones intermedias son perezosas (lazy) y, como resultado, ninguna operaci\u00f3n tendr\u00e1 ning\u00fan efecto hasta que la tuber\u00eda comience a funcionar.</p>"},{"location":"ud7/6streams/#operaciones-intermedias-que-tienen-un-efecto-en-el-tamano-del-stream-resultante","title":"Operaciones intermedias que tienen un efecto en el tama\u00f1o del stream resultante","text":"Tipo de retorno Operaci\u00f3n Descripci\u00f3n Stream distinct() Elimina los valores duplicados del Stream. Stream filter(Predicate) Los elementos que coinciden con el filtro de Predicate se mantienen en el stream de salida para las operaciones. Stream takeWhile(Predicate) Similar a filter. Con la diferencia de que la primera vez que se eval\u00faa a falsa la condici\u00f3n, deja de comprobar el resto de elementos. Stream dropWhile(Predicate) Eliminar\u00e1 o filtrar\u00e1 cualquier elemento mientras coincida con la condici\u00f3n del Predicate. Cuando la condici\u00f3n se eval\u00faa como falso la primera vez, la condici\u00f3n ya no se comprueba. Stream limit(long maxSize) Reduce el stream al tama\u00f1o especificados en el par\u00e1metro. Stream skip(long n) Este metodo omite elementos, es decir, no formar\u00e1n parte del stream resultante."},{"location":"ud7/6streams/#peek","title":"<code>Peek()</code>","text":"<p>El m\u00e9todo <code>peek</code> recibe como par\u00e1metro una expresi\u00f3n lambda de tipo <code>Consumer</code> para poder utilizar cada elemento del stream. Normalmente se utilizar para mostrar por consola el contenido del stream.</p> <p>Este m\u00e9todo existe principalmente para la depuraci\u00f3n del programa, donde se desea ver los elementos a medida que pasan por un punto determinado en el pipeline.</p> <p><code>peek()</code> tambi\u00e9n se utiliza cuando queremos alterar el estado interno de un elemento (aunque esto no es muy com\u00fan).</p> <pre><code>Stream.of(\"one\", \"two\", \"three\", \"four\")\n.filter(e -&gt; e.length() &gt; 3)\n.peek(e -&gt; System.out.println(\"Filtered value: \" + e))\n.map(String::toUpperCase)\n.peek(e -&gt; System.out.println(\"Mapped value: \" + e))\n.collect(Collectors.toList());\n</code></pre>"},{"location":"ud7/6streams/#sorted","title":"<code>Sorted()</code>","text":"<p>Se utiliza para ordenar los elementos del stream. Recibe como par\u00e1metro una expresi\u00f3n lambda de tipo <code>Comparator</code> para que podamos indicar la l\u00f3gica de la ordenaci\u00f3n.</p>"},{"location":"ud7/6streams/#map","title":"<code>Map()</code>","text":"<p>El m\u00e9todo <code>map</code> recibe como par\u00e1metro una expresi\u00f3n lambda de tipo <code>Function</code>, por lo que debemos especificar una funci\u00f3n que recibe como par\u00e1metro de entrada cada elemento del stream, y devuelve un objeto que puede ser un tipo de dato distinto o el mismo.</p> <p>La funci\u00f3n se aplica a cada uno de los elementos del stream para realizar alguna transformaci\u00f3n sobre cada elemento y devuelve otro Stream sobre el cual puedes seguir trabajando. Se utiliza para modificar el contenido del stream. <code>map()</code> devuelve un stream nuevo que consta de los resultados de aplicar la funci\u00f3n dada a los elementos del stream.</p> <pre><code>List&lt;Integer&gt; list = Arrays.asList(3, 6, 9, 12, 15);\n\n//Mostramos el nuevo stream devuelto por map\nlist.stream().map(number -&gt; number * 3).forEach(System.out::println);\n//[9 18 27 36 45]\n</code></pre>"},{"location":"ud7/6streams/#flatmap","title":"<code>FlatMap</code>","text":"<p>Cuando nos encontramos con estructuras m\u00e1s complejas, como por ejemplo una lista con otra lista, trabajar con <code>map()</code> no es suficiente, por ello, utilizamos <code>flatMap()</code> que lo que hace es \"aplanar\" listas anidadas y quedarnos con un stream plano.</p> <p>Es una funci\u00f3n que recibe una entrada y devuelve varias salidas para esa entrada. Esa es la diferencia con respecto a <code>map()</code> que recibe solo un par\u00e1metro de entrada y devuelve una salida.</p> <p><code>flatMap()</code> es una operaci\u00f3n intermedia y devuelve un nuevo Stream. Devuelve un Stream que consiste en los resultados de reemplazar cada elemento del stream dado con el contenido de un stream mapeado producido al aplicar la funci\u00f3n de mapeo provista a cada elemento. La funci\u00f3n de mapeo utilizada para la transformaci\u00f3n en <code>flatMap()</code> es una funci\u00f3n sin estado y solo devuelve una secuencia de nuevos valores.</p> <p>En el siguiente ejemplo el programa usa la operaci\u00f3n <code>flatMap()</code> para convertir una lista de una lista <code>List&lt;List&lt;Integer&gt;&gt;</code> a una lista <code>List&lt;Integer&gt;</code>.</p> <pre><code>List&lt;Integer&gt; list1 = Arrays.asList(1,2,3);\nList&lt;Integer&gt; list2 = Arrays.asList(4,5,6);\nList&lt;Integer&gt; list3 = Arrays.asList(7,8,9);\n\nList&lt;List&lt;Integer&gt;&gt; listOfLists = Arrays.asList(list1, list2, list3);\n\nList&lt;Integer&gt; listOfAllIntegers = listOfLists.stream()\n.flatMap(x -&gt; x.stream())\n.collect(Collectors.toList());\n\nSystem.out.println(listOfAllIntegers);\n//[1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre>"},{"location":"ud7/6streams/#operaciones-terminales","title":"Operaciones terminales","text":"<p>Las operaciones terminales significan el final del ciclo de vida del steam. Lo m\u00e1s importante para nuestro escenario es que inician el trabajo en la tuber\u00eda.</p>"},{"location":"ud7/6streams/#foreach","title":"<code>forEach()</code>","text":"<p>Recorremos cada elemento del stream para realizar alguna acci\u00f3n con \u00e9l. Como bien sabemos recibe como par\u00e1metro una exprsi\u00f3n lambda de tipo <code>Consumer</code>.</p>"},{"location":"ud7/6streams/#collect","title":"<code>collect()</code>","text":"<p>Es una operaci\u00f3n terminal, se utiliza para indicar el tipo de colecci\u00f3n en la que se devolver\u00e1 el resultado final de todas las operaciones realizadas en el stream.</p> <pre><code>List&lt;String&gt; lista = Arrays.asList(\"Texto1\", \"Texto2\");\nSet&lt;String&gt; set = lista.stream().collect(Collectors.toSet());\n</code></pre>"},{"location":"ud7/6streams/#findfirst","title":"<code>findFirst()</code>","text":"<p>Se utiliza para devolver el primer elemento encontrado del stream. Se suele utilizar en combinaci\u00f3n con otras funciones cuando hay que seleccionar un \u00fanico valor del stream que cumpla determinadas condiciones.</p> <p><code>findFirst</code> devuelve un objeto de tipo <code>Optional</code> para poder indicar un valor por defecto en caso de que no se pueda devovler ning\u00fan elemento del stream.</p>"},{"location":"ud7/6streams/#toarray","title":"<code>toArray()</code>","text":"<p>Con este m\u00e9todo se puede convertir cualquier tipo de <code>Collection</code> en un array de forma sencilla.</p>"},{"location":"ud7/6streams/#min","title":"<code>min()</code>","text":"<p>Con <code>min</code> se obtiene el elemento del stream con el valor m\u00ednimo calculado a partir de una expresi\u00f3n lambda de tipo <code>Comparator</code> que indicamos como par\u00e1metro.</p> <p><code>min</code> devuelve un objeto de tipo <code>Optional</code> para poder indicar un valor por defecto en caso de que no se pueda devolver ning\u00fan elemento del stream.</p>"},{"location":"ud7/6streams/#max","title":"<code>max()</code>","text":"<p>Con <code>max</code> se obtiene el elemento del stream con el valor m\u00e1ximo calculado a partir de una expresi\u00f3n lambda de tipo <code>Comparator</code> que indicamos como par\u00e1metro de la expresi\u00f3n.</p> <p><code>max</code> devuelve un objeto de tipo <code>Optional</code> para poder indicar un valor por defecto en caso de que no se pueda devolver ning\u00fan elemento del stream.</p>"},{"location":"ud7/6streams/#anymatch","title":"<code>anyMatch()</code>","text":"<p>El m\u00e9todo <code>anyMatch</code> devuelve verdadero si al menos un elemento satisface la condici\u00f3n proporcionada por el predicado; en caso contrario, es falso. No eval\u00faa el predicado sobre todos los elementos si no es necesario para determinar el resultado. El m\u00e9todo devuelve verdadero tan pronto como se encuentra el primer elemento coincidente. Si la secuencia est\u00e1 vac\u00eda, se devuelve falso y el predicado no se eval\u00faa.</p> Sintaxis boolean anyMatch(Predicate&lt;? super T&gt; predicate)"},{"location":"ud7/6streams/#ventajas-de-streams","title":"Ventajas de Streams","text":"<ul> <li>C\u00f3digo conciso y m\u00e1s limpio.</li> <li>Programaci\u00f3n funcional: se programa escribiendo el \"qu\u00e9\" en lugar del \"c\u00f3mo\" para que sea comprensible de un vistazo.</li> <li>Puede leer y comprender f\u00e1cilmente el c\u00f3digo que tiene una serie de operaciones complejas.</li> <li>Ejecutar tan r\u00e1pido como bucles for (o m\u00e1s r\u00e1pido con operaciones paralelas)</li> <li>Ideal para listas grandes.</li> </ul>"},{"location":"ud7/6streams/#desventajas","title":"Desventajas","text":"<ul> <li>Excesivo para peque\u00f1as colecciones.</li> <li>Dif\u00edcil de aprender si est\u00e1 acostumbrado a la codificaci\u00f3n de estilo imperativo tradicional</li> </ul>"},{"location":"ud7/7regularexpressions/","title":"Expresiones Regulares","text":"<p>Una expresi\u00f3n regular (regex) define un patr\u00f3n de b\u00fasqueda para cadenas. El patr\u00f3n de b\u00fasqueda puede ser cualquier cosa, desde un car\u00e1cter simple, una cadena fija o una expresi\u00f3n compleja que contenga caracteres especiales que describan el patr\u00f3n.</p> <p>Se puede usar una expresi\u00f3n regular para buscar, editar y manipular texto.</p> <p>La expresi\u00f3n regular se aplica en el texto de izquierda a derecha.</p> <p>Se usa ampliamente para definir la restricci\u00f3n en cadenas como contrase\u00f1a y validaci\u00f3n de correo electr\u00f3nico.</p> <p>Java Regex API proporciona 1 interfaz y 3 clases en el paquete java.util.regex:</p> <ul> <li>MatchResult interface</li> <li>Matcher class</li> <li>Pattern class</li> <li>PatternSyntaxException class</li> </ul>"},{"location":"ud7/7regularexpressions/#clases-de-caracteres-y-limites-de-coincidencia","title":"Clases de caracteres y l\u00edmites de coincidencia","text":"<p>La forma m\u00e1s simple de una expresi\u00f3n regular (regex) es una cadena, un literal, un String. Por ejemplo, \"Hola\" es una regex que coincide (matches) con la palabra \"Hola\".</p> <p>Si solo us\u00e1ramos literales como patr\u00f3n para buscar en un String, las regex no ser\u00edan muy interesantes. Por eso, se crearon las Character classes &amp; boundary matches.</p> <p>Los boundary matches o l\u00edmites de coincidencia son: ^ (al principio del String), $ (final del String), \\b (principio y final palabra).</p> <p>Una clase caracter es como un comod\u00edn y representa un conjunto o clase de caracteres.</p> Regex Descripci\u00f3n . Coincide con cualquier car\u00e1cter. ^pattern El s\u00edmbolo ^ indica al inicio del String. Encuentra la regex que coincide con el patr\u00f3n dado al comienzo del String. pattern$ El s\u00edmbolo $ indica el final del String. Encuentra la regex que coincide con el patr\u00f3n dado al final del String. [abc] Los corchetes representan un conjunto. El String debe coincidir con la/s letra/s dentro del corchete. [abc][12] El String debe coincidir con las letras a, b \u00f3 c, seguidas de 1 \u00f3 2. [^abc] El s\u00edmbolo ^ dentro de los corchetes indica negaci\u00f3n. El String debe coincidir con cualquier car\u00e1cter excepto a \u00f3 b \u00f3 c. [a-z1-9] Rango. Busca coincidir las letras min\u00fasculas de la a a la z (ambas incluidas) y los d\u00edgitos del 1 al 9 (ambos incluidos). a|b Encuentra en el String las ocurrencias de a \u00f3 b. ab Encuentra en el String todas las ocurrencias de 'a' seguido de una 'b'."},{"location":"ud7/7regularexpressions/#meta-caracteres","title":"Meta caracteres","text":"<p>Los siguientes metacaracteres tienen un significado predefinido y hacen que ciertos patrones comunes sean m\u00e1s f\u00e1ciles de usar. Por ejemplo, puede usar \\d como definici\u00f3n simplificada para [0..9].</p> Regex Descripci\u00f3n \\d Cualquier d\u00edgito. Equivale a [0-9]. \\D No d\u00edgito. Equivale a [^0-9]. \\s Espacio en blanco. Equivale a [ \\t\\n\\x0b\\r\\f] \\S No espacio en blanco. Equivale a [^\\s] \\w Una letra may\u00fascula o min\u00fascula, un d\u00edgito o el car\u00e1cter '_'. Equivale a  [a-zA-Z0-9_] \\W Equivale a [^\\w] \\S+ Varios caracteres que no son espacios en blanco \\b L\u00edmite de una palabra"},{"location":"ud7/7regularexpressions/#especificacion-de-modos-dentro-de-la-expresion-regular","title":"Especificaci\u00f3n de modos dentro de la expresi\u00f3n regular","text":"<p>Puede agregar los siguientes modificadores de modo al comienzo de la expresi\u00f3n regular. Para especificar m\u00faltiples modos, simplemente se juntan: (?ismx).</p> <ul> <li>(?i) hace que la expresi\u00f3n regular sea insensible a may\u00fasculas y min\u00fasculas.</li> <li>(?s) para \"modo de una sola l\u00ednea\" hace que el punto coincida con todos los caracteres, incluidos los saltos de l\u00ednea.</li> <li>(?m) para \"modo multil\u00ednea\" hace que el s\u00edmbolo de intercalaci\u00f3n y el d\u00f3lar coincidan al principio y al final de cada l\u00ednea en la cadena de asunto.</li> </ul>"},{"location":"ud7/7regularexpressions/#cuantificadores-regex","title":"Cuantificadores Regex","text":"<p>Los cuantificadores especifican el n\u00famero de ocurrencias de un car\u00e1cter.</p> <p>Un cuantificador define con qu\u00e9 frecuencia puede ocurrir un elemento. Los s\u00edmbolos ?, *, + y {} son calificadores.</p> Regex Descripci\u00f3n * Indica que ocurre 0 \u00f3 m\u00e1s veces. Equivale a {0,}. + Indica que ocurre 1 \u00f3 m\u00e1s veces. Equivale a {1,}. ? Indica que ocurre 0 \u00f3 1 veces. Equivale a {0,1}. {X} Indica que lo que va justo antes de las llaves {} se repite X n\u00famero de veces. {X, Y} Indica que lo que va justo antes de las llaves {} se repite m\u00ednimo X n\u00famero de veces y m\u00e1ximo Y. *? ? despu\u00e9s de un cuantificador lo convierte en un cuantificador perezoso (lazy). Intenta encontrar la coincidencia m\u00e1s peque\u00f1a. Esto hace que la expresi\u00f3n regular se detenga en la primera coincidencia. <p>En la documentaci\u00f3n de Oracle podemos ver todas las clases de caracteres que hay para construir una expresi\u00f3n regular.</p> <p>https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html</p>"},{"location":"ud7/7regularexpressions/#entrena-tus-regex","title":"Entrena tus Regex","text":"<p>https://regexcrossword.com/</p>"},{"location":"ud7/7regularexpressions/#java-regex-core-classes","title":"Java Regex Core Classes","text":"<p>La API de expresiones regulares de Java consta de dos clases principales. Estos son:</p> <p><code>Pattern</code> (java.util.regex.Pattern) <code>Matcher</code> (java.util.regex.Matcher)</p>"},{"location":"ud7/7regularexpressions/#clase-pattern","title":"Clase <code>Pattern</code>","text":"<p>La clase <code>Pattern</code> se utiliza para crear patrones (expresiones regulares). Un patr\u00f3n es una expresi\u00f3n regular precompilada en forma de objeto (como una instancia de patr\u00f3n), capaz de compararse con un texto.</p> <pre><code>String regex = \".*http://.*\";\n\nPattern pattern = Pattern.compile(regex);\n</code></pre>"},{"location":"ud7/7regularexpressions/#clase-matcher","title":"Clase <code>Matcher</code>","text":"<p>La clase <code>Matcher</code> se usa para hacer coincidir una expresi\u00f3n regular determinada (\u00f9na instancia de <code>Pattern</code>) con un texto varias veces. En otras palabras, buscar m\u00faltiples ocurrencias de la expresi\u00f3n regular en el texto. <code>Matcher</code> nos dir\u00e1 en qu\u00e9 parte del texto (\u00edndice de caracteres) encontr\u00f3 las ocurrencias. Puede obtener una instancia de Matcher a partir de una instancia de Pattern.</p> <p>Implementa la interfaz <code>MatchResult</code>.</p> <p>Algunos de los m\u00e9todos de la clase Matcher son:</p> <ul> <li>boolean matches(): prueba si la expresi\u00f3n regular coincide con el patr\u00f3n.</li> <li>booleano find(): encuentra la siguiente expresi\u00f3n que coincide con el patr\u00f3n.</li> <li>boolean find(int start): encuentra la siguiente expresi\u00f3n que coincide con el patr\u00f3n del n\u00famero de inicio dado.</li> <li>String group(): devuelve la subsecuencia coincidente.</li> <li>int start(): devuelve el \u00edndice inicial de la subsecuencia coincidente.</li> <li>int end(): devuelve el \u00edndice final de la subsecuencia coincidente.</li> <li>int groupCount(): devuelve el n\u00famero total de la subsecuencia coincidente.</li> </ul> <p>Ejemplo:</p> <pre><code>StringBuilder html = new StringBuilder(\"&lt;h1&gt;Head&lt;/h1&gt;\");\nhtml.append(\"&lt;h2&gt;Etiqueta h2 de encabezado&lt;/h2&gt;\");\nhtml.append(\"&lt;p&gt;Esto es un p\u00e1rrafo en html&lt;/p&gt;\");\nhtml.append(\"&lt;h2&gt;Resumen&lt;/h2&gt;\");\nhtml.append(\"&lt;p&gt;Fin del html&lt;/p&gt;\");\n\nPattern p = Pattern.compile(\"&lt;h2&gt;\");\nMatcher m = p.matcher(html);\nSystem.out.println(m.matches());\n</code></pre>"},{"location":"ud7/7regularexpressions/#reset","title":"reset()","text":"<p>El m\u00e9todo de la clase Matcher <code>reset()</code> restablece el estado de coincidencia internamente en el Matcher. En caso de que haya comenzado a hacer coincidir las ocurrencias en una cadena a trav\u00e9s del m\u00e9todo <code>find()</code>, el Matcher mantendr\u00e1 internamente un estado sobre qu\u00e9 tan lejos ha buscado a trav\u00e9s del texto de entrada. Al llamar a <code>reset()</code>, la coincidencia comenzar\u00e1 nuevamente desde el principio del texto.</p>"},{"location":"ud7/7regularexpressions/#group","title":"group()","text":"<p>Los grupos est\u00e1n marcados con par\u00e9ntesis en la expresi\u00f3n regular. Por ejemplo:</p> <p>(Hola)</p> <p>Esta expresi\u00f3n regular coincide con el texto Hola. Los par\u00e9ntesis no son parte del texto que se compara. Los par\u00e9ntesis marcan un grupo. Cuando se encuentra una coincidencia en un texto, puede obtener acceso a la parte de la expresi\u00f3n regular dentro del grupo.</p> <p>Para acceder a un grupo se utliza el m\u00e9todo <code>group(int groupNo)</code>. Una expresi\u00f3n regular puede tener m\u00e1s de un grupo. Por lo tanto, cada grupo est\u00e1 marcado con un conjunto separado de par\u00e9ntesis. Para obtener acceso al texto que coincidi\u00f3 con la subparte de la expresi\u00f3n en un grupo espec\u00edfico, se pasa el n\u00famero del grupo al m\u00e9todo <code>group(int groupNo)</code>.</p> <p>El grupo con el n\u00famero 0 es siempre la expresi\u00f3n regular completa. Para obtener acceso a un grupo marcado entre par\u00e9ntesis, debe comenzar con los n\u00fameros de grupo 1.</p> <p>Ejemplo:</p> <pre><code>String text    =\n\"John writes about this, and John writes about that,\" +\n\" and John writes about everything. \"\n;\n\nString patternString1 = \"(John)\";\n\nPattern pattern = Pattern.compile(patternString1);\nMatcher matcher = pattern.matcher(text);\n\nwhile(matcher.find()) {\nSystem.out.println(\"found: \" + matcher.group(1)); //el primer grupo de par\u00e9ntesis\n}\n</code></pre> <p>OUTPUT</p> <p>found: John</p> <p>found: John</p> <p>found: John</p>"},{"location":"ud7/7regularexpressions/#operadores-logicos","title":"Operadores l\u00f3gicos","text":"<p>La API de Java Regex admite un conjunto de operadores l\u00f3gicos que se pueden usar para combinar m\u00faltiples subpatrones dentro de una sola expresi\u00f3n regular.</p> <p>Los operadores l\u00f3gicos son: el operador and, el operador or y el operador not.</p> <p>El operador and es impl\u00edcito. Si dos caracteres (u otros subpatrones) se suceden en una expresi\u00f3n regular, eso significa que tanto el primer como el segundo subpatr\u00f3n coinciden en gran medida con la cadena de destino.</p> <p>El operador or es expl\u00edcito y est\u00e1 representado por el car\u00e1cter vertical |.</p> <p>El operador not es expl\u00edcito, est\u00e1 representado por el s\u00edmbolo !, brinda la posibilidad de excluir un patr\u00f3n. Con esto se puede decir que una cadena no debe ir seguida de otra cadena.</p> <p>In regex, there is positive lookahead (?=) and negative lookahead (?!):</p> <p>Positive lookahead (?=) ensures something followed by something else. Negative lookahead (?!) ensures something NOT followed by something else.</p> <p>For example, b(?=c) matches a b that is followed by a c. (positive lookahead) For example, b(?!c) matches a b that is NOT followed by a c. (negative lookahead)</p>"},{"location":"ud7/7regularexpressions/#ejemplo-expresion-regular-telefono-movil","title":"Ejemplo expresi\u00f3n regular tel\u00e9fono m\u00f3vil","text":"<pre><code>//(+34) 655-555-555\nString regexTelefono = \"^([\\\\(]{1}[\\\\+]{1}34[\\\\)]{1}[ ]{1}[0-9]{3}[\\\\-]{1}[0-9]{3}[\\\\-]{1}[0-9]{3})$\";\n\nString t1 = \"123456789\";//no\nString t2 = \"(+35) 123456-789\";//no\nString t3 = \"(+34) 123-456-789\";//si\nString t4 = \"(+34)123-456-789\";//no\n\nSystem.out.println(t1.matches(regexTelefono));//false\nSystem.out.println(t2.matches(regexTelefono));//false\nSystem.out.println(t3.matches(regexTelefono));//true\nSystem.out.println(t4.matches(regexTelefono));//false\n</code></pre>"},{"location":"ud7/8optional/","title":"Optional","text":"<p><code>Optional</code> es una clase gen\u00e9rica, cuyo prop\u00f3sito es ser un contenedor para un valor que puede o no ser nulo. Fue creado por los ingenieros de Java, para abordar el problema o excepci\u00f3n tan conocida la <code>NullPointerException</code>.</p> <p>La documentaci\u00f3n oficial de Java dice que este tipo est\u00e1 pensado principalmente para un uso como tipo de retorno de m\u00e9todo, bajo condiciones espec\u00edficas.</p> <p><code>Optional</code> trata de resolver el problema cuando hay ausencia de resultados o datos y no queremos que esto sea un error. Por ejemplo, no todas las personas tienen 2o apellido. Esto ser\u00eda v\u00e1lido para un optional, pero por ejemplo todo el mundo tenemos fecha de nacimiento, esto si que es un error.</p>"},{"location":"ud7/8optional/#crear-una-instancia-de-optional","title":"Crear una instancia de <code>Optional</code>","text":"<p><code>Optional</code> es una clase gen\u00e9rica que se declara como cualquier otra, indicando el tipo. Aunque, no se puede construir un <code>Optional</code>. En su lugar, se usa uno de sus m\u00e9todos est\u00e1ticos: <code>empty</code>, <code>of</code> or <code>ofNullable</code>.</p> <p></p>"},{"location":"ud7/8optional/#ejemplo-con-optionalof","title":"Ejemplo con <code>Optional.of</code>","text":"<pre><code>Student s = new Student(\"Patricia\", 32, LocalDate.now());        Optional&lt;Student&gt; op = Optional.of(s);\nSystem.out.println(\"Empty: \" + op.isEmpty() + \" Present: \" + op.isPresent());\n</code></pre> <p>Output</p> <p>Optional[Patricia,32,2023-10-15]</p> <p>Empty: false Present: true</p> <p>Hay que tener cuidado con Optional.of(object), ya que si lo usamos y puede llegar un valor <code>null</code>, dar\u00e1 una excepci\u00f3n <code>NullPointerException</code>:</p> <pre><code>Student s = null;\nOptional&lt;Student&gt; op = Optional.of(s);\nSystem.out.println(op);\nSystem.out.println(\"Empty: \" + op.isEmpty() + \" Present: \" + op.isPresent());\n</code></pre> <p>Output</p> <p><code>NullPointerException</code></p> <p>Por tanto, no habremos solucionado el problema, en vez de eso, debemos usar el m\u00e9todo Optional.ofNullable(object), que si el objeto que se pasa es <code>null</code>, devolver\u00e1 un <code>Optional</code> vac\u00edo.</p> <pre><code>Student s = null;\nOptional&lt;Student&gt; op = Optional.ofNullable(s);\nSystem.out.println(op);\nSystem.out.println(\"Empty: \" + op.isEmpty() + \" Present: \" + op.isPresent());\n</code></pre> <p>Output</p> <p>Optional.empty</p> <p>Empty: true Present: false</p> <p>La primera regla para los desarrolladores que utilizan <code>Optional</code>, es que cualquier m\u00e9todo que devuelva un <code>Optional</code>, nunca debe devolver null. En su lugar, deber\u00eda devolver un optional vac\u00edo.</p>"},{"location":"ud7/8optional/#como-obtener-el-objeto-o-valor-del-optional","title":"C\u00f3mo obtener el objeto o valor del <code>Optional</code>","text":"<p>El tipo <code>Optional</code> tiene un m\u00e9todo <code>get()</code>, que devuelve el valor.</p> <pre><code>Student student = new Student(\"Patricia\", 32, LocalDate.now());\nOptional&lt;Student&gt; op = Optional.ofNullable(student);\nSystem.out.println(op.get());\nSystem.out.println(\"Empty: \" + op.isEmpty() + \" Present: \" + op.isPresent());\n</code></pre> <p>Output</p> <p>Patricia,32,2023-10-15</p> <p>Empty: false Present: true</p> <p>En el ejemplo anterior, ha funcionado correctamente, hemos obtenido el objeto Student al hacer op.get(). Veamos que pasa, cuando <code>Optional.ofNullable()</code> devuelve un optional vac\u00edo:</p> <pre><code>Student studentNull = null;\nOptional&lt;Student&gt; op = Optional.ofNullable(studentNull);\nSystem.out.println(op.get());\nSystem.out.println(\"Empty: \" + op.isEmpty() + \" Present: \" + op.isPresent());\n</code></pre> <p>Output</p> <p>Exception in thread \"main\" java.util.NoSuchElementException: No value present</p> <p>El c\u00f3digo anterior nos lanza una excepci\u00f3n porque s\u00f3lo podemos llamar al m\u00e9todo get() si el m\u00e9todo isPresent es verdadero, es decir, si tengo valor. Para corregir el error tendr\u00edamos que realizar lo siguiente:</p> <p><pre><code>Student studentNull = null;\nOptional&lt;Student&gt; op = Optional.ofNullable(studentNull);\nif (op.isPresent()) {\nSystem.out.println(op.get());\n}\n\n// tambi\u00e9n puedes hacerlo en una sola l\u00ednea de c\u00f3digo\nop.ifPresent(System.out::println);\n</code></pre> Ahora vemos que no imprime nada porque isPresent() devuelve false, ya que optional es vac\u00edo. Si queremos mostrar algo cuando tengamos un Optional vac\u00edo, podemos usar el m\u00e9todo <code>ifPresentOrElse</code>:</p> <pre><code>Student studentNull = null;\nOptional&lt;Student&gt; op = Optional.ofNullable(studentNull);\nop.ifPresentOrElse(System.out::println, ()-&gt; System.out.println(\"empty object\"));\n</code></pre> <p>El m\u00e9todo ifPresentOrElse, recibe un <code>Consumer</code>, que es si el objeto no est\u00e1 vac\u00edo, y un <code>Runnable</code> que se llamar\u00e1 si est\u00e1 vac\u00edo. Como <code>Runnable</code> es una interfaz funcional, podemos usar lambda para implementar el m\u00e9todo <code>run</code>, que ser\u00e1 la acci\u00f3n que se realice si el objeto <code>Optional</code> es vac\u00edo.</p> <p>Output</p> <p>empty object</p>"},{"location":"ud7/9var/","title":"Keyword var","text":"<p><code>var</code> es una palabra clave introducida en Java 10 como parte de las mejoras en el sistema de inferencia de tipos para las variables locales. </p> <p>El uso de var permite que el compilador infiera autom\u00e1ticamente el tipo de una variable en funci\u00f3n del tipo de dato al que se asigna. Esto puede hacer que el c\u00f3digo sea m\u00e1s conciso y legible al reducir la redundancia en la declaraci\u00f3n de variables.</p> <p>Por ejemplo, antes de la introducci\u00f3n de var, podr\u00edas declarar una variable as\u00ed:</p> <pre><code>List&lt;String&gt; lista = new ArrayList&lt;String&gt;();\n</code></pre> <p>Con var, la declaraci\u00f3n se simplificar\u00eda de la siguiente manera:</p> <p><pre><code>var lista = new ArrayList&lt;String&gt;();\n</code></pre> En este caso, el compilador infiere que lista es del tipo ArrayList bas\u00e1ndose en el tipo de dato utilizado en el lado derecho de la asignaci\u00f3n."},{"location":"ud7/9var/#consideraciones-importantes-en-el-uso-de-var","title":"Consideraciones importantes en el uso de <code>var</code>","text":"<ul> <li> <p>Inferencia de Tipo. El compilador infiere el tipo de la variable en funci\u00f3n del tipo de dato a la derecha de la asignaci\u00f3n. No se puede utilizar <code>var</code> para variables de instancia de clases, par\u00e1metros de m\u00e9todos, variables de array, o variables con valores null sin asignar.</p> </li> <li> <p>Uso Responsable. Se recomienda su uso con moderaci\u00f3n y en situaciones donde el tipo es obvio o donde la inferencia de tipo mejora la legibilidad del c\u00f3digo.</p> </li> <li> <p>C\u00f3digo m\u00e1s Conciso. Puede hacer que el c\u00f3digo sea m\u00e1s conciso y eliminar la redundancia en declaraciones de variables.</p> </li> </ul> <pre><code>// Ejemplo de uso de var para eliminar la redundancia\nList&lt;String&gt; nombres = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\");\nfor (var nombre : nombres) {//no repetimos que el tipo es String\nSystem.out.println(nombre);\n}\n</code></pre>"},{"location":"ud8/1javafx/","title":"JavaFX","text":"<p>JavaFX es una plataforma de aplicaciones de cliente de pr\u00f3xima generaci\u00f3n de c\u00f3digo abierto para sistemas integrados, m\u00f3viles y de escritorio construidos en Java. Es un esfuerzo de colaboraci\u00f3n de muchas personas y empresas con el objetivo de producir un conjunto de herramientas moderno, eficiente y con todas las funciones para desarrollar aplicaciones de clientes enriquecidos.</p> <p>En este tema nos centraremos en las aplicaciones de escritorio. JavaFX est\u00e1 disponible en Windows, Mac OS X y Linux.</p> <p>Dado que la biblioteca JavaFX est\u00e1 escrita como una API de Java, el c\u00f3digo de la aplicaci\u00f3n JavaFX puede hacer referencia a las API de cualquier biblioteca de Java. Por ejemplo, las aplicaciones JavaFX pueden usar bibliotecas API de Java para acceder a las capacidades del sistema nativo y conectarse a aplicaciones de middleware basadas en servidor.</p> <p>Es en esencia un conjunto de paquetes en Java y el sucesor de swing.</p> <p>Documentaci\u00f3n oficial para JavaFX JDK11</p> <p>API documentation</p>"},{"location":"ud8/1javafx/#crear-un-nuevo-proyecto-javafx","title":"Crear un nuevo proyecto JavaFX","text":"<p>En IntelliJ, seleccionamos File -&gt; New Project</p> <p></p> <p>Seleccionamos JavaFX, lo llamamos HolaMundo y le damos a crear. Para ejecutarlo nos ponemos en la clase principal y hacemos click en Run.</p> <p></p>"},{"location":"ud8/1javafx/#workflow-de-una-aplicacion-javafx","title":"Workflow de una aplicaci\u00f3n JavaFX","text":"<ol> <li> <p><code>Application</code> La clase de <code>Application</code> del paquete javafx.application es el punto de entrada de la aplicaci\u00f3n en JavaFX. Para crear una aplicaci\u00f3n JavaFX, se debe heredar esta clase e implementar su m\u00e9todo abstracto <code>start()</code>. La clase principal tiene el nombre del proyecto seguido de Application y extiende de la clase <code>Application</code>, que es la que gestiona el ciclo de vida de una aplicaci\u00f3n JavaFX.</p> </li> <li> <p><code>main</code> method Cuando ejecutamos la aplicaci\u00f3n JavaFX por primera vez, se lanza el m\u00e9todo <code>main</code> que contiene el m\u00e9todo <code>launch</code> que lanza la aplicaci\u00f3n JavaFX y no vuelve hasta que se cierra la aplicaci\u00f3n.</p> </li> <li> <p><code>init</code> method Cuando un aplicaci\u00f3n JavaFX es lanzada, el m\u00e9todo <code>init</code> se ejecuta primero. Este m\u00e9todo se encuentra en la clase <code>Application</code> y est\u00e1 vac\u00edo, por lo que podremos sobreescribirlo si queremos hacer algo con \u00e9l.</p> </li> <li> <p><code>start</code> method El m\u00e9todo <code>start</code> se ejecuta justo despu\u00e9s del m\u00e9todo <code>init</code>. <code>start</code> es un m\u00e9todo abstracto que heredamos de la clase <code>Application</code> por lo que siempre hay que sobreescribirlo y darle cuerpo.</p> </li> <li> <p><code>stop</code> method Cuando la aplicaci\u00f3n acaba porque los usuario cierran la ventana de la aplicaci\u00f3n se ejecuta el m\u00e9todo <code>stop</code>. Igual que pasa con el m\u00e9todo <code>init</code>, este m\u00e9todo se encuentra en la clase <code>Application</code> y est\u00e1 vac\u00edo tambi\u00e9n. Si no lo sobreescribimos no se har\u00e1 nada con \u00e9l.</p> </li> </ol>"},{"location":"ud8/1javafx/#estructura-de-una-aplicacion-javafx","title":"Estructura de una aplicaci\u00f3n JavaFX","text":"<p>En general, una aplicaci\u00f3n JavaFX tendr\u00e1 tres componentes principales, Stage, Scene y Node como se muestra en la siguiente figura:</p> <p></p>"},{"location":"ud8/2stage/","title":"JavaFX Stage","text":"<p>Uno de los s\u00edmiles que m\u00e1s se aproxima para entender estos conceptos es ver el stage como un escenario, teatro o cine, en el cual, se desarrollan escenas. Dicho de otro modo, stage es un espacio y una escena define que sucede en ese espacio. Visto as\u00ed, tenemos que un stage es el contenedor de nivel superior, que como m\u00ednimo consta de una escena, que a su vez es contenedora de otros elementos.</p> <p>Si nuestra programa es una aplicaci\u00f3n de escritorio, el stage ser\u00e1 la ventana, con su barra de t\u00edtulo, y botones de maximizar, minimizar o cerrar, en el caso que que se ejecutase en un navegador web como Chrome, nuestro stage esta embebido dentro del navegador.</p> <p>Un <code>Stage</code> JavaFX, javafx.stage.Stage, es un contenedor de nivel superior y extiende de la clase <code>Window</code>. Representa una ventana en una aplicaci\u00f3n de escritorio JavaFX. Dentro de un stage JavaFX, se puede insertar un <code>Scene</code> JavaFX que representar\u00e1 el contenido que se muestra dentro de una ventana, dentro de un <code>Stage</code>.</p> <p>Cuando se inicia una aplicaci\u00f3n JavaFX, se crea un objeto <code>Stage</code> ra\u00edz que se pasa al m\u00e9todo <code>start(Stage primaryStage)</code> de la clase ra\u00edz de la aplicaci\u00f3n JavaFX. Este objeto Stage representa la ventana principal de la aplicaci\u00f3n. Se pueden crear m\u00e1s objetos nuevos <code>Stage</code> m\u00e1s adelante si la aplicaci\u00f3n necesita abrir m\u00e1s ventanas.</p> <p>Normalmente las aplicaciones tienen una ventana o stage de nivel superior, ya que muchas ventanas pueden conducir a una mala experiencia por parte del usuario.</p> <p></p>"},{"location":"ud8/2stage/#crear-un-stage","title":"Crear un <code>Stage</code>","text":"<pre><code>Stage stage = new Stage();\n</code></pre>"},{"location":"ud8/2stage/#mostrar-un-stage","title":"Mostrar un <code>Stage</code>","text":"<p>Solo con crear un objeto Stage no basta para que se muestre en la aplicaci\u00f3n. Para que el Stage sea visible, se debe llamar a su m\u00e9todo <code>show()</code> o <code>showAndWait()</code>.</p> <pre><code>stage.show();\n</code></pre> <p>La diferencia entre los m\u00e9todos <code>show()</code> y <code>showAndWait()</code>, es que show() hace visible el <code>Stage</code> y sale del m\u00e9todo inmediatamente, mientras que showAndWait() muestra el objeto <code>Stage</code> y luego lo bloquea (permanece dentro del m\u00e9todo showAndWait()) hasta que se cierre el <code>stage</code>.</p>"},{"location":"ud8/2stage/#establecer-un-scene-a-un-stage","title":"Establecer un <code>Scene</code> a un <code>Stage</code>","text":"<p>Para mostrar algo dentro de un <code>Stage</code>, se debe establecer un objeto <code>Scene</code> en el Stage. El contenido de <code>Scene</code> se mostrar\u00e1 dentro del Stage cuando se muestre el Stage.</p> <pre><code>VBox vBox = new VBox(new Label(\"A JavaFX Label\"));\nScene scene = new Scene(vBox);\n\nStage stage = new Stage();\nstage.setScene(scene);\nstage.show();\n</code></pre>"},{"location":"ud8/2stage/#ponerle-titulo-a-un-stage","title":"Ponerle t\u00edtulo a un <code>Stage</code>","text":"<p>El t\u00edtulo del <code>Stage</code> se muestra en la barra de t\u00edtulo de la ventana.</p> <pre><code>stage.setTitle(\"Aplicaci\u00f3n JavaFX\");\n</code></pre>"},{"location":"ud8/2stage/#posicionar-un-stage","title":"Posicionar un <code>Stage</code>","text":"<p>Se puede establecer la posici\u00f3n (X,Y) de un <code>Stage</code> a trav\u00e9s de sus m\u00e9todos setX() y setY(). Los m\u00e9todos setX() y setY() establecen la posici\u00f3n de la esquina superior izquierda de la ventana.</p> <pre><code>Stage stage = new Stage();\n\nstage.setX(50);\nstage.setY(50);\n</code></pre>"},{"location":"ud8/2stage/#dimensionar-un-stage","title":"Dimensionar un <code>Stage</code>","text":"<p>Para establecer el ancho y el alto de un <code>Stage</code> utilizaremos los m\u00e9todos <code>setWidth()</code> y <code>setHeight()</code>.</p> <pre><code>Stage stage = new Stage();\n\nstage.setWidth(600);\nstage.setHeight(300);\n</code></pre>"},{"location":"ud8/2stage/#establecer-una-ventana-modal","title":"Establecer una ventana modal","text":"<p>Si queremos establecer la ventana como modal en un <code>Stage</code> usamos el m\u00e9todo <code>initModality()</code>. La modalidad determina si la ventana que representa el Stage bloquear\u00e1 otras ventanas abiertas por la misma aplicaci\u00f3n.</p> <pre><code>@Override\npublic void start(Stage primaryStage) {\nprimaryStage.setTitle(\"JavaFX App\");\n\nStage stage = new Stage();\nstage.initModality(Modality.APPLICATION_MODAL);\n//stage.initModality(Modality.WINDOW_MODAL);\n//stage.initModality(Modality.NONE);\n\nprimaryStage.show();\n\nstage.showAndWait();\n\n}\n</code></pre> <ul> <li>Modalidad.APPLICATION_MODAL, bloquear\u00e1 todas las dem\u00e1s ventanas abiertas por esta aplicaci\u00f3n. No puede acceder a ninguna otra ventana hasta que se haya cerrado esta ventana.</li> <li>Modality.WINDOW_MODAL el <code>Stage</code> creado bloquear\u00e1 la ventana del <code>Stage</code> que \"posee\" (propietario) el <code>Stage</code> creado, pero solo eso. No todas las ventanas de la aplicaci\u00f3n.</li> <li>Modalidad.NONE el <code>Stage</code> no bloquear\u00e1 ninguna otra ventana abierta en esta aplicaci\u00f3n.</li> </ul>"},{"location":"ud8/2stage/#establecer-propietario-de-un-stage","title":"Establecer propietario de un <code>Stage</code>","text":"<p>Un <code>Stage</code> puede ser propiedad de otro <code>Stage</code>. El propietario de un stage se establece a trav\u00e9s de su m\u00e9todo <code>initOwner()</code>.</p> <pre><code>@Override\npublic void start(Stage primaryStage) {\nprimaryStage.setTitle(\"JavaFX App\");\n\nStage stage = new Stage();\nstage.initModality(Modality.WINDOW_MODAL);\n\nstage.initOwner(primaryStage);\n\nprimaryStage.show();\n\nstage.showAndWait();\n}\n</code></pre>"},{"location":"ud8/2stage/#dar-estilo-a-un-stage","title":"Dar estilo a un <code>Stage</code>","text":"<p>Se puede dar estilo a un stage utilizando el m\u00e9todo <code>initStyle()</code>. Hay un conjunto de estilos diferentes:</p> <ul> <li>DECORATED: es una ventana est\u00e1ndar con decoraciones del sistema operativo (barra de t\u00edtulo y botones para minimizar/maximizar/cerrar) y un fondo blanco.</li> <li>UNDECORATED: es una ventana est\u00e1ndar sin decoraciones del sistema operativo, pero a\u00fan con un fondo blanco.</li> <li>TRANSPARENT: es una ventana sin decorar con un fondo transparente.</li> <li>UNIFIED: es como un escenario decorado, excepto que no tiene borde entre el \u00e1rea de decoraci\u00f3n y el \u00e1rea de contenido principal.</li> <li>UTILITY: es una ventana decorada, pero con decoraciones m\u00ednimas.</li> </ul> <pre><code>stage.initStyle(StageStyle.DECORATED);\n</code></pre>"},{"location":"ud8/2stage/#stage-a-pantalla-completa","title":"<code>Stage</code> a pantalla completa","text":"<p>Se puede establecer el stage a modo de pantalla completa a trav\u00e9s del m\u00e9todo <code>setFullScreen()</code>. Nota: puede que no obtengamos el resultado esperado sino a\u00f1adimos un <code>Scene</code> en el stage.</p> <pre><code>VBox vbox = new VBox();\nScene scene = new Scene(vbox);\n\nprimaryStage.setScene(scene);\nprimaryStage.setFullScreen(true);\n\nprimaryStage.show();\n</code></pre>"},{"location":"ud8/2stage/#eventos-del-ciclo-de-vida-de-un-stage","title":"Eventos del ciclo de vida de un <code>Stage</code>","text":"<p><code>Stage</code> emite algunos eventos que se pueden escuchar.</p> <ul> <li>Close Request: se recibe una notificaci\u00f3n cuando el usuario hace click en el bot\u00f3n con la X en la esquina superior derecha de la ventana del escenario. Escuchar el evento de cierre del escenario puede ser \u00fatil si se necesita limpiar algunos recursos despu\u00e9s de cerrar la ventana principal del escenario, o p. necesita detener algunos hilos, etc.</li> </ul> <pre><code>primaryStage.setOnCloseRequest((event) -&gt; {\nSystem.out.println(\"Closing Stage\");\n});\n</code></pre> <ul> <li>Hiding: se llama antes de que se oculte el stage, pero despu\u00e9s de que se haya solicitado ocultarlo.</li> </ul> <pre><code>primaryStage.setOnHiding((event) -&gt; {\nSystem.out.println(\"Hiding Stage\");\n});\n</code></pre> <ul> <li>Hidden: se llama despu\u00e9s de que se oculta el Stage.</li> </ul> <pre><code>primaryStage.setOnHidden((event) -&gt; {\nSystem.out.println(\"Stage hidden\");\n});\n</code></pre> <ul> <li>Showing: se llama despu\u00e9s de que se solicite que se muestre el stage, pero antes de que se muestre.</li> </ul> <pre><code>primaryStage.setOnShowing((event) -&gt; {\nSystem.out.println(\"Showing Stage\");\n});\n</code></pre> <ul> <li>Shown: se llama despu\u00e9s de que se muestre el stage.</li> </ul> <pre><code>primaryStage.setOnShown((event) -&gt; {\nSystem.out.println(\"Stage Shown\");\n});\n</code></pre>"},{"location":"ud8/2stage/#eventos-de-teclado-del-stage","title":"Eventos de teclado del <code>Stage</code>","text":"<p>Podemos escuchar eventos de teclado en un stage. De esta forma, se puede capturar todos los eventos del teclado que ocurren mientras el stage tiene el foco. Ejemplo que escucha las teclas ESC y Retorno en el teclado cuando un Stage tiene foco:</p> <pre><code>primaryStage.addEventHandler(KeyEvent.KEY_PRESSED,  (event) -&gt; {\nSystem.out.println(\"Key pressed: \" + event.toString());\n\nswitch(event.getCode().getCode()) {\ncase 27 : { // 27 = ESC key\nprimaryStage.close();\nbreak;\n}\ncase 10 : { // 10 = Return\nprimaryStage.setWidth( primaryStage.getWidth() * 2);\n}\ndefault:  {\nSystem.out.println(\"Unrecognized key\");\n}\n}\n});\n</code></pre>"},{"location":"ud8/3scene/","title":"JavaFX Scene","text":"<p>Para mostrar cualquier cosa en un escenario <code>Stage</code> se necesita una escena <code>Scene</code>. Un <code>Stage</code> solo puede mostrar una escena a la vez, pero es posible intercambiar la escena en tiempo de ejecuci\u00f3n. Al igual que un escenario en un teatro se puede reorganizar para mostrar varias escenas durante una obra, un objeto de escenario (stage) en JavaFX puede mostrar varias escenas (una a la vez) durante la vida \u00fatil de una aplicaci\u00f3n JavaFX.</p> <p>Quiz\u00e1s se pregunte por qu\u00e9 una aplicaci\u00f3n JavaFX tendr\u00eda m\u00e1s de una escena por etapa. Imagina un juego de computadora. Un juego puede tener m\u00faltiples \"pantallas\" para mostrar al usuario. Por ejemplo, una pantalla de men\u00fa inicial, la pantalla principal del juego (donde se juega el juego), una pantalla de finalizaci\u00f3n del juego y una pantalla de puntuaci\u00f3n m\u00e1s alta. Cada una de estas pantallas puede ser representada por una escena diferente. Cuando el juego necesita cambiar de una pantalla a la siguiente, simplemente adjunta la escena correspondiente al objeto Stage de la aplicaci\u00f3n JavaFX.</p> <p>Una escena est\u00e1 representada por un objeto <code>Scene</code> dentro de una aplicaci\u00f3n JavaFX.</p> <p>Note</p> <p>Para que un objeto <code>Scene</code> sea visible debe configurarse en un <code>Stage</code>.</p>"},{"location":"ud8/3scene/#scene-graph","title":"Scene Graph","text":"<p>Todos los componentes visuales (controls, layouts, etc.) deben adjuntarse a un <code>Scene</code> para ser mostrados, y ese <code>Scene</code> debe adjuntarse a un <code>Stage</code> para que la escena completa sea visible. El objeto gr\u00e1fico total final de todos los controles, layouts, etc. adjuntos a un <code>Scene</code> se denomina gr\u00e1fico de escena (Scene Graph).</p> <p>Consta de todos los nodos que se adjuntan a un objeto de Scene determinado. Cada objeto Scene tiene su propio gr\u00e1fico de escena.</p> <p>El Scene Graph tiene un \u00fanico nodo ra\u00edz. Se pueden adjuntar otros nodos al nodo ra\u00edz en una estructura de datos similar a un \u00e1rbol (un \u00e1rbol es una especie de gr\u00e1fico).</p>"},{"location":"ud8/3scene/#crear-un-scene","title":"Crear un Scene","text":"<p>Para crear un objeto <code>Scene</code> lo haremos a trav\u00e9s de su constructor. Como par\u00e1metro, se debe pasar el componente ra\u00edz de la GUI de JavaFX que actuar\u00e1 como la vista ra\u00edz que se mostrar\u00e1 dentro de la escena.</p> <pre><code>VBox  vBox  = new VBox();\nScene scene = new Scene(vBox);\n</code></pre>"},{"location":"ud8/3scene/#establecer-un-scene-en-un-stage","title":"Establecer un Scene en un Stage","text":"<p>Para hacer visible un <code>Scene</code> debe asignarse a un <code>Stage</code>.</p> <pre><code>VBox vBox = new VBox(new Label(\"A JavaFX Label\"));\nScene scene = new Scene(vBox);\n\nStage stage = new Stage();\nstage.setScene(scene);\n</code></pre> <p>Un Scene se puede adjuntar a un solo Stage a la vez, y el Stage tambi\u00e9n puede mostrar solo un Scene a la vez.</p>"},{"location":"ud8/3scene/#scene-mouse-cursor","title":"Scene Mouse Cursor","text":"<p>Es posible configurar el cursor del mouse de un <code>Scene</code>. Se establece el cursor del mouse de una escena a trav\u00e9s del m\u00e9todo <code>setCursor()</code>.</p> <pre><code>scene.setCursor(Cursor.OPEN_HAND);\n</code></pre> <p>La clase <code>javafx.scene.Cursor</code> contiene muchas constantes que puede usar para especificar qu\u00e9 cursor del mouse desea mostrar. Algunas de estas constantes son:</p> <ul> <li>Cursor.OPEN_HAND</li> <li>Cursor.CLOSED_HAND</li> <li>Cursor.CROSSHAIR</li> <li>Cursor.DEFAULT</li> <li>Cursor.HAND</li> <li>Cursor.WAIT</li> <li>Cursor.MOVE</li> </ul> <p>Puede consultar el resto en la documentaci\u00f3n oficial de JavaFX.</p>"},{"location":"ud8/4node/","title":"JavaFX Node","text":"<p>La clase <code>Node</code>, javafx.scene.Node, es la clase base (superclase) para todos los componentes agregados a JavaFX Scene Graph. La clase <code>Node</code> es abstracta, por lo que solo agregar\u00e1 subclases de la clase Node al Scene Graph. Todas las instancias de <code>Node</code> en el escenario gr\u00e1fico comparten un conjunto de propiedades comunes que est\u00e1n definidas por la clase JavaFX <code>Node</code> y que veremos a continuaci\u00f3n.</p>"},{"location":"ud8/4node/#conceptos-basicos-de-node","title":"Conceptos b\u00e1sicos de <code>Node</code>","text":"<p>Cada instancia de <code>Node</code> (subclase) solo se puede agregar al Scene Graph una vez. En otras palabras, cada instancia de Node solo puede aparecer en un lugar en el escenario gr\u00e1fico. Si intenta agregar la misma instancia de Node, o instancia de subclase de Node, al gr\u00e1fico de escena m\u00e1s de una vez, se generar\u00e1 una excepci\u00f3n.</p> <p>Un nodo JavaFX a veces puede tener subelementos, que tambi\u00e9n se denominan elementos secundarios.</p> <p>Una vez que se adjunta una instancia de node al gr\u00e1fico de escena, solo el hilo de la aplicaci\u00f3n JavaFX puede modificar la instancia de node.</p>"},{"location":"ud8/4node/#propiedades-de-javafx-node","title":"Propiedades de JavaFX <code>Node</code>","text":"<p>La clase <code>Node</code> y, por lo tanto, todas las subclases de Node, tienen las siguientes propiedades comunes:</p>"},{"location":"ud8/4node/#1-sistema-de-coordenadas-coordinate-system","title":"1. Sistema de coordenadas (Coordinate System)","text":"<p>Cada nodo JavaFX tiene su propio sistema de coordenadas cartesianas. La \u00fanica diferencia con un sistema de coordenadas cartesianas regular es que el eje Y est\u00e1 invertido. Eso significa que el origen del sistema de coordenadas est\u00e1 en la esquina superior izquierda del sistema de coordenadas. A medida que aumentan los valores de Y, el punto se mueve hacia abajo desde la parte superior del sistema de coordenadas. Esta inversi\u00f3n del eje Y es normal en los sistemas de coordenadas de gr\u00e1ficos 2D.</p> <p></p> <p>Es posible que un nodo JavaFX tenga coordenadas X e Y negativas.</p> <p>Cada nodo tiene su propio sistema de coordenadas. Este sistema de coordenadas se utiliza para colocar instancias de nodos secundarios dentro del nodo principal o al dibujar en un lienzo JavaFX. Eso significa que un nodo que es hijo de otro nodo tiene su propio sistema de coordenadas y una ubicaci\u00f3n (X,Y) dentro del sistema de coordenadas de su nodo principal.</p> <p>A continuaci\u00f3n se muestra un ejemplo de un sistema de coordenadas de nodo principal en el que un nodo secundario est\u00e1 ubicado en (25,25) en el sistema de coordenadas del nodo principal. El nodo secundario tambi\u00e9n tiene su propio sistema de coordenadas que tiene su (0,0) donde el nodo secundario se encuentra en el sistema de coordenadas principal, es decir, en (25,25) en el sistema de coordenadas del nodo principal.</p> <p></p>"},{"location":"ud8/4node/#2-cuadro-delimitador-bounding-box","title":"2. Cuadro delimitador (Bounding Box)","text":"<p>Un nodo JavaFX tiene un cuadro delimitador. El cuadro delimitador es un cuadro l\u00f3gico alrededor de la forma del nodo. El nodo completo se encuentra dentro del cuadro delimitador, es decir, gr\u00e1ficamente. En otras palabras, todas las esquinas y bordes del Nodo est\u00e1n contenidos dentro del cuadro delimitador, y no hay espacio adicional alrededor del Nodo, a menos que se agregue a trav\u00e9s de un efecto, relleno u otra cosa aplicada al Nodo.</p> <p>En realidad, un nodo tiene 3 cuadros delimitadores:</p> <ul> <li>layoutBounds Los l\u00edmites del nodo en su propio espacio de coordenadas, sin aplicar ning\u00fan efecto, recorte o transformaci\u00f3n.</li> <li>boundsInLocal Los l\u00edmites del nodo en su propio espacio de coordenadas, con efectos y clip aplicados, pero sin transformaciones.</li> <li>boundsInParent Los l\u00edmites del nodo en su espacio de coordenadas principal, con efectos, recorte y transformaciones aplicadas.</li> </ul> <p>Cada una de estas dimensiones del cuadro delimitador se puede leer desde sus propiedades correspondientes con el mismo nombre, es decir, propiedades denominadas layoutBounds,boundsInLocal yboundsInParent.</p> <p>El cuadro boundsInParent es utilizado por el nodo padre (padre) para dise\u00f1ar sus hijos. El nodo principal necesita conocer el espacio total, incluidos todos los efectos, clips y transformaciones de un nodo para poder asignarle espacio.</p>"},{"location":"ud8/4node/#3-layoutx-y-layouty","title":"3. layoutX y layoutY","text":"<p>Las propiedades layoutX y layoutY de un objeto de nodo contienen la X y la Y del nodo dentro de su padre.</p>"},{"location":"ud8/4node/#4-preferred-height-and-width","title":"4. Preferred height and width","text":"<p>Las propiedades de ancho y alto preferidas de un objeto de nodo especifican el ancho y alto preferidos del objeto de nodo dado (normalmente subclase de nodo). No todas las clases de nodos principales respetar\u00e1n el ancho preferido y la altura preferida de un nodo secundario. Depende de la implementaci\u00f3n concreta del nodo padre.</p>"},{"location":"ud8/4node/#5-minimum-height-and-minimum-width","title":"5. Minimum height and Minimum width","text":"<p>Las propiedades m\u00ednimas de ancho y alto de un objeto de nodo JavaFX especifican el ancho y el alto m\u00ednimos que un nodo quiere (o necesita) para mostrarse. No todas las clases de nodos principales pueden respetar estas propiedades. Depende de la implementaci\u00f3n concreta del nodo padre.</p>"},{"location":"ud8/4node/#6-maximum-height-and-maximum-width","title":"6. Maximum height and Maximum width","text":"<p>Las propiedades m\u00e1ximas de ancho y alto de un objeto de nodo especifican el ancho y alto m\u00e1ximo que un nodo quiere (o necesita) para mostrarse. No todas las clases de nodos principales pueden respetar estas propiedades. Depende de la implementaci\u00f3n concreta del nodo padre.</p>"},{"location":"ud8/4node/#7-user-data","title":"7. User data","text":"<p>Puede establecer datos de usuario en un nodo utilizando el m\u00e9todo <code>setUserData()</code>. Este m\u00e9todo toma cualquier objeto Java de su elecci\u00f3n. De esta manera puede adjuntar, por ejemplo objetos de instancias de nodo.</p>"},{"location":"ud8/4node/#8-items-child-nodes","title":"8. Items (Child nodes)","text":"<p>Muchas subclases de nodos pueden contener elementos o nodos secundarios. La forma exacta en que agrega y accede a estos nodos secundarios depende de la subclase de nodo concreta. Algunas clases tienen un m\u00e9todo <code>getItems()</code> que devuelve una lista de elementos. Otras clases tienen un m\u00e9todo <code>getChildren()</code> que hace lo mismo. Se tendr\u00e1 que comprobar la subclase de Nodo concreta para averiguar si puede tener elementos o nodos secundarios, y c\u00f3mo los agrega y accede a ellos.</p>"},{"location":"ud8/5uicontrols/","title":"UI Controls (User Interface Controls)","text":"<p>Los controles de la interfaz de usuario de JavaFX disponibles a trav\u00e9s de la API de JavaFX se crean mediante el uso de nodos en el gr\u00e1fico de escena. Pueden aprovechar al m\u00e1ximo las funciones visualmente ricas de la plataforma JavaFX y son port\u00e1tiles entre diferentes plataformas. JavaFX CSS permite la creaci\u00f3n de temas y estilos a los diferentes ontroles de la interfaz de usuario.</p> <p></p> <p>Las clases para construir controles de interfaz de usuario residen en el paquete <code>javafx.scene.control</code> de la API de JavaFX.</p> <p>La lista de controles de IU incluye componentes de IU t\u00edpicos que puede reconocer de su desarrollo anterior de aplicaciones cliente en Java. Sin embargo, el SDK de JavaFX presenta nuevos controles de interfaz de usuario de Java, como <code>TitledPane</code>, <code>ColorPicker</code> y <code>Pagination</code> entre otros.</p> <p>Podemos obtener informaci\u00f3n detallada sobre todos los controles de interfaz de usuario de JavaFX disponibles en Documentaci\u00f3n JavaFX UI y en la documentaci\u00f3n de la API para el paquete javafx.scene.control.</p>"},{"location":"ud8/5uicontrols/#funciones-y-efectos","title":"Funciones y efectos","text":"<p>Dado que los controles de la interfaz de usuario del paquete javafx.scene.control son extensiones de la clase Node, se pueden integrar con la representaci\u00f3n, la animaci\u00f3n, las transformaciones y las transiciones animadas del gr\u00e1fico de escena.</p> <p>Considere la tarea de crear un bot\u00f3n, aplicarle un reflejo y animar el bot\u00f3n alterando su opacidad de su valor m\u00e1ximo a su valor m\u00ednimo.</p> <p>La siguiente figura muestra tres estados del bot\u00f3n a trav\u00e9s de la l\u00ednea de tiempo de la animaci\u00f3n. La imagen de la izquierda muestra el bot\u00f3n cuando su opacidad se establece en 1,0, la imagen central muestra la opacidad establecida en 0,8 y la imagen de la derecha muestra la opacidad establecida en 0,5.</p> <p></p> <p>El siguiente ejemplo crea e inicia una l\u00ednea de tiempo indefinida, donde dentro de un cuadro de 600 milisegundos, la opacidad del bot\u00f3n cambia de su valor predeterminado (1,0) a 0,0.</p> <pre><code>Button button = new Button();\nbutton.setText(\"OK\");\nbutton.setFont(new Font(\"Tahoma\", 24));\nbutton.setEffect(new Reflection());\n\nfinal Timeline timeline = new Timeline();\ntimeline.setCycleCount(Timeline.INDEFINITE);\ntimeline.setAutoReverse(true);\nfinal KeyValue kv = new KeyValue(button.opacityProperty(), 0);\nfinal KeyFrame kf = new KeyFrame(Duration.millis(600), kv);\ntimeline.getKeyFrames().add(kf);\ntimeline.play();\n</code></pre> <p>Podemos aplicar otros efectos visuales disponibles en el paquete <code>javafx.scene.effect</code>, como sombra, iluminaci\u00f3n o desenfoque de movimiento.</p>"},{"location":"ud8/5uicontrols/#aplicar-estilo-a-los-controles-de-la-interfaz-de-usuario-con-css","title":"Aplicar estilo a los controles de la interfaz de usuario con CSS","text":"<p>Podemos personalizar el aspecto de los controles de la interfaz de usuario definiendo sus propias hojas de estilo en cascada (CSS). Usar CSS en aplicaciones JavaFX es muy similar a usar CSS en HTML, porque cada caso se basa en la misma especificaci\u00f3n de CSS. El estado visual de un control se define mediante el archivo .css, como se muestra en el ejemplo.</p> <pre><code>/*controlStyle.css */\n\n.scene{\n-fx-font: 14pt \"Cambria Bold\";\n-fx-color: #e79423;\n-fx-background: #67644e;\n}\n\n.button{\n-fx-text-fill: #006464;\n-fx-background-color: #e79423;\n-fx-border-radius: 20;\n-fx-background-radius: 20;\n-fx-padding: 5;\n}\n</code></pre> <pre><code>Scene scene = new Scene();\nscene.getStylesheets().add(\"uicontrolssample/controlStyle.css\");\n</code></pre> <p>Adem\u00e1s, tambi\u00e9n podemos definir el estilo de un control directamente en el c\u00f3digo de la aplicaci\u00f3n utilizando el m\u00e9todo <code>setStyle()</code>.</p>"},{"location":"ud8/5uicontrols/#graficos-charts","title":"Gr\u00e1ficos (Charts)","text":"<p>Adem\u00e1s de los elementos t\u00edpicos de una interfaz de usuario, JavaFX proporciona gr\u00e1ficos predefinidos en el paquete <code>javafx.scene.chart</code>. Actualmente se admiten los siguientes tipos de gr\u00e1ficos: gr\u00e1fico de \u00e1reas, gr\u00e1fico de barras, gr\u00e1fico de burbujas, gr\u00e1fico de l\u00edneas, gr\u00e1fico circular y gr\u00e1fico de dispersi\u00f3n. Un gr\u00e1fico puede contener varias series de datos.</p>"},{"location":"ud8/5uicontrols/#preferred-size-tamano-preferido","title":"Preferred Size (tama\u00f1o preferido)","text":"<p>Cada control calcula su preferred size en funci\u00f3n de su contenido, es decir, el alto y el ancho del control cuando se muestra.</p> <p>Por ejemplo, en el caso de un button se redimensionar\u00e1 a si mismo de forma que haya espacio suficiente para mostrar su contenido, en su caso el texto.</p>"},{"location":"ud8/6layouts/","title":"Layout","text":"<p>Los contenedores o paneles de dise\u00f1o (layout) nos permiten a\u00f1adir controles de la interfaz de usuario dentro de un gr\u00e1fico de escena de una aplicaci\u00f3n JavaFX sin tener que escribir el c\u00f3digo necesario para gestionar el posicionamiento o el cambio de tama\u00f1o de esos controles. El Layout gestionar\u00e1 todo eso por nosotros. La API de layout de JavaFX incluye 8 layouts:</p> <ol> <li><code>BorderPane</code>: presenta sus nodos de contenido en la regi\u00f3n superior, inferior, derecha, izquierda o central. </li> <li><code>HBox</code> organiza sus nodos de contenido horizontalmente en una sola fila y los dimensiona con sus tama\u00f1os preferidos. Normalmente usamos un HBox para dise\u00f1ar un conjunto de botones en un di\u00e1logo.</li> <li><code>VBox</code> organiza sus nodos de contenido verticalmente en una sola columna.</li> <li><code>StackPane</code> coloca sus nodos de contenido en una sola pila de atr\u00e1s hacia adelante.</li> <li><code>GridPane</code> permite al desarrollador crear una cuadr\u00edcula flexible de filas y columnas en la que dise\u00f1ar los nodos de contenido. Cada posici\u00f3n de la cuadr\u00edcula se llama celda. Un fila ser\u00e1 tan alta como el control m\u00e1s alto y una columna ser\u00e1 tan ancha como el control m\u00e1s ancho que contiene.</li> <li><code>FlowPane</code> organiza sus nodos de contenido en un \"flujo\" horizontal o vertical, envolvi\u00e9ndose en los l\u00edmites especificados de ancho (para horizontal) o alto (para vertical).</li> <li><code>TilePane</code> coloca sus nodos de contenido en mosaicos o celdas de dise\u00f1o de tama\u00f1o uniforme y los envuelve como hace <code>FlowPane</code>.</li> <li><code>AnchorPane</code> permite a los desarrolladores crear nodos de anclaje en la parte superior, inferior, izquierda o central del dise\u00f1o.</li> </ol> <p>Para lograr una estructura de dise\u00f1o deseada, se pueden anidar diferentes layouts dentro de una aplicaci\u00f3n JavaFX.</p> <p>En <code>HBox</code> y <code>VBox</code> si al reducir la ventana los hijos que contienen esos paneles no caben, entonces se cortan. En cambio, con <code>FlowPane</code>, pasan a la siguiente fila en el caso de que la orientaci\u00f3n sea horizontal y si es vertical pasar\u00edan a la siguiente columna.</p>"},{"location":"ud8/7events/","title":"Eventos","text":"<p>Cada vez que un usuario interact\u00faa con la aplicaci\u00f3n (nodos), se dice que ha ocurrido un evento. Existe un <code>UIThread</code> que est\u00e1 escuchando cuando lanzamos la aplicaci\u00f3n. Cuando el usuario hace algo el UIThread que est\u00e1 escuchando, mira a ver si se lanza un evento, y si es as\u00ed, env\u00eda el evento al controlador de eventos (event handler). El Event Handler se ejecuta en el subproceso del hilo UIThread. Mientras se ejecuta un evento del UIThread el usuario no puede interactuar con la aplicaci\u00f3n.</p> <p>Por ejemplo, hacer clic en un bot\u00f3n, mover el mouse, ingresar un car\u00e1cter a trav\u00e9s del teclado, seleccionar un elemento de la lista, desplazarse por la p\u00e1gina, etc. son ejemplos de actividades que provocan que suceda un evento.</p> <p>Un evento notifica que ha ocurrido algo importante. Los eventos suelen ser la parte \"primitiva\" de un sistema de eventos (tambi\u00e9n conocido como bus de eventos). Generalmente, un sistema de eventos tiene las siguientes 3 responsabilidades:</p> <ol> <li>Trigger an event (disparar un evento),</li> <li>Notify listeners (notificar a los oyentes partes interesadas) sobre el evento y</li> <li>Handle the event (manejar o procesar el evento).</li> </ol> <p>El mecanismo de notificaci\u00f3n de eventos lo realiza la plataforma JavaFX autom\u00e1ticamente. Por lo tanto, solo consideraremos c\u00f3mo disparar eventos, escuchar eventos y c\u00f3mo manejarlos.</p>"},{"location":"ud8/7events/#tipos-de-eventos","title":"Tipos de eventos","text":"<ul> <li>Eventos en primer plano (foreground events): requieren la interacci\u00f3n directa de un usuario. Se generan como consecuencia de la interacci\u00f3n de una persona con los componentes gr\u00e1ficos en una interfaz gr\u00e1fica de usuario. Por ejemplo, hacer clic en un bot\u00f3n, mover el mouse, ingresar un car\u00e1cter a trav\u00e9s del teclado, seleccionar un elemento de la lista, desplazarse por la p\u00e1gina, etc.</li> <li>Eventos de fondo (background events): no requieren la interacci\u00f3n del usuario final. Las interrupciones del sistema operativo, fallas de hardware o software, vencimiento del temporizador, finalizaci\u00f3n de la operaci\u00f3n son ejemplos de eventos en segundo plano.</li> </ul>"},{"location":"ud8/7events/#eventos-en-javafx","title":"Eventos en JavaFX","text":"<p>La clase denominada <code>Event</code> del paquete <code>javafx.event</code> es la clase base para un evento. Una instancia de cualquiera de sus subclases es un evento. JavaFX proporciona una amplia variedad de eventos. Algunos de ellos se enumeran a continuaci\u00f3n.</p> <ul> <li> <p>Mouse event: evento de entrada que ocurre cuando se hace clic en el mouse. Est\u00e1 representado por la clase denominada <code>MouseEvent</code>. Incluye acciones como hacer clic con el mouse, presionar el mouse, soltar el mouse, mover el mouse, objetivo ingresado con el mouse, objetivo salido del mouse, etc.</p> </li> <li> <p>Key event: evento de entrada que indica que se produjo una pulsaci\u00f3n de tecla en un nodo. Est\u00e1 representado por la clase denominada <code>KeyEvent</code>. Este evento incluye acciones como pulsaci\u00f3n de tecla, liberaci\u00f3n de tecla y escritura de tecla.</p> </li> <li> <p>Drag event: evento de entrada que ocurre cuando se arrastra el mouse. Est\u00e1 representado por la clase llamada <code>DragEvent</code>. Incluye acciones como arrastrar para insertar, arrastrar para soltar, etc.</p> </li> <li> <p>Window event: evento relacionado con las acciones de mostrar/ocultar ventanas. Est\u00e1 representado por la clase llamada <code>WindowEvent</code>.</p> </li> </ul>"},{"location":"ud8/7events/#manejo-de-eventos-event-handling","title":"Manejo de eventos (Event Handling)","text":"<p>Es el mecanismo que controla el evento y decide qu\u00e9 debe suceder, si ocurre un evento. Tiene el c\u00f3digo que se conoce como event handler que se ejecuta cuando ocurre un evento.</p> <p>En JavaFX cada evento tiene:</p> <ol> <li> <p>Target: el nodo en el que se produjo un evento. Un objetivo puede ser una ventana, una escena y un nodo.</p> </li> <li> <p>Source: la fuente a partir de la cual se genera el evento. Por ejemplo, el mouse es la fuente del evento.</p> </li> <li> <p>Type: tipo del evento ocurrido; en el caso de un evento del mouse, el tipo de evento es presionar el mouse y soltar el mouse.</p> </li> </ol> <p>Supongamos que tenemos una aplicaci\u00f3n que tiene botones. Si hace clic en un bot\u00f3n, la source ser\u00e1 el mouse, el target ser\u00e1 el nodo del bot\u00f3n presionado y el tipo de evento generado ser\u00e1 el clic del mouse.</p>"},{"location":"ud8/7events/#fases-del-manejo-de-eventos","title":"Fases del manejo de eventos","text":"<p>Cada vez que se genera un evento, JavaFX pasa por las siguientes fases.</p>"},{"location":"ud8/7events/#route-construction-construccion-de-rutas","title":"Route construction (Construcci\u00f3n de rutas)","text":"<p>Cada vez que se genera un evento, la ruta predeterminada/inicial del evento est\u00e1 determinada por la construcci\u00f3n de una cadena de env\u00edo de eventos. Es el camino desde el escenario hasta el Nodo fuente.</p> <p>A continuaci\u00f3n se muestra la cadena de env\u00edo de eventos para el evento generado, cuando hacemos clic en el bot\u00f3n en el escenario anterior: Stage -&gt; Scene -&gt; Button</p>"},{"location":"ud8/7events/#event-capturing-phase-fase-de-captura-de-eventos","title":"Event capturing phase (Fase de captura de eventos)","text":"<p>Despu\u00e9s de la fase anterior se dispara el evento. Este evento viaja a todos los nodos de la cadena de despacho anterior (de arriba a abajo). Si alguno de estos nodos tiene registrado un filtro (filter) para el evento generado, se ejecutar\u00e1. Si ninguno de los nodos en la cadena de despacho tiene un filtro para el evento generado, entonces se pasa al nodo de destino y finalmente el nodo de destino procesa el evento.</p>"},{"location":"ud8/7events/#event-bubbling-phase-fase-de-propagacion-de-eventos","title":"Event bubbling phase (Fase de propagaci\u00f3n de eventos)","text":"<p>Aqu\u00ed el evento viaja desde el nodo de destino hasta el nodo de Stage (de abajo hacia arriba). Si alguno de los nodos de la cadena de env\u00edo de eventos tiene un controlador (handler) registrado para el evento generado, se ejecutar\u00e1. Si ninguno de estos nodos tiene controladores para manejar el evento, entonces el evento llega al nodo ra\u00edz y finalmente se completar\u00e1 el proceso.</p>"},{"location":"ud8/7events/#event-handlers-and-filters","title":"Event handlers and filters","text":"<p>Los filter y handlers de eventos son aquellos que contienen la l\u00f3gica de la aplicaci\u00f3n para procesar un evento. Un nodo puede registrarse en m\u00e1s de un controlador/filtro (handler/filter).</p> <p>Como se mencion\u00f3 anteriormente, durante el evento, el procesamiento es un filtro que se ejecuta y durante la fase de propagaci\u00f3n del evento, se ejecuta un controlador. Todos los controladores y filtros implementan la interfaz EventHandler del paquete javafx.event.</p>"},{"location":"ud8/7events/#anadir-y-eliminar-un-event-filter","title":"A\u00f1adir y eliminar un event filter","text":"<p>Para agregar un filtro de eventos a un nodo, debe registrar este filtro utilizando el m\u00e9todo <code>addEventFilter()</code> de la clase Node.</p> <pre><code>//Creating the mouse event handler \nEventHandler&lt;MouseEvent&gt; eventHandler = new EventHandler&lt;MouseEvent&gt;() { @Override public void handle(MouseEvent e) { System.out.println(\"Hello World\"); boton.setFill(Color.DARKSLATEBLUE);  } };   //Adding event Filter \nboton.addEventFilter(MouseEvent.MOUSE_CLICKED, eventHandler);\n</code></pre> <p>Para eliminar un filter hacemos:</p> <pre><code>boton.removeEventFilter(MouseEvent.MOUSE_CLICKED, eventHandler);\n</code></pre>"},{"location":"ud8/7events/#anadir-y-eliminar-event-handler","title":"A\u00f1adir y eliminar event handler","text":"<p>Para agregar un controlador de eventos a un nodo, debe registrar este controlador mediante el m\u00e9todo <code>addEventHandler()</code> de la clase Node, como se muestra a continuaci\u00f3n.</p> <pre><code>//Creating the mouse event handler \nEventHandler&lt;MouseEvent&gt; eventHandler = new EventHandler&lt;MouseEvent&gt;() { @Override public void handle(MouseEvent e) { System.out.println(\"Hello World\"); boton.setFill(Color.DARKSLATEBLUE);             } };    //Adding the event handler \nboton.addEventHandler(MouseEvent.MOUSE_CLICKED, eventHandler);\n</code></pre> <p>Para eliminar:</p> <pre><code>boton.removeEventHandler(MouseEvent.MOUSE_CLICKED, eventHandler);\n</code></pre> <p>Controllers JavaFX</p>"},{"location":"ud9/12binaryfiles/","title":"Ficheros binarios","text":""},{"location":"ud9/12binaryfiles/#escribir-datos-en-un-fichero-binario","title":"Escribir datos en un fichero binario","text":"<p>La escritura en ficheros binarios representa el flujo de salida de bytes, es decir, necesitamos utilizar las clases que derivan de <code>OutputStream</code>. Se puede escribir datos en un fichero binario de muchas formas. Veamos un ejemplo utilizando la clase <code>FileOutputStream</code>.</p> <pre><code>public static void main(String[] args) {\ntry {\nDataOutputStream fos = new DataOutputStream(new FileOutputStream(\"datos.dat\"));\nfos.writeInt(0);\nfos.writeInt(-34);\nfos.close();\n} catch (FileNotFoundException e) { //todas pueden derivar de IOException\nSystem.out.println(e.getMessage());\n} catch (IOException e) {\nSystem.out.println(e.getMessage());\n}\n}\n</code></pre> <p>En el ejemplo, el constructor <code>FileOutputStream</code> abre el fichero <code>datos.dat</code> para escritura. Se crea un nuevo fichero; si un fichero antiguo tiene el mismo nombre, se eliminar\u00e1. Luego, un <code>DataOutputStream</code> se conecta al <code>FileOutputStream</code>.</p> <p><code>DataOutputStream</code> tiene m\u00e9todos para escribir datos primitivos en un flujo de salida. El m\u00e9todo writeInt() escribe los cuatro bytes de un tipo de datos int en la secuencia.</p> <p>El programa escribe cuatro enteros en el flujo de salida y luego cierra el flujo.</p> <p>Warning</p> <p>Siempre hay que cerrar el flujo para asegurarse de liberar todos los recursos asociados a \u00e9l y que el sistema operativo no consuma recursos.</p> <p>La excepci\u00f3n <code>IOException</code> se lanza si el stream se ha cerrado y el flujo de salida contenido no admite la escritura despu\u00e9s del cierre, o se produce otro error de I/O.</p>"},{"location":"ud9/12binaryfiles/#escritura-en-un-fichero-binario-usando-el-bufer","title":"Escritura en un fichero binario usando el b\u00fafer","text":"<p>Ahora vamos a escribir m\u00e1s enteros en el fichero. Para ello utilizamos <code>BufferedOutputStream</code>. Este b\u00fafer almacena los bytes antes de que se escriban en el disco. Recuerda que un b\u00fafer es un bloque de memoria que se usa para ensamblar datos antes de que se escriban todos a la vez.</p> <p>Cuando se cierra el stream <code>close()</code>, es como si pinch\u00e1ramos en guardar de forma gr\u00e1fica, es decir, que si no cerramos el stream es como si el fichero estuviera vac\u00edo.</p> <p>El almacenamiento en b\u00fafer hace que las operaciones de E/S sean m\u00e1s eficientes. Para un programa que realiza E/S masivas, el almacenamiento en b\u00fafer es esencial. La E/S es muy lenta en comparaci\u00f3n con las operaciones con almacenamiento principal. Sin almacenamiento en b\u00fafer, la E/S ser\u00eda muy, muy lenta.</p> <pre><code> public static void writeBuffer() {\ntry {\nDataOutputStream out = new DataOutputStream(\nnew BufferedOutputStream(\nnew FileOutputStream(\"datosBufer.dat\")));\nfor (int i = 0; i &lt; 1000; i++) {\nout.writeInt(i);\n}\nout.close();\n} catch (FileNotFoundException e) {\nthrow new RuntimeException(e);\n} catch (IOException e) {\nthrow new RuntimeException(e);\n}\n}\n</code></pre>"},{"location":"ud9/12binaryfiles/#lectura-de-datos-en-un-fichero-binario","title":"Lectura de datos en un fichero binario","text":"<p>Para leer un fichero, primero hemos de preguntarnos un poco sobre \u00e9l, es decir, si fue escrito por un programa Java, entonces necesitaremos saber qu\u00e9 tipos de datos se usaron, y as\u00ed poder usar una subclase de <code>InputStream</code> para leer bytes para ese tipo de datos.</p> <p><code>InputStream</code>, como hemos visto en los diagramas, es una clase abstracta para objetos que leen flujos de bytes. Aunque, no todas las clases que derivan de ella est\u00e1n relacionadas con la entrada de ficheros de disco. Por ejemplo, <code>PipedInputStream</code> representa datos provenientes de otro programa en ejecuci\u00f3n.</p> <pre><code>public static void main(String[] args) {\ntry {\nDataInputStream dis = new DataInputStream(new FileInputStream(\"datos.dat\"));\n//leer todos los enteros de un fichero\nwhile (dis.available() &gt; 0) {//me va diciendo cu\u00e1ntos bytes disponibles hay en el input stream\n//mientras hayan bytes que leer\nSystem.out.println(dis.readInt());\n}\ndis.close();\n} catch (FileNotFoundException e) { //todas pueden derivar de IOException\nSystem.out.println(e.getMessage());\n} catch (IOException e) {\nSystem.out.println(e.getMessage());\n}\n}\n</code></pre> <p>Al igual que en la escritura para la lectura tambi\u00e9n disponemos de la clase <code>BufferedInputStream</code>.</p>"},{"location":"ud9/13characterfiles/","title":"Ficheros de caracteres","text":"<p>Las clases Java <code>FileWriter</code> y <code>FileReader</code> se utilizan para escribir y leer datos de archivos de texto (son clases de flujo de caracteres, character stream). Se recomienda no utilizar las clases <code>FileInputStream</code> y <code>FileOutputStream</code> si vamos a leer o escribir informaci\u00f3n de texto.</p> <p></p>"},{"location":"ud9/13characterfiles/#escritura-de-caracteres","title":"Escritura de caracteres","text":"<p>La clase Java <code>FileWriter</code> del paquete java.io se utiliza para escribir datos en forma de caracteres en un archivo.</p> <ul> <li>Esta clase hereda de la clase <code>OutputStream</code>.</li> <li>Los constructores de esta clase asumen que la codificaci\u00f3n de caracteres predeterminada y el tama\u00f1o de b\u00fafer de bytes predeterminado son aceptables.</li> <li><code>FileWriter</code> est\u00e1 dise\u00f1ado para escribir secuencias de caracteres. Si queremos escribir flujos de bytes sin procesar, tendr\u00edamos que usar la clase <code>FileOutputStream</code>.</li> </ul> <pre><code>public static void main(String[] args) {\nString str = \"Este es un ejemplo de escritura usando FileWriter.\";\n\ntry {\nFileWriter fw = new FileWriter(\"output.txt\");\nfw.write(str);\nfw.close();\n} catch(IOException e) {\nSystem.out.println(\"Error E/S: \" + e);\n}\n}\n</code></pre> <p>Cuando se cierra el stream <code>close()</code> se escribe en el fichero. Si quisi\u00e9ramos grabar en el fichero en alg\u00fan momento antes de cerrar, podemos usar el m\u00e9todo <code>flush()</code>.</p>"},{"location":"ud9/13characterfiles/#lectura-de-datos","title":"Lectura de datos","text":"<p><code>FileReader</code> es una clase en el paquete java.io que se usa para leer una secuencia de caracteres de los ficheros. Esta clase se hereda de la clase <code>InputStreamReader</code>.</p> <ul> <li><code>FileReader</code> est\u00e1 dise\u00f1ada para leer flujos de caracteres. Para leer flujos de bytes sin procesar, usaremos <code>FileInputStream</code>.</li> </ul> <pre><code>    int ch;\ntry {\nFileReader fr = new FileReader(\"output.txt\");\nch = fr.read();\nwhile (ch != -1) { //fin de fichero\nSystem.out.print((char) ch);\nch = fr.read();\n}\nfr.close();\n} catch (IOException fe) {\nSystem.out.println(\"Error de E/S\");\n}\n</code></pre> <p>Al igual que ocurr\u00eda con los ficheros binarios, disponemos de las clases <code>BufferedReader</code> y <code>BufferedWriter</code> para leer y escribir usando el b\u00fafer y as\u00ed acceder a los datos m\u00e1s r\u00e1pidamente.</p>"},{"location":"ud9/14fileclass/","title":"File vs Path","text":"<p>En Java, <code>Path</code> y <code>File</code> son clases responsables de las operaciones de E/S de ficheros. Realizan las mismas funciones pero pertenecen a diferentes paquetes.</p>"},{"location":"ud9/14fileclass/#clase-file","title":"Clase <code>File</code>","text":"<p>Las primeras versiones de Java incluyen el paquete <code>java.io</code>, que contiene casi todas las clases que podr\u00edamos necesitar para realizar operaciones de entrada y salida. La clase <code>File</code> es una representaci\u00f3n abstracta de nombres de rutas de ficheros, directorios y m\u00e9todos para manipularlos.</p> <p>Un objeto <code>File</code> NO es el fichero real. No contiene los datos que contiene el fichero. Es un objeto que contiene m\u00e9todos que afectan a un archivo o directorio en particular y las funciones para la manipulaci\u00f3n real del archivo.</p> <p>Ejemplo en Windows:</p> <pre><code>File f = new File(\"C:\\\\Users\\\\temp\\\\data.txt\");\n</code></pre> <p>En Linux el car\u00e1cter separador es <code>/</code>.</p>"},{"location":"ud9/14fileclass/#constructor-de-file","title":"Constructor de <code>File</code>","text":"<pre><code>File(String pathName) //Constructor\n</code></pre> <p><code>pathName</code> es una secuencia de nombres de directorio seguidos de un nombre de archivo. Los nombres de los directorios est\u00e1n separados por un car\u00e1cter especial. La sintaxis de los nombres de directorio, separadores y nombres de archivo depende del sistema operativo.</p> <p>Warning</p> <p>Construir un objeto de la clase File NO CREA UN FICHERO</p>"},{"location":"ud9/14fileclass/#desventajas-de-la-clase-file","title":"Desventajas de la clase <code>File</code>","text":"<ul> <li> <p>Manejo de errores El problema m\u00e1s com\u00fan es el manejo deficiente de errores. Muchos m\u00e9todos no nos dicen ning\u00fan detalle sobre el problema encontrado o incluso lanzan excepciones.</p> </li> <li> <p>Compatibilidad con metadatos Los metadatos pueden incluir permisos, propietario del fichero y atributos de seguridad. Debido a esto, la clase <code>File</code> no admite enlaces simb\u00f3licos en absoluto, y el m\u00e9todo rename() no funciona de manera consistente en diferentes plataformas.</p> </li> <li> <p>Escalabilidad y rendimiento de m\u00e9todos Tambi\u00e9n hay un problema de rendimiento porque los m\u00e9todos de la clase File no escalan. Conduce a problemas con algunos directorios con una gran cantidad de archivos. Enumerar el contenido de un directorio podr\u00eda provocar un bloqueo, lo que provocar\u00eda problemas de recursos de memoria. Debido a algunos de estos inconvenientes, Oracle desarroll\u00f3 la API NIO2 mejorada.</p> </li> </ul>"},{"location":"ud9/14fileclass/#path-vs-file","title":"Path vs File","text":"<p>Cuando construimos un objeto <code>File</code> lo hacemos a trav\u00e9s del constructor, mientras que en la clase <code>Path</code> se usa un m\u00e9todo est\u00e1tico.</p> <pre><code>File file = new File(\"ada.txt\");\nPath path = Paths.get(\"ada.txt\");\n</code></pre>"},{"location":"ud9/15javanio/","title":"java.nio","text":"<ul> <li><code>java.nio.file.Path</code>: Es una interfaz que localiza un fichero o directorio mediante una ruta dependiente del sistema.</li> <li><code>java.nio.file.Files</code>: En combinaci\u00f3n con <code>Path</code>, realiza operaciones en ficheros o directorios.</li> <li><code>java.nio.file.FileSystem</code>: Proporciona una interfaz para el sistema de ficheros y una f\u00e1brica para crear <code>Path</code> y otros objetos que acceden al sistema de ficheros.</li> <li>Todos los m\u00e9todos que acceden al sistema de ficheros lanzan una excepci\u00f3n de tipo <code>IOException</code>.</li> </ul>"},{"location":"ud9/15javanio/#path","title":"<code>Path</code>","text":"<p>Ofrece una API completamente nueva para trabajar con E/S. Adem\u00e1s, al igual que la clase <code>File</code>, <code>Path</code> tambi\u00e9n crea un objeto que se puede usar para ubicar un archivo en un sistema de archivos.</p> <p><code>Path</code> puede realizar todas las operaciones que se pueden realizar con la clase <code>File</code>.</p> <p>Muchos ficheros utilizan la notaci\u00f3n \".\" para denotar el directorio actual y \"..\" para denotar el directorio del padre.</p>"},{"location":"ud9/15javanio/#filesystems-cargar-un-fichero-con-filesystems","title":"<code>FileSystems</code>. Cargar un fichero con FileSystems","text":"<pre><code>Path path = FileSystems.getDefault().getPath(\"fichero.txt\");\n</code></pre>"},{"location":"ud9/15javanio/#escritura-en-un-fichero","title":"Escritura en un fichero","text":"<pre><code>Path p = FileSystems.getDefault().getPath(\"ficPrueba.txt\");\ntry(BufferedWriter bw = Files.newBufferedWriter(p)) {\nfor (int i = 0; i &lt; 10; i++) {\nbw.write(String.valueOf(i));\n}\n} catch (IOException e) {\nthrow new RuntimeException(e);\n}\n</code></pre>"},{"location":"ud9/15javanio/#lectura-de-un-fichero","title":"Lectura de un fichero","text":"<p>Con buffer:</p> <pre><code>Path p = FileSystems.getDefault().getPath(\"ficPrueba.txt\");\ntry (BufferedReader br = Files.newBufferedReader(p)) {\nString input;\nwhile ((input = br.readLine()) != null) {\nSystem.out.println(input);\n}\n} catch (IOException e) {\nthrow new RuntimeException(e);\n}\n\nPath p = FileSystems.getDefault().getPath(\"ficPrueba.txt\");\ntry {\nList&lt;String&gt; lines = Files.readAllLines(p);\nfor (String line: lines) {\nSystem.out.println(line);\n}\n} catch (IOException e) {\nthrow new RuntimeException(e);\n}\n</code></pre>"},{"location":"ud9/15javanio/#listar-todos-los-directorios-con-fileswalk","title":"Listar todos los directorios con Files.walk","text":"<p>Es importante utilizar el try with resources para cerrar el stream. Viene especificado en la documentaci\u00f3n oficial</p> <p>Note</p> <p>This method must be used within a try-with-resources statement or similar control structure to ensure that the stream's open directories are closed promptly after the stream's operations have completed.</p> <pre><code>List&lt;Path&gt; result;\ntry (Stream&lt;Path&gt; walk = Files.walk(path)) {\nresult = walk.filter(Files::isDirectory)\n.collect(Collectors.toList());\n}\n</code></pre>"},{"location":"ud9/16randomaccessfile/","title":"Acceso aleatorio a ficheros","text":"<p>Todos los flujos de E/S que hemos usado hasta ahora se conocen como flujos de solo lectura o solo escritura. Estos flujos se denominan flujos secuenciales en Java.</p> <p>Un fichero que se lee o escribe mediante un flujo secuencial se denomina fichero de acceso secuencial. Los datos de un fichero de acceso secuencial NO se pueden actualizar.</p> <p>Por lo tanto, para leer y escribir datos simult\u00e1neamente, Java proporciona la clase <code>RandomAccessFile</code>. Con esta clase, podemos leer y escribir datos en cualquier ubicaci\u00f3n del fichero. Los archivos de acceso aleatorio son \u00fatiles para muchas aplicaciones diferentes.</p>"},{"location":"ud9/16randomaccessfile/#puntero-de-la-clase-randomaccessfile","title":"Puntero de la clase <code>RandomAccessFile</code>","text":"<p>Un fichero de acceso aleatorio consta de una secuencia de bytes. \u00c9stos, admiten un puntero especial conocido como puntero de fichero (file pointer). El puntero indica la posici\u00f3n actual (ubicaci\u00f3n) en el fichero.</p> <p>Se coloca en uno de estos bytes en el fichero y se puede mover a cualquier posici\u00f3n arbitraria antes de leer o escribir.</p> <p>En otras palabras, se lleva a cabo una operaci\u00f3n de lectura o escritura en la ubicaci\u00f3n del puntero.</p> <p>El puntero se puede mover utilizando el m\u00e9todo <code>seek()</code>.</p> <p>Cuando se crea un fichero por primera vez, el puntero se establece en 0, lo que indica el comienzo del archivo. Cuando leemos o escribimos datos en el archivo usando m\u00e9todos de lectura o escritura, el puntero del archivo avanza al siguiente elemento de datos (es decir, el siguiente byte).</p> <p>Por ejemplo, si leemos un valor int usando el m\u00e9todo readInt() del archivo, JVM lee 4 bytes usando el puntero, y ahora el puntero del archivo est\u00e1 4 bytes por delante de la posici\u00f3n anterior, como se muestra en la figura a continuaci\u00f3n.</p> <p></p> <pre><code>RandomAccessFile raf = ....\n\nraf.seek(position); //mueve el puntero a una posici\u00f3n\nraf.seek(0); //mueve el puntero al inicio del fichero\nraf.seek(raf.length()); //mueve el puntero al final del fichero\n</code></pre>"},{"location":"ud9/16randomaccessfile/#constructor-de-la-clase-randomaccessfile","title":"Constructor de la clase RandomAccessFile","text":"<p>Para construir un objeto de la clase tenemos que especificar el modo (mode) que determina qu\u00e9 tipo de acceso a ficheros est\u00e1 permitido.</p> <ul> <li>r: el fichero es de solo lectura.</li> <li>rw: se abre en modo lectura-escritura.</li> <li>rws: se abre para lectura y escritura y cada cambio en los datos del fichero se escribir\u00e1 inmediatamente en el dispositivo f\u00edsico.</li> </ul> <p>RandomAccessFile raf = new RandomAccessFile(\"myfile.dat\", \"rw\");</p>"},{"location":"ud9/16randomaccessfile/#ejemplo-de-un-programa-que-anade-texto-al-final-de-un-fichero","title":"Ejemplo de un programa que a\u00f1ade texto al final de un fichero","text":"<pre><code>public static void main(String[] args) {\nRandomAccessFile file = null;\ntry {\nfile = new RandomAccessFile(\"file.txt\", \"rw\");\nfile.seek(file.length()); // Moving file pointer to the end.\nfile.writeBytes(\"\\nJava\"); // Append text.\nfile.close();\n} catch (IOException e) {\nthrow new RuntimeException(e);\n}\n}\n</code></pre>"},{"location":"ud9/17configfiles/","title":"Ficheros de configuraci\u00f3n","text":"<p>En Java es habitual guardar algunos par\u00e1metros de configuraci\u00f3n de nuestro programa en un fichero de propiedades. Un fichero de propiedades no es m\u00e1s que un fichero de texto, habitualmente con la extensi\u00f3n \u201c.properties\u201d, en donde cada l\u00ednea tiene una pareja clave=valor.</p> <p>En la API de Java se incluyen librer\u00edas para trabajar con los ficheros de configuraci\u00f3n. Puesto que todos siguen un mismo patr\u00f3n, es la librer\u00eda la que se encarga de acceder al fichero a bajo nivel y el programador s\u00f3lo tiene que indicar a que propiedad quiere acceder o que propiedad quiere modificar, sin tener que a\u00f1adir nada de c\u00f3digo para leer o escribir el fichero tal.</p> <p>Aqu\u00ed se muestra un ejemplo de fichero de configuraci\u00f3n, llamado <code>datasource.properties</code>, que almacena informaci\u00f3n sobre la base de datos:</p> <p></p> <p>La primera l\u00ednea del ejemplo es un comentario, que se indica con #, y las posteriores cada clave, parte izquierda del =, ser\u00e1 un par\u00e1metro de nuestra configuraci\u00f3n separado por un igual donde est\u00e1 su valor correspondiente, parte derecha del =.</p> <p>Java nos proporciona la clase <code>Properties</code>, para leer de forma sencilla los ficheros de configuraci\u00f3n.</p>"},{"location":"ud9/17configfiles/#cargar-el-fichero-de-configuracion","title":"Cargar el fichero de configuraci\u00f3n","text":"<p>Lo primero que haremos ser\u00e1 inicializar nuestro objeto Properties.</p> <pre><code>Properties properties = new Properties();\n</code></pre> <p>Esta clase tiene un m\u00e9todo <code>load()</code> que permite cargar el fichero. No tenemos m\u00e1s que pasarle un <code>InputStream</code> o un <code>Reader</code> de java.</p> <pre><code>properties.load(new FileReader(\"datasource.properties\"));\n</code></pre>"},{"location":"ud9/17configfiles/#leer-una-propiedad","title":"Leer una propiedad","text":"<p>El m\u00e9todo <code>properties.getProperty(String)</code> nos permite, pas\u00e1ndole una clave, obtener el valor asociado a ella. En nuestro ejemplo, pasando como clave \"db.username\", obtendr\u00edamos el valor asociado a ella \"admin\" (siempre como String, aunque sea un n\u00famero).</p> <p>Si la clave no existe, obtendremos <code>null</code> como resultado. Sin embargo, tenemos una variante de <code>getProperty()</code> que permite obtener un valor por defecto en caso de que no exista la clave, como en el siguiente c\u00f3digo:</p> <pre><code>properties.getProperty(\"db.username\", \"default value\"));\n</code></pre> <p>Al m\u00e9todo <code>getProperty()</code> le pasamos como primer par\u00e1metro la clave cuyo valor queremos obtener, y como segundo par\u00e1metro el valor que queremos por defecto, en caso de que la clave no tenga valor asociado.</p>"},{"location":"ud9/17configfiles/#leer-todas-las-propiedades","title":"Leer todas las propiedades","text":"<p>La clase <code>Properties</code> tiene varios m\u00e9todos que nos permiten obtener todas las claves que hay en el fichero. Para ello recurriremos a un objeto <code>Enumeration</code> que nos permitir\u00e1 iterar sobre ellas. En este objeto almacenamos todas las claves de nuestro properties. Recorriendo estas claves, podemos obtener todos los valores. El siguiente c\u00f3digo consulta todas las claves con el m\u00e9todo <code>keys()</code> y luego realiza un bucle para ir sacando por pantalla todos los valores.</p> <pre><code>Enumeration&lt;Object&gt; keys = properties.keys(); while (keys.hasMoreElements()) {\nObject key = keys.nextElement(); System.out.println(key + \" = \"+ properties.get(key));\n}\n</code></pre>"},{"location":"ud9/17configfiles/#anadir-o-modificar-una-propiedad","title":"A\u00f1adir o modificar una propiedad","text":"<p>Para a\u00f1adir/modificar el valor de una propiedad, la clase <code>Properties</code> tiene un m\u00e9todo llamado <code>setProperty(String key, String value)</code> que te permite a\u00f1adir una pareja clave/valor nuevas o modificar una ya existente.</p> <pre><code>properties.setProperty(\"db.port\", \"4020\");\n</code></pre> <p>Una vez que hemos modificado/a\u00f1adido valores, tendremos que guardar el fichero. Para ello la clase <code>Properties</code> tiene dos m\u00e9todos: <code>save()</code> y <code>store()</code>. El m\u00e9todo <code>save()</code> est\u00e1 obsoleto, por lo que no se aconseja su uso. Para guardar los cambios, debemos llamar a <code>store()</code> pas\u00e1ndole un <code>OutputStream</code> o un <code>Writer</code> de java.</p> <pre><code>properties.store(new FileWriter(\"datasource.properties\"),\"Added database port\");\n</code></pre> <p>El m\u00e9todo <code>store()</code> admite un segundo par\u00e1metro que es un comentario que se a\u00f1adir\u00e1 como una l\u00ednea de cabecera en el fichero. El resultado de esta llamada es un fichero con un contenido como el siguiente:</p> <p></p> <p>Contiene el comentario que pusimos en la llamada a <code>store()</code> y la fecha, que la inserta de regalo.</p>"},{"location":"ud9/18xmlfiles/","title":"Ficheros XML","text":"<p>XML es la abreviatura de Extensible Markup Language y es un formato de intercambio de datos establecido. XML fue definido en 1998 por el World Wide Web Consortium (W3C). A diferencia de otros lenguajes, XML da soporte a bases de datos, siendo \u00fatil cuando varias aplicaciones deben comunicarse entre s\u00ed o integrar informaci\u00f3n.</p>"},{"location":"ud9/18xmlfiles/#estructura-de-un-documento-xml","title":"Estructura de un documento XML","text":"<p>Un documento XML consta de elementos, cada elemento tiene una etiqueta de inicio, contenido y una etiqueta de finalizaci\u00f3n. Una etiqueta consiste en una marca hecha en el documento, que se\u00f1ala una porci\u00f3n de este como un elemento. Un pedazo de informaci\u00f3n con un sentido claro y definido. Las etiquetas tienen la forma <code>&lt;nombre&gt;</code>, donde nombre es el nombre del elemento que se est\u00e1 se\u00f1alando.</p>"},{"location":"ud9/18xmlfiles/#documento-xml-valido","title":"Documento XML v\u00e1lido","text":"<p>Los documentos denominados como \u00abbien formados\u00bb (del ingl\u00e9s well formed) son aquellos que cumplen con todas las definiciones b\u00e1sicas de formato y pueden, por lo tanto, analizarse correctamente por cualquier analizador sint\u00e1ctico (parser) que cumpla con la norma. Esto significa que debe aplicarse a las siguientes condiciones:</p> <ol> <li>Cada etiqueta de apertura tiene una etiqueta de cierre.</li> <li>Todas las etiquetas est\u00e1n completamente anidadas.</li> <li>Los documentos XML solamente permiten un elemento ra\u00edz del que todos los dem\u00e1s sean parte, es decir, solo pueden tener un elemento inicial.</li> <li>El XML es sensible a may\u00fasculas y min\u00fasculas.</li> </ol>"},{"location":"ud9/18xmlfiles/#partes-de-un-documento-xml","title":"Partes de un documento XML","text":""},{"location":"ud9/18xmlfiles/#prologo","title":"Pr\u00f3logo","text":"<p>Aunque no es obligatorio, los documentos XML pueden empezar con unas l\u00edneas que describen la versi\u00f3n XML, el tipo de documento y otras cosas.</p> <p>El pr\u00f3logo de un documento XML contiene:</p> <ul> <li>Una declaraci\u00f3n XML. Es la sentencia que declara al documento como un documento XML.</li> <li>Una declaraci\u00f3n de tipo de documento. Enlaza el documento con su DTD (definici\u00f3n de tipo de documento), o el DTD puede estar incluido en la propia declaraci\u00f3n o ambas cosas al mismo tiempo.</li> <li>Uno o m\u00e1s comentarios e instrucciones de procesamiento. Ejemplo:</li> </ul> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n</code></pre>"},{"location":"ud9/18xmlfiles/#cuerpo","title":"Cuerpo","text":"<p>A diferencia del pr\u00f3logo, el cuerpo no es opcional en un documento XML, el cuerpo debe contener solo un elemento ra\u00edz, caracter\u00edstica indispensable tambi\u00e9n para que el documento est\u00e9 bien formado. Sin embargo es necesaria la adquisici\u00f3n de datos para su buen funcionamiento.</p>"},{"location":"ud9/18xmlfiles/#elementos","title":"Elementos","text":"<p>Los elementos XML pueden tener contenido (m\u00e1s elementos, caracteres o ambos), o bien ser elementos vac\u00edos.</p>"},{"location":"ud9/18xmlfiles/#atributos","title":"Atributos","text":"<p>Los elementos pueden tener atributos, que son una manera de incorporar caracter\u00edsticas o propiedades a los elementos de un documento. Deben ir entre comillas.</p> <pre><code>&lt;person sex=\"female\"&gt;\n&lt;firstname&gt;Patricia&lt;/firstname&gt;\n&lt;lastname&gt;Marti&lt;/lastname&gt;\n&lt;/person&gt;\n</code></pre> <p>En el ejemplo, el elemento <code>person</code> tiene un atributo <code>sex</code>.</p>"},{"location":"ud9/18xmlfiles/#comentarios","title":"Comentarios","text":"<p>Comentarios a modo informativo para el programador que han de ser ignorados por el procesador. Los comentarios en XML tienen el siguiente formato:</p> <pre><code>  &lt;!-- Comment --&gt;\n</code></pre>"},{"location":"ud9/18xmlfiles/#ejemplo-de-un-documento-xml","title":"Ejemplo de un documento XML","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"&gt;\n\n&lt;!-- This is a comment --&gt;\n\n&lt;products&gt; &lt;product&gt; &lt;name&gt;Cereales&lt;/name&gt; &lt;price&gt;3.45&lt;/price&gt; &lt;/product&gt; &lt;product&gt; &lt;name&gt;Colacao&lt;/name&gt; &lt;price&gt;1.45&lt;/price&gt; &lt;/product&gt; &lt;product&gt; &lt;name&gt;Agua mineral&lt;/name&gt; &lt;price&gt;1.00&lt;/price&gt; &lt;/product&gt; &lt;/products&gt;\n</code></pre>"},{"location":"ud9/18xmlfiles/#url-xml","title":"Url XML","text":"<p>El est\u00e1ndar XML</p>"},{"location":"ud9/18xmlfiles/#java-xml","title":"Java XML","text":"<p>Java permite usar analizadores XML como DOM, SAX, StAX y JDOM para leer y escribir documentos XML; Adem\u00e1s, JAXB para convertir XML a/desde objetos.</p> <p>En general, existen dos modelos de programaci\u00f3n para trabajar con documentos XML: DOM y SAX (Streaming).</p>"},{"location":"ud9/18xmlfiles/#dom","title":"DOM","text":"<p>El modelo de objeto de documento (DOM) utiliza nodos para representar los documentos XML completos como una estructura de \u00e1rbol y almacenarlos en la memoria.</p> <p>DOM es bueno para manipular el archivo XML peque\u00f1o, como leer, escribir y modificar la estructura XML; DOM NO es para analizar o manipular archivos XML grandes porque construir la estructura XML completa en la memoria consume mucha memoria.</p>"},{"location":"ud9/18xmlfiles/#sax","title":"SAX","text":"<p>La API simple para XML (SAX) permite leer el archivo XML de principio a fin, es decir, de manera secuencial.</p> <p>El SAX es r\u00e1pido y eficiente, requiere mucha menos memoria que DOM porque SAX no crea una representaci\u00f3n interna (estructura de \u00e1rbol) de los datos XML, como lo hace un DOM.</p>"},{"location":"ud9/18xmlfiles/#stax","title":"StAX","text":"<p>Streaming API for XML (StAX) est\u00e1 basado en eventos, permite leer y escribir documentos XML. StAX ofrece un modelo de programaci\u00f3n m\u00e1s simple que SAX y una gesti\u00f3n de memoria m\u00e1s eficiente que DOM.</p>"},{"location":"ud9/18xmlfiles/#ejemplo-lectura-xml-desde-una-api","title":"Ejemplo lectura XML desde una API","text":"<pre><code>private static Document loadXMLDocument(String url)  {\ntry (InputStream input = new URL(url).openStream()) {\nDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\nDocumentBuilder builder = factory.newDocumentBuilder();\nreturn builder.parse(input);\n} catch (Exception e) {\nthrow new RuntimeException(e);\n}\n}\n</code></pre>"},{"location":"ud9/18xmlfiles/#escritura-de-un-documento-xml","title":"Escritura de un documento XML","text":"<pre><code>private static void writeXml(Document doc,\nOutputStream output)\nthrows TransformerException {\n\nTransformerFactory transformerFactory = TransformerFactory.newInstance();\nTransformer transformer = transformerFactory.newTransformer();\ntransformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\nDOMSource source = new DOMSource(doc);\nStreamResult result = new StreamResult(output);\ntransformer.transform(source, result);\n\n}\n</code></pre>"},{"location":"ud9/19jsonfiles/","title":"Ficheros JSON","text":"<p>JSON (JavaScript Object Notation) es un formato ligero de intercambio de datos. Es un fichero f\u00e1cil de leer y escribir para los humanos y tambi\u00e9n f\u00e1cil de analizar y generar para las m\u00e1quinas. Se basa en un subconjunto del lenguaje de programaci\u00f3n JavaScript. Debido a su amplia adopci\u00f3n como alternativa a XML. JSON es un formato de texto que es completamente independiente del lenguaje pero utiliza convenciones que son ampliamente conocidos por los programadores de la familia de lenguajes C, incluyendo C, C++, C#, Java, JavaScript, Perl, Python, y muchos otros. Estas propiedades hacen que JSON sea un lenguaje ideal para el intercambio de datos.</p> <p>JSON se utiliza hoy en d\u00eda en cada API web \u00fanica.</p> <p>JSON se basa en dos estructuras que son universales; virtualmente todos los lenguajes de programaci\u00f3n las soportan de una forma u otra:</p> <ul> <li>Una colecci\u00f3n de pares de name/value. En varios lenguajes, esto se realiza como un objeto, registro, estructura, diccionario, tabla hash, lista con clave o matriz asociativa.</li> <li>Una lista ordenada de valores. En la mayor\u00eda de los lenguajes, esto se realiza como una matriz, vector, lista o secuencia.</li> </ul>"},{"location":"ud9/19jsonfiles/#tipos-de-datos-disponibles","title":"Tipos de datos disponibles","text":"<ol> <li>N\u00fameros: Se permiten n\u00fameros negativos y opcionalmente pueden contener parte fraccional separada por puntos. Ejemplo: 123.456</li> <li>Cadenas: Representan secuencias de cero o m\u00e1s caracteres. Se ponen entre doble comilla y se permiten cadenas de escape. Ejemplo: \"Hola\"</li> <li>Booleanos: Representan valores booleanos y pueden tener dos valores: true y false</li> <li>null: Representan el valor nulo.</li> <li>Array: Representa una lista ordenada de cero o m\u00e1s valores los cuales pueden ser de cualquier tipo. Los valores se separan por comas y el vector se mete entre corchetes.</li> <li>Objetos: Son colecciones no ordenadas de pares de la forma <code>nombre:valor</code> separados por comas y puestas entre llaves. El nombre tiene que ser una cadena entre comillas dobles. El valor puede ser de cualquier tipo.</li> </ol>"},{"location":"ud9/19jsonfiles/#formato-json","title":"Formato JSON","text":"<ul> <li>Un objeto es un conjunto desordenado de pares de name/value. Un objeto comienza con {(llave izquierda) y termina con} (llave derecha). Cada nombre va seguido de: (dos puntos) y los pares de name/value est\u00e1n separados por, (coma).</li> </ul> <ul> <li>Un array es una colecci\u00f3n ordenada de valores. Una matriz comienza con [(corchete izquierdo) y termina con] (corchete derecho). Los valores est\u00e1n separados por (coma).</li> </ul> <ul> <li>Un value puede ser una cadena entre comillas dobles, un n\u00famero, verdadero, falso, nulo, un objeto o una matriz. Estas estructuras se pueden anidar.</li> </ul>"},{"location":"ud9/19jsonfiles/#ejemplo-de-fichero-json","title":"Ejemplo de fichero JSON","text":"<pre><code># Fichero JSON {\"web-app\": {\n\"servlet\": [   {\n\"servlet-name\": \"cofaxCDS\",\n\"servlet-class\": \"org.cofax.cds.CDSServlet\",\n\"init-param\": {\n\"configGlossary:installationAt\": \"Philadelphia, PA\",\n\"configGlossary:adminEmail\": \"p.marti2@edu.gva.es\",\n\"configGlossary:poweredBy\": \"Patricia Marti\",\n\"configGlossary:poweredByIcon\": \"/images/cofax.gif\",\n\"configGlossary:staticPath\": \"/content/static\",\n\"templateProcessorClass\": \"org.cofax.WysiwygTemplate\",\n\"templateLoaderClass\": \"org.cofax.FilesTemplateLoader\",\n\"templatePath\": \"templates\",\n\"templateOverridePath\": \"\",\n\"defaultListTemplate\": \"listTemplate.htm\",\n\"defaultFileTemplate\": \"articleTemplate.htm\",\n\"useJSP\": false,\n\"dataStoreMaxConns\": 100\n}\n},\nnull,\n{\n\"servlet-name\": \"cofaxEmail\",\n\"servlet-class\": \"org.cofax.cds.EmailServlet\",\n\"init-param\": {\n\"mailHost\": \"mail1\",\n\"mailHostOverride\": \"mail2\"\n}\n}],\n\"servlet-mapping\": {\n\"cofaxCDS\": \"/\",\n\"cofaxEmail\": \"/cofaxutil/aemail/*\",\n\"cofaxAdmin\": \"/admin/*\",\n\"fileServlet\": \"/static/*\",\n\"cofaxTools\": \"/tools/*\"\n},\n\"taglib\": {\n\"taglib-uri\": \"cofax.tld\",\n\"taglib-location\": \"/WEB-INF/tlds/cofax.tld\"\n}\n}\n}\n</code></pre> <p>El fichero anterior se puede traducir como un array de objetos, por ejemplo de la clase <code>Servlet</code>, donde la clase <code>Servlet</code> estar\u00e1 compuesta por atributos como: servlet-name, servlet-class, etc.</p> <p>Existen varias librer\u00edas en Java para parsear ficheros JSON. Entre las m\u00e1s comunes est\u00e1n: Gson, Jackson, JSON.simple, org.json, JsonPATH, etc.</p>"},{"location":"ud9/19jsonfiles/#url-oficial","title":"URL oficial","text":"<p>The JSON Specification</p>"},{"location":"ud9/19jsonfiles/#json-vs-xml","title":"JSON vs XML","text":""},{"location":"ud9/19jsonfiles/#java-json","title":"Java JSON","text":"<p>Java por defecto no ofrece ninguna funcionalidad integrada para analizar o crear JSON, en lugar de eso, tendremos que confiar en una biblioteca/paquete de terceros.</p> <p>En la actualidad existen varias librer\u00edas para pasar transformar un objeto Java en una cadena JSON (serializaci\u00f3n) o viceversa (deserializaci\u00f3n).</p> <p>Desde la p\u00e1gina en donde se encuentra la especificaci\u00f3n de JSON se indican las librer\u00edas m\u00e1s conocidas para tratar/generar informaci\u00f3n relativa al formato JSON en los diferentes lenguajes de programaci\u00f3n.</p> <p>Vamos a ver c\u00f3mo parsear un JSON utilizando el paquete org.json. Los archivos en este paquete implementan codificadores/decodificadores JSON en Java.</p>"},{"location":"ud9/19jsonfiles/#leer-un-json-a-partir-de-una-api","title":"Leer un JSON a partir de una API","text":"<pre><code>//Este m\u00e9todo accede a una URL y se descarga el contenido en forma de String\npublic static String stream(String url) {\ntry (InputStream input = new URL(url).openStream()) {\nInputStreamReader isr = new InputStreamReader(input);\nBufferedReader reader = new BufferedReader(isr);\nStringBuilder json = new StringBuilder();\nint c;\nwhile ((c = reader.read()) != -1) {\njson.append((char) c);\n}\nreturn json.toString();\n} catch (IOException e) {\nthrow new RuntimeException(e);\n}\n}\n\npublic static void main(String[] args) {\nString caturl = \"https://catfact.ninja/facts\";\n\n//parseamos un string a un JSONObject\nJSONObject jsonObject = new JSONObject(stream(caturl));\nJSONArray a = jsonObject.getJSONArray(\"data\");\nJSONObject o = (JSONObject) a.get(0);\nSystem.out.println(o.getString(\"fact\"));\n\n}\n</code></pre> <p>Un <code>JSONObject</code> es una colecci\u00f3n desordenada de pares clave y valor, que se asemeja a las implementaciones Map nativas de Java.</p>"},{"location":"ud9/1io/","title":"I/O Input/Output - Entrada/Salida de la informaci\u00f3n","text":"<p>Todo dato tiene un origen de entrada o un destino de salida (convenientemente en ingl\u00e9s: I/O). Input o entrada implica leer datos de una fuente y Output o salida implica escribirlos en un destino. Un programa trabaja con datos que provienen de una entrada la cual puede ser un teclado, un archivo en disco o un socket a trav\u00e9s de la red. As\u00ed mismo un programa genera resultados envi\u00e1ndolos a una salida la cual puede ser la pantalla, un archivo en disco o un socket a trav\u00e9s de la red. En Java, la conexi\u00f3n entre un programa y un origen o destino de datos se denomina flujo (en ingl\u00e9s: stream).</p> <p></p> <p>Un flujo de entrada (input stream) maneja los datos que fluyen hacia un programa. Un flujo de salida (output stream) maneja los datos que salen de un programa.</p> <p></p> <p>En las primeras versiones de Java el sistema de entrada/salida proporcionado en el paquete <code>java.io</code> era b\u00e1sico. En la versi\u00f3n 1.4 de Java se a\u00f1adi\u00f3 un nuevo sistema de entrada/salida llamado <code>java.NIO</code> (New IO) para suplir algunas de sus deficiencias que posteriormente en Java 7 se mejor\u00f3 a\u00fan m\u00e1s <code>java.NIO</code>. Entre las mejoras se incluyen permitir navegaci\u00f3n de directorios sencillo, soporte para reconocer enlaces simb\u00f3licos, leer atributos de ficheros como permisos e informaci\u00f3n como \u00faltima fecha de modificaci\u00f3n, soporte de entrada/salida as\u00edncrona y soporte para operaciones b\u00e1sicas sobre ficheros como copiar y mover ficheros.</p>"},{"location":"ud9/1io/#tipos-de-datos-caracteres-y-bytes","title":"Tipos de Datos - Caracteres y bytes","text":"<p>Existen dos tipos de flujos (streams) seg\u00fan el tipo de datos, flujos binarios y flujos de caracteres. Los tipos de datos que se pueden leer/escribir suelen ser bytes o caracteres y los m\u00e9todos que se utilizan son similares, pero se utilizan clases diferentes.</p> <p>Internamente, todos los datos consisten en patrones de bits agrupados en bytes. Entonces, l\u00f3gicamente, todos los flujos podr\u00edan llamarse \"flujos de bytes\" (byte streams). Sin embargo, los flujos destinados a bytes que representan caracteres se denominan \"flujos de caracteres\" (character streams) y todos los dem\u00e1s se denominan \"flujos de bytes\".</p> <p>Al escribir y leer datos de caracteres, \u00e9stos est\u00e1n en un formato legible para el ser humano, sin embargo, los datos binarios implican leer y escribir bytes que no son legibles si los abrimos en un editor de texto.</p> <ul> <li>Flujos binarios (byte streams): almacenan variables, clases del programa, archivos de imagen, sonido, etc. Por ejemplo, el archivo de c\u00f3digo de bytes creado por el compilador de Java contiene instrucciones de m\u00e1quina para la m\u00e1quina virtual de Java. Estos no est\u00e1n destinados a representar caracteres, y la entrada y salida de ellos debe usar flujos de bytes. Las clases principales para manejar estos flujos son las clases abstractas InputStream y OutputStream.</li> </ul> <p>Clases principales de InputStream:</p> <p></p> <p>Clases principales de OutputStream:</p> <p></p> <ul> <li>Flujos de caracteres (character streams): est\u00e1n optimizados para datos de caracteres. Se utilizan con frecuencia para leer/escribir ficheros de texto, xml y json. Las clases principales para manejar estos flujos son las clases abstractas Reader y Writer.</li> </ul> <p>Clases principales de Reader:</p> <p></p> <p>Clases principales de Writer:</p> <p></p> <p>La siguiente figura muestra la jerarqu\u00eda del paquete <code>java.io</code>. Los streams pueden estar orientados a bytes u orientados a caracteres. Cada tipo tiene flujos de entrada y flujos de salida.</p> <p></p>"},{"location":"ud9/1io/#flujos-orientados-a-bytes","title":"Flujos orientados a bytes","text":"<ul> <li>Dise\u00f1ado para entrada y salida de prop\u00f3sito general.</li> <li>Los datos pueden ser tipos de datos primitivos o bytes sin procesar.</li> </ul>"},{"location":"ud9/1io/#flujos-orientados-a-caracteres","title":"Flujos orientados a caracteres","text":"<ul> <li>Destinado a datos de caracteres.</li> <li>Los datos se transforman de/a caracteres Java de 16 bits utilizados dentro de los programas al formato utilizado externamente.</li> </ul>"},{"location":"ud9/1io/#ficheros","title":"Ficheros","text":"<p>Un fichero es un conjunto l\u00f3gico de informaci\u00f3n o de datos que se designa con un nombre y se configura como una unidad aut\u00f3noma completa para el sistema o el usuario. Un archivo o fichero inform\u00e1tico es un conjunto de bits que son almacenados en un dispositivo. Para poder acceder a ellos haremos uso de una ruta (path) ya sea relativa o absoluta.</p> <p></p>"},{"location":"ud9/1io/#tipos-de-acceso-a-ficheros","title":"Tipos de acceso a ficheros","text":"<ol> <li> <p>Acceso secuencial: Una lectura secuencial implica tener que acceder a un elemento antes de acceder al siguiente, es decir, de una manera lineal (sin saltos). Las clases <code>InputStream</code> y <code>OutputStream</code> son secuenciales.</p> </li> <li> <p>Acceso aleatorio: los ficheros de acceso aleatorio permiten acceder a sus datos de una forma aleatoria, esto es indicando una determinada posici\u00f3n desde la que leer/escribir.</p> </li> </ol>"},{"location":"ud9/20createjar/","title":"C\u00f3mo crear un jar en IntelliJ","text":"<ol> <li>Vamos a File --&gt; Project Structure</li> </ol> <ol> <li>En la secci\u00f3n Artifacts, seleccionamos el s\u00edmbolo \"+\" y seleccionamos el formato .jar --&gt; \"From modules with dependencies\"</li> </ol> <ol> <li>Le decimos cu\u00e1l es la clase main y aceptamos.</li> </ol> <ol> <li>Todav\u00eda no hemos construido el .jar. Para crearlo vamos al men\u00fa \"Build\" --&gt; \"Build Artifact\".</li> </ol> <ol> <li>Seleccionamos \"Build\".</li> </ol> <p>El .jar estar\u00e1 en la carpeta del proyecto dentro de /out/artifacts/...</p>"},{"location":"ud9/21tryresources/","title":"\ud83e\udd73 try-with-resources","text":"<p>La sentencia try-with-resources es una sentencia try que declara uno o m\u00e1s recursos (resources). Un recurso es un objeto que debe cerrarse despu\u00e9s de que el programa termine con \u00e9l. La instrucci\u00f3n try-with-resources garantiza que cada recurso se cierre al final de la instrucci\u00f3n. Cualquier objeto que implemente java.lang.AutoCloseable, que incluye todos los objetos que implementen java.io.Closeable, se puede utilizar como recurso, por lo que no ser\u00eda necesario realizar la sentencia <code>recurso.close()</code>.</p> <p>Antes de Java SE 7, se pod\u00eda usar un bloque <code>finally</code> para asegurarse de que un recurso se cerraba, independientemente de si el try generaba excepci\u00f3n o no.</p> <p>El siguiente ejemplo, creamos el objeto <code>FileWriter</code> en la l\u00ednea 2, en vez de hacerlo en la 4 porque el <code>finally</code> de la l\u00ednea 8 se encuentra en otro scope y la variable <code>fw</code> no existe.</p> <pre><code>public static void main(String[] args) {\nFileWriter fw =null;\ntry {\nfw = new FileWriter(\"prueba.txt\");\nfw.write(\"texto de prueba\");\n} catch (IOException e) {\ne.printStackTrace();\n} finally {\ntry {\nif (fw != null) {\nSystem.out.println(\"El fichero se cierra\");\nfw.close();\n}\n}catch (IOException e) {\ne.printStackTrace();\n}\n}\n}\n</code></pre> <p>Al hacer el <code>close()</code> manualmente, vemos que el c\u00f3digo queda bastante engorroso, ya que la sentencia close lanza una excepci\u00f3n que hay que capturar. Con try-with-resources el c\u00f3digo queda m\u00e1s limpio.</p> <p>Importante diferencia entre try-with-resources y try con finally \ud83e\udd14</p> <p>Existe una ligera mejora al usar try-with-resources. Si en el c\u00f3digo anterior se lanzara una excepci\u00f3n al escribir el fichero, \u00e9sta se capturar\u00eda y se ejecutar\u00eda el finally a continuaci\u00f3n. Si \u00e9ste a su vez, lanzara tambi\u00e9n una excepci\u00f3n al llamar al m\u00e9todo <code>close</code>, se reenviar\u00eda esta, NO la primera que se gener\u00f3. Esto cambia ligeramente en el try-with-resources, puesto que enviar\u00eda la primera excepci\u00f3n que se gener\u00f3. Lo cual tiene sentido, puesto que fue la causante del error.</p> <p>As\u00ed quedar\u00eda el c\u00f3digo usando try-with-resources:</p> <pre><code>public static void main (String[] args) throws IOException {\ntry(FileWriter fw = new FileWriter(\"prueba.txt\");\nFileWriter fw2 = new FileWriter(\"prueba2.txt\");) {\n//si quisiera poner un segundo writer quedar\u00eda as\u00ed\n\nfw.write(\"texto de prueba\");\n}\n}\n</code></pre> <p>Nota \ud83e\udd13</p> <p>Podemos declarar varios recursos dentro de un mismo try como se ve en el ejemplo.</p>"}]}